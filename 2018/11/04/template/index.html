<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">ACM模板 | Kaizyn&#39;s Blog</title>
  
    <link rel="shortcut icon" href="/images/favicon32.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" type="text/css" href="/css/matery.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "Kaizyn'sBlog";
  mashiro_option.author_name = "Blog";
  mashiro_option.site_url = "https://kaizynx.github.io/";
  mashiro_option.v_appId = "thHO16MtUqCFt5ytzki9wwNG-gzGzoHsz";
  mashiro_option.v_appKey = "RztxTMKSVDyuAaC0BVM1wPM1";
  mashiro_option.mathjax = "1";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/cover/001.jpg,https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/cover/002.jpg,https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/cover/003.jpg,https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/cover/004.jpg,https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/cover/005.jpg,https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/cover/006.jpg,https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/cover/007.jpg,https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/cover/008.jpg,https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/cover/009.jpg".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
  
  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>
  .pace .pace-progress {  background: #1E92FB; /*进度条颜色*/
  height: 3px;  }
  .pace .pace-progress-inner {  box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
  }
  .pace .pace-activity {  border-top-color: #1E92FB;    /*上边框颜色*/
  border-left-color: #1E92FB;    /*左边框颜色*/
  }</style>

</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop ">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://kaizynx.github.io/">
          <img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/custom/avatar.gif">
        </a>
      </div>
      <div class="header-info">
        <p>一只菜鸡的博客</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://github.com/KaizynX" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://www.zhihu.com/people/kaizyn" target="_blank" class="social-github" title="zhihu">
                    <img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/social/zhihu.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="mailto:2291443901@qq.com" target="_blank" class="social-github" title="email">
                    <img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/social/email.svg">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=2291443901" target="_blank" class="social-github" title="qq">
                    <img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/social/qq.png">
                  </a>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">Kaizyn&#39;s</span>
            <span class="shironeko">Blog</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome fa-headphones" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories">
                          <i class="fa fa-list-ul faa-vertical" aria-hidden="true"></i>
                          分类
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags">
                          <i class="fa fa-tags faa-bounce" aria-hidden="true"></i>
                          标签
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    留言板
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    大佬链
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/donate/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
                    投食
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我?
                        </a>
                      </li>
                    
                      <li>
                        <a href="https://github.com/honjun/hexo-theme-sakura">
                          <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                          主题
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/atom.xml">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
                    RSS
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>
<div class="pattern-center single-center">
  <!-- 有配图默认渲染第一张 -->
  
  <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/posts/template/cover.jpg);" src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/post-loading.gif" data-src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/posts/template/cover.jpg">
  </div>
  
  <header class="pattern-header single-header">
    <h1 class="entry-title">
    ACM模板</h1>
    <p class="entry-census">
        <span>
          <a href="https://kaizynx.github.io/">
            <img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/custom/avatar.jpg">
          </a>
        </span>
        <span>
          <a href="https://kaizynx.github.io/">Kaizyn</a>
        </span>
        <span class="bull">
        ·</span>
        2018-11-4<span class="bull">
        ·</span>
    <span id="busuanzi_value_page_pv"></span>次阅读</p>
  </header>
</div>
<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        <!--  -->
        <div class="entry-content">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">while</span> (<span class="literal">true</span>) ++++++ ++++++ ++++++ RP;
</code></pre>

    </div>
</div>
<a id="more"></a>
<hr>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="快读快写"><a href="#快读快写" class="headerlink" title="快读快写"></a>快读快写</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>{
  <span class="keyword">int</span> c; T tag = <span class="number">1</span>;
  <span class="keyword">while</span>(!<span class="built_in">isdigit</span>((c=getchar()))) <span class="keyword">if</span>(c == <span class="string">'-'</span>) tag = <span class="number">-1</span>;
  x = c-<span class="string">'0'</span>;
  <span class="keyword">while</span>(<span class="built_in">isdigit</span>((c=getchar()))) x = (x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>) + c-<span class="string">'0'</span>;
  x *= tag;
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>{
  <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>);
  <span class="keyword">if</span>(x &gt; <span class="number">9</span>) write(x/<span class="number">10</span>);
  <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);
}
</code></pre>

    </div>
</div>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp">ios::sync_with_stdio(<span class="literal">false</span>); <span class="built_in">cin</span>.tie(<span class="literal">NULL</span>); <span class="built_in">cout</span>.tie(<span class="literal">NULL</span>);
</code></pre>

    </div>
</div>
<p><a href="https://atcoder.jp/contests/hitachi2020/submissions/10676875" target="_blank" rel="noopener">巨佬模板</a><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Scanner</span> {</span>
  FILE* fp = <span class="literal">nullptr</span>;
  <span class="keyword">char</span> line[(<span class="number">1</span> &lt;&lt; <span class="number">15</span>) + <span class="number">1</span>];
  <span class="keyword">size_t</span> st = <span class="number">0</span>, ed = <span class="number">0</span>;
  <span class="function"><span class="keyword">void</span> <span class="title">reread</span><span class="params">()</span> </span>{
    memmove(line, line + st, ed - st);
    ed -= st;
    st = <span class="number">0</span>;
    ed += fread(line + ed, <span class="number">1</span>, (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) - ed, fp);
    line[ed] = <span class="string">'\0'</span>;
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">succ</span><span class="params">()</span> </span>{
    <span class="keyword">while</span> (<span class="literal">true</span>) {
      <span class="keyword">if</span> (st == ed) {
        reread();
        <span class="keyword">if</span> (st == ed) <span class="keyword">return</span> <span class="literal">false</span>;
      }
      <span class="keyword">while</span> (st != ed &amp;&amp; <span class="built_in">isspace</span>(line[st])) st++;
      <span class="keyword">if</span> (st != ed) <span class="keyword">break</span>;
    }
    <span class="keyword">if</span> (ed - st &lt;= <span class="number">50</span>) reread();
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">enable_if_t</span>&lt;is_same&lt;T, string&gt;::value, int&gt; = 0&gt;</span>
<span class="class">  <span class="title">bool</span> <span class="title">read_single</span>(<span class="title">T</span>&amp; <span class="title">ref</span>) {</span>
    <span class="keyword">if</span> (!succ()) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">while</span> (<span class="literal">true</span>) {
      <span class="keyword">size_t</span> sz = <span class="number">0</span>;
      <span class="keyword">while</span> (st + sz &lt; ed &amp;&amp; !<span class="built_in">isspace</span>(line[st + sz])) sz++;
      ref.append(line + st, sz);
      st += sz;
      <span class="keyword">if</span> (!sz || st != ed) <span class="keyword">break</span>;
      reread();
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">enable_if_t</span>&lt;is_integral&lt;T&gt;::value, int&gt; = 0&gt;</span>
<span class="class">  <span class="title">bool</span> <span class="title">read_single</span>(<span class="title">T</span>&amp; <span class="title">ref</span>) {</span>
    <span class="keyword">if</span> (!succ()) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">bool</span> neg = <span class="literal">false</span>;
    <span class="keyword">if</span> (line[st] == <span class="string">'-'</span>) {
      neg = <span class="literal">true</span>;
      st++;
    }
    ref = T(<span class="number">0</span>);
    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(line[st])) {
      ref = <span class="number">10</span> * ref + (line[st++] - <span class="string">'0'</span>);
    }
    <span class="keyword">if</span> (neg) ref = -ref;
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">bool</span> <span class="title">read_single</span>(<span class="title">V</span>&lt;T&gt;&amp; <span class="title">ref</span>) {</span>
    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; d : ref) {
      <span class="keyword">if</span> (!read_single(d)) <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>{}
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">H</span>, <span class="title">class</span>... <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">read</span>(<span class="title">H</span>&amp; <span class="title">h</span>, <span class="title">T</span>&amp;... <span class="title">t</span>) {</span>
    <span class="keyword">bool</span> f = read_single(h);
    assert(f);
    read(t...);
  }
  Scanner(FILE* _fp) : fp(_fp) {}
};

<span class="class"><span class="keyword">struct</span> <span class="title">Printer</span> {</span>
  <span class="keyword">public</span>:
  <span class="keyword">template</span> &lt;<span class="keyword">bool</span> F = <span class="literal">false</span>&gt; <span class="keyword">void</span> write() {}
  <span class="keyword">template</span> &lt;<span class="keyword">bool</span> F = <span class="literal">false</span>, class H, class... T&gt;
  <span class="keyword">void</span> write(<span class="keyword">const</span> H&amp; h, <span class="keyword">const</span> T&amp;... t) {
    <span class="keyword">if</span> (F) write_single(<span class="string">' '</span>);
    write_single(h);
    write&lt;<span class="literal">true</span>&gt;(t...);
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">writeln</span>(<span class="title">const</span> <span class="title">T</span>&amp;... <span class="title">t</span>) {</span>
    write(t...);
    write_single(<span class="string">'\n'</span>);
  }

  Printer(FILE* _fp) : fp(_fp) {}
  ~Printer() { flush(); }

  <span class="keyword">private</span>:
  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> SIZE = <span class="number">1</span> &lt;&lt; <span class="number">15</span>;
  FILE* fp;
  <span class="keyword">char</span> line[SIZE], small[<span class="number">50</span>];
  <span class="keyword">size_t</span> pos = <span class="number">0</span>;
  <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>{
    fwrite(line, <span class="number">1</span>, pos, fp);
    pos = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">write_single</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>&amp; val)</span> </span>{
    <span class="keyword">if</span> (pos == SIZE) flush();
    line[pos++] = val;
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">enable_if_t</span>&lt;is_integral&lt;T&gt;::value, int&gt; = 0&gt;</span>
<span class="class">  <span class="title">void</span> <span class="title">write_single</span>(<span class="title">T</span> <span class="title">val</span>) {</span>
    <span class="keyword">if</span> (pos &gt; (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) - <span class="number">50</span>) flush();
    <span class="keyword">if</span> (val == <span class="number">0</span>) {
      write_single(<span class="string">'0'</span>);
      <span class="keyword">return</span>;
    }
    <span class="keyword">if</span> (val &lt; <span class="number">0</span>) {
      write_single(<span class="string">'-'</span>);
      val = -val; <span class="comment">// todo min</span>
    }
    <span class="keyword">size_t</span> len = <span class="number">0</span>;
    <span class="keyword">while</span> (val) {
      small[len++] = <span class="keyword">char</span>(<span class="string">'0'</span> + (val % <span class="number">10</span>));
      val /= <span class="number">10</span>;
    }
    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) {
      line[pos + i] = small[len - <span class="number">1</span> - i];
    }
    pos += len;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">write_single</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) write_single(c);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">write_single</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>{
    <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(s);
    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) write_single(s[i]);
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">write_single</span>(<span class="title">const</span> <span class="title">V</span>&lt;T&gt;&amp; <span class="title">val</span>) {</span>
    <span class="keyword">auto</span> n = val.size();
    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) {
      <span class="keyword">if</span> (i) write_single(<span class="string">' '</span>);
      write_single(val[i]);
    }
  }
};

Scanner sc = Scanner(<span class="built_in">stdin</span>);
Printer pr = Printer(<span class="built_in">stdout</span>);
</code></pre>

    </div>
</div></p>
<hr>
<h2 id="玄学优化-卡常"><a href="#玄学优化-卡常" class="headerlink" title="玄学优化|卡常"></a>玄学优化|卡常</h2><p>吸氧,吸臭氧<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast,no-stack-protector"</span>)</span>
<span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"</span>)</span>
</code></pre>

    </div>
</div></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">char</span> str[];
<span class="built_in">scanf</span>(<span class="string">"%3s"</span>, str); <span class="comment">// 读取长度为n的字符串</span>
<span class="built_in">scanf</span>(<span class="string">"%[abc]"</span>, str); <span class="comment">// 读取a,b,c,读到之外的立即停止</span>
<span class="built_in">scanf</span>(<span class="string">"%[a-z0-9]"</span>, str); <span class="comment">// 同上,读取小写字母和数字</span>
<span class="built_in">scanf</span>(<span class="string">"%*[a-z]%s"</span>, str); <span class="comment">// 过滤掉小写字母读取</span>
<span class="built_in">scanf</span>(<span class="string">"%[^a-z]"</span>, str); <span class="comment">// 读取小写字符外字符,^表示非 </span>
<span class="built_in">scanf</span>(<span class="string">"%*c"</span>); <span class="comment">//清理输入缓冲区中第一个字符，也就是上次遗留下的\n</span>
<span class="built_in">scanf</span>(<span class="string">"%[^\n]%*c"</span>,str); <span class="comment">// 相当于gets(str), %*c的作用是吸收\n</span>
</code></pre>

    </div>
</div>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span>
<span class="comment">// 范围 unsigned int</span>
<span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="literal">NULL</span>))</span></span>;
<span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;
<span class="built_in">cout</span> &lt;&lt; rnd() &lt;&lt; <span class="built_in">endl</span>;
</code></pre>
<pre><code class="cpp"><span class="built_in">std</span>::random_device rd;  <span class="comment">//获取随机数种子</span>
<span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">//Standard mersenne_twister_engine seeded with rd()</span>
<span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;&gt; <span class="title">dis</span><span class="params">(<span class="number">0</span>, <span class="number">9</span>)</span></span>;
<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dis(gen) &lt;&lt; <span class="built_in">endl</span>;
</code></pre>
<pre><code class="cpp"><span class="function"><span class="keyword">inline</span> ull <span class="title">xorshift128</span><span class="params">()</span></span>{
  <span class="keyword">static</span> U SX=<span class="number">335634763</span>,SY=<span class="number">873658265</span>,SZ=<span class="number">192849106</span>,SW=<span class="number">746126501</span>;
  U t=SX^(SX&lt;&lt;<span class="number">11</span>);
  SX=SY;
  SY=SZ;
  SZ=SW;
  <span class="keyword">return</span> SW=SW^(SW&gt;&gt;<span class="number">19</span>)^t^(t&gt;&gt;<span class="number">8</span>);
}
<span class="function"><span class="keyword">inline</span> ull <span class="title">myrand</span><span class="params">()</span></span>{<span class="keyword">return</span> (xorshift128()&lt;&lt;<span class="number">32</span>)^xorshift128();}
</code></pre>

    </div>
</div>
<hr>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>双哈希,好多哈希,<a href="https://codeforces.com/contest/1394/problem/B" target="_blank" rel="noopener">题目链接</a><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">HashNumber</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> HN = <span class="number">2</span>;
  <span class="keyword">int</span> a[HN], mod[HN] = {<span class="number">25165843</span>, <span class="number">50331653</span>};
  HashNumber() { <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; HashNumber(<span class="keyword">const</span> U &amp;x) {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; HN; ++i) a[i] = x%mod[i];
  }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> HashNumber &amp;lhs, <span class="keyword">const</span> HashNumber &amp;rhs) {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; HN; ++i) <span class="keyword">if</span> (lhs.a[i] != rhs.a[i]) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> HashNumber &amp;lhs, <span class="keyword">const</span> HashNumber &amp;rhs) {
    <span class="keyword">return</span> !(lhs == rhs);
  }
  HashNumber&amp; <span class="keyword">operator</span> +=(<span class="keyword">const</span> HashNumber &amp;hs) {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; HN; ++i) (a[i] += hs.a[i]) %= mod[i];
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }
  HashNumber&amp; <span class="keyword">operator</span> *=(<span class="keyword">const</span> HashNumber &amp;hs) {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; HN; ++i) a[i] = (<span class="number">1l</span>l*a[i]*hs.a[i])%mod[i];
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }
  <span class="keyword">friend</span> HashNumber <span class="keyword">operator</span> +(<span class="keyword">const</span> HashNumber &amp;lhs, <span class="keyword">const</span> HashNumber &amp;rhs) {
    HashNumber res = lhs;
    <span class="keyword">return</span> res += rhs;
  }
  <span class="keyword">friend</span> HashNumber <span class="keyword">operator</span> *(<span class="keyword">const</span> HashNumber &amp;lhs, <span class="keyword">const</span> HashNumber &amp;rhs) {
    HashNumber res = lhs;
    <span class="keyword">return</span> res *= rhs;
  }
};
</code></pre>

    </div>
</div></p>
<hr>
<h2 id="计算log2"><a href="#计算log2" class="headerlink" title="计算log2"></a>计算log2</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="meta">#<span class="meta-keyword">define</span> log(x) (31-__builtin_clz(x))</span>
<span class="comment">// #define log(x) (63-__builtin_clzll(x))</span>
<span class="comment">// lg2[i] = lg2(i) +1</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) lg2[i] = lg2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;
<span class="comment">// lg2[i] = (int)log2(i)</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg2[i] = lg2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;
</code></pre>

    </div>
</div>
<h2 id="快速开根号-牛顿迭代法"><a href="#快速开根号-牛顿迭代法" class="headerlink" title="快速开根号|牛顿迭代法"></a>快速开根号|牛顿迭代法</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;a)</span> </span>{
  <span class="keyword">double</span> x = a, y = <span class="number">.0</span>;
  <span class="keyword">while</span> (<span class="built_in">abs</span>(x-y) &gt; err) {
    y = x;
    x = <span class="number">.5</span>*(x+a/x);
  }
  <span class="keyword">return</span> x;
}
</code></pre>

    </div>
</div>
<h2 id="i-k-j-的-k-的个数"><a href="#i-k-j-的-k-的个数" class="headerlink" title="i/k == j 的 k 的个数"></a>i/k == j 的 k 的个数</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, l, r; j &lt;= n; ++j) {
    l = max(<span class="number">1</span>, i/(j+<span class="number">1</span>));
    <span class="keyword">while</span> (l<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; i/(l<span class="number">-1</span>) == j) --l;
    <span class="keyword">while</span> (i/l &gt; j) ++l;
    r = i/j;
    <span class="keyword">while</span> (r+<span class="number">1</span> &lt;= i &amp;&amp; i/(r+<span class="number">1</span>) == j) ++r;
    <span class="keyword">while</span> (i/r &lt; j) --r;
    <span class="keyword">if</span> (r-l+<span class="number">1</span> != i/j-i/(j+<span class="number">1</span>)) {
        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;
    }
  }
}
</code></pre>

    </div>
</div>
<h2 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a><a href="https://blog.csdn.net/inf_force/article/details/44891121" target="_blank" rel="noopener">三分法</a></h2><p>示例为凹函数<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">while</span> (l &lt; r) {
  <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
  <span class="keyword">if</span> (f(mid) &lt; f(mid+<span class="number">1</span>)) r = mid;
  <span class="keyword">else</span> l = mid+<span class="number">1</span>;
}
</code></pre>
<pre><code class="cpp"><span class="keyword">while</span>(r-l&gt;<span class="number">5</span>){
    <span class="keyword">int</span> ml=(l+l+r)/<span class="number">3</span>;
    <span class="keyword">int</span> mr=(l+r+r)/<span class="number">3</span>;
    <span class="keyword">if</span>(f(ml)&lt;f(mr))r=mr;
    <span class="keyword">else</span> l=ml;
}
<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) res = min(res, f(i));
</code></pre>
<pre><code class="cpp"><span class="keyword">while</span> (r-l &gt; eps) {
  <span class="keyword">double</span> ml = l+(r-l)/<span class="number">3</span>, mr = r-(r-l)/<span class="number">3</span>;
  <span class="keyword">if</span> (f(ml) &lt; f(mr)) r = mr;
  <span class="keyword">else</span> l = ml;
}
</code></pre>

    </div>
</div></p>
<h2 id="三维偏序-CDQ分治"><a href="#三维偏序-CDQ分治" class="headerlink" title="三维偏序|CDQ分治"></a><a href="https://www.luogu.com.cn/blog/ljc20020730/cdq-fen-zhi-xue-xi-bi-ji" target="_blank" rel="noopener">三维偏序|CDQ分治</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{
  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;
  <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>, i = l, j = mid+<span class="number">1</span>;
  cdq(l, mid); cdq(mid+<span class="number">1</span>, r);
  <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; ++k) {
    <span class="keyword">if</span> (j &gt; r || (i &lt;= mid &amp;&amp; a[i].y &lt;= a[j].y)) {
      tree.add(a[i].z, a[i].w);
      b[k] = a[i++];
    } <span class="keyword">else</span> {
      a[j].f += tree.query(a[j].z);
      b[k] = a[j++];
    }
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= mid; ++k) tree.add(a[k].z, -a[k].w);
  <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; ++k) a[k] = b[k];
}
</code></pre>

    </div>
</div>
<h3 id="四维偏序"><a href="#四维偏序" class="headerlink" title="四维偏序"></a>四维偏序</h3><p>CDQ套CDQ</p>
<p>第一维在第一层CDQ合并时标记左右区间</p>
<p>合并后第二维有序,进入第二层CDQ</p>
<p>此时按照正常CDQ合并第三维,用数据结构统计第四维</p>
<p>只有标记左区间的加入数据结构,标记右边区间的更新答案</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{
  cdq(l, mid); cdq(mid+<span class="number">1</span>, r);
}

<span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{
  CDQ(l, mid); CDQ(mid+<span class="number">1</span>, r);
  <span class="comment">// ...</span>
  cdq(l, r);
}
</code></pre>

    </div>
</div>
<h2 id="某区间操作问题"><a href="#某区间操作问题" class="headerlink" title="某区间操作问题"></a>某区间操作问题</h2><p>每次操作可以使一个区间+1(或-1),使得序列为0的操作次数下界 $\frac{\sum\limits_{i=1}^{n+1}\lvert a_i-a_{i-1} \rvert}{2}$</p>
<h2 id="分数规划"><a href="#分数规划" class="headerlink" title="分数规划"></a>分数规划</h2><p>分数规划用来求一个分式的极值。</p>
<p>形象一点就是，给出 $a_i$ 和 $b_i$，求一组 $w_i\in{0,1}$，最小化或最大化</p>
<p>$$ \displaystyle\frac{\sum\limits_{i=1}^na_i\times w_i}{\sum\limits_{i=1}^nb_i\times w_i} $$</p>
<p>每种物品有两个权值 $a$ 和 $b$，选出若干个物品使得 $\displaystyle\frac{\sum a}{\sum b}$ 最小/最大。</p>
<p>例如代价为 平均值 或 乘积开个数次根(取ln)</p>
<p>分数规划问题的通用方法是二分。</p>
<p>假设我们要求最大值。二分一个答案 $mid$，然后推式子（为了方便少写了上下界）：</p>
<p>$$\displaystyle<br>\begin{aligned}<br>&amp;\frac{\sum a_i\times w_i}{\sum b_i\times w_i}&gt;mid\<br>\Longrightarrow&amp;\sum a_i\times w_i-mid\times \sum b_i\cdot w_i&gt;0\<br>\Longrightarrow&amp;\sum w_i\times(a_i-mid\times b_i)&gt;0 \end{aligned}$$</p>
<p>那么只要求出不等号左边的式子的最大值就行了。如果最大值比 $0$ 要大，说明 $mid$ 是可行的，否则不可行。</p>
<h2 id="不转义"><a href="#不转义" class="headerlink" title="不转义"></a>不转义</h2><p>R”()”</p>
<h2 id="十六进制输出内存"><a href="#十六进制输出内存" class="headerlink" title="十六进制输出内存"></a>十六进制输出内存</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">void</span> <span class="title">hex_print</span><span class="params">(<span class="keyword">const</span> T &amp;y)</span> </span>{
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> HEX[] = <span class="string">"0123456789ABCDEF"</span>;
  <span class="keyword">char</span> *x = (<span class="keyword">char</span>*)(&amp;y);
  <span class="built_in">printf</span>(<span class="string">"0x"</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">sizeof</span>(T) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) { <span class="comment">// 小端存储</span>
    <span class="keyword">char</span> a = *(x + i);
    <span class="built_in">printf</span>(<span class="string">"%c%c"</span>,HEX[(a&amp;<span class="number">0xF0</span>)&gt;&gt;<span class="number">4</span>],HEX[a&amp;<span class="number">0x0F</span>]);
  }
  <span class="built_in">puts</span>(<span class="string">""</span>);
}
</code></pre>

    </div>
</div>
<h2 id="两两组合"><a href="#两两组合" class="headerlink" title="两两组合"></a>两两组合</h2><p>2n 个人两两组合方案数 $(2n-1)<em>(2n-3)</em>\dots$</p>
<h2 id="INF"><a href="#INF" class="headerlink" title="INF"></a>INF</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">static</span> <span class="keyword">constexpr</span> T inf = numeric_limits&lt;T&gt;::max() / <span class="number">2</span>;
</code></pre>

    </div>
</div>
<h2 id="高维前缀和"><a href="#高维前缀和" class="headerlink" title="高维前缀和"></a>高维前缀和</h2><p>可以将高维数组映射成一维，从小到大枚举即可</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="comment">// 二维</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)
    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)
        a[i][j] += a[i - <span class="number">1</span>][j];
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)
    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)
        a[i][j] += a[i][j - <span class="number">1</span>];
<span class="comment">// 三维</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)
    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)
        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) 
            a[i][j][k] += a[i - <span class="number">1</span>][j][k];
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)
    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)
        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)
            a[i][j][k] += a[i][j - <span class="number">1</span>][k];
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)
    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)
        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)
            a[i][j][k] += a[i][j][k - <span class="number">1</span>];
<span class="comment">// 以此类推,每一维度都做一遍前缀和</span>
</code></pre>

    </div>
</div>
<hr>
<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="向量-坐标-直线-圆-结构体"><a href="#向量-坐标-直线-圆-结构体" class="headerlink" title="向量 坐标 直线 圆 (结构体)"></a>向量 坐标 直线 圆 (结构体)</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> {</span>
  <span class="keyword">typedef</span> <span class="keyword">double</span> T;
  T x, y;
  <span class="keyword">int</span> id;
  Point(){}
  Point(<span class="keyword">const</span> T &amp;_x, <span class="keyword">const</span> T &amp;_y, <span class="keyword">const</span> <span class="keyword">int</span> &amp;_i = <span class="number">0</span>) : x(_x), y(_y), id(_i) {}
  <span class="keyword">friend</span> Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2) {
    <span class="keyword">return</span> Point(p1.x+p2.x, p1.y+p2.y, p1.id);
  }
  <span class="keyword">friend</span> Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2) {
    <span class="keyword">return</span> Point(p1.x-p2.x, p1.y-p2.y, p1.id);
  }
  <span class="keyword">friend</span> Point <span class="keyword">operator</span> - (<span class="keyword">const</span> Point &amp;p) {
    <span class="keyword">return</span> Point(-p.x, -p.y, p.id);
  }
  <span class="comment">// a*b b在a的顺负逆正</span>
  <span class="keyword">friend</span> T <span class="keyword">operator</span> * (<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2) {
    <span class="keyword">return</span> p1.x*p2.y-p1.y*p2.x;
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="keyword">friend</span> Point <span class="keyword">operator</span> / (<span class="keyword">const</span> Point &amp;p, <span class="keyword">const</span> TT &amp;k) {
    <span class="keyword">return</span> Point(p.x/k, p.y/k, p.id);
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="keyword">friend</span> Point <span class="keyword">operator</span> * (<span class="keyword">const</span> Point &amp;p, <span class="keyword">const</span> TT &amp;k) {
    <span class="keyword">return</span> Point(p.x*k, p.y*k, p.id);
  }
  Point <span class="keyword">operator</span> += (<span class="keyword">const</span> Point &amp;p) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+p; }
  Point <span class="keyword">operator</span> -= (<span class="keyword">const</span> Point &amp;p) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+p; }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  Point <span class="keyword">operator</span> *= (<span class="keyword">const</span> TT &amp;k) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*k; }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  Point <span class="keyword">operator</span> /= (<span class="keyword">const</span> TT &amp;k) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>/k; }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2) {
    <span class="keyword">return</span> make_pair(p1.x, p1.y) &lt; make_pair(p2.x, p2.y);
  }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2) {
    <span class="keyword">return</span> make_pair(p1.x, p1.y) &gt; make_pair(p2.x, p2.y);
  }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2) {
    <span class="keyword">return</span> p1.x == p2.x &amp;&amp; p1.y == p2.y;
  }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2) {
    <span class="keyword">return</span> p1.x != p2.x || p1.y != p2.y;
  }
  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;is, Point &amp;p) {
    <span class="keyword">return</span> is &gt;&gt; p.x &gt;&gt; p.y;
  }
  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, Point &amp;p) {
    <span class="keyword">return</span> os &lt;&lt; p.x &lt;&lt; <span class="string">" "</span> &lt;&lt; p.y &lt;&lt; <span class="string">" "</span> &lt;&lt; p.id &lt;&lt; <span class="built_in">endl</span>;
  }
  <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">1.0</span>*x*x+<span class="number">1.0</span>*y*y); }
  <span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> </span>{ <span class="keyword">return</span> (p2-p1).length(); }
  <span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Point &amp;p)</span> </span>{ <span class="keyword">return</span> (p-*<span class="keyword">this</span>).length(); }
  <span class="function"><span class="keyword">friend</span> T <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> </span>{ <span class="keyword">return</span> p1.x*p2.x+p1.y*p2.y; }
  <span class="function">T <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point &amp;p)</span> </span>{ <span class="keyword">return</span> x*p.x+y*p.y; }
  <span class="function"><span class="keyword">friend</span> Point <span class="title">rotate_90_c</span><span class="params">(<span class="keyword">const</span> Point &amp;p)</span> </span>{ <span class="keyword">return</span> Point(p.y, -p.x, p.id); }
  <span class="function">Point <span class="title">rotate_90_c</span><span class="params">()</span> </span>{ <span class="keyword">return</span> Point(y, -x, id); }
  <span class="function"><span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">const</span> Point &amp;p)</span> </span>{ <span class="keyword">return</span> <span class="built_in">atan2</span>(p.y, p.x); }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">double</span>&gt;
struct Vec { <span class="comment">// 三维向量</span>
  T x, y, z;
  Vec(<span class="keyword">const</span> T &amp;_x = <span class="number">0</span>, <span class="keyword">const</span> T &amp;_y = <span class="number">0</span>, <span class="keyword">const</span> T &amp;_z = <span class="number">0</span>) : x(_x), y(_y), z(_z) {}
  <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">1.0</span>*x*x+<span class="number">1.0</span>*y*y+<span class="number">1.0</span>*z*z); }
  <span class="keyword">friend</span> Vec <span class="keyword">operator</span> +(<span class="keyword">const</span> Vec &amp;v1, <span class="keyword">const</span> Vec &amp;v2) { <span class="keyword">return</span> Vec(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z); }
  <span class="keyword">friend</span> Vec <span class="keyword">operator</span> -(<span class="keyword">const</span> Vec &amp;v1, <span class="keyword">const</span> Vec &amp;v2) { <span class="keyword">return</span> Vec(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z); }
  <span class="keyword">friend</span> Vec <span class="keyword">operator</span> *(<span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> Vec &amp;v) { <span class="keyword">return</span> Vec(k*v.x, k*v.y, k*v.z); }
  <span class="keyword">friend</span> Vec <span class="keyword">operator</span> *(<span class="keyword">const</span> Vec &amp;v, <span class="keyword">const</span> T &amp;k) { <span class="keyword">return</span> k*v; }
  <span class="keyword">friend</span> Vec <span class="keyword">operator</span> *(<span class="keyword">const</span> Vec &amp;v1, <span class="keyword">const</span> Vec &amp;v2) {
    <span class="keyword">return</span> Vec(
        v1.y*v2.z-v1.z*v2.y,
        v1.z*v2.x-v1.x*v2.z,
        v1.x*v2.y-v1.y*v2.x
    );
  }
  <span class="function"><span class="keyword">friend</span> T <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Vec &amp;v1, <span class="keyword">const</span> Vec &amp;v2)</span> </span>{ <span class="keyword">return</span> v1.x*v2.x+v1.y*v2.y+v1.z*v2.z; }
  <span class="function">T <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Vec &amp;v)</span> </span>{ <span class="keyword">return</span> dot(*<span class="keyword">this</span>, v); }
  Vec&amp; <span class="keyword">operator</span> +=(<span class="keyword">const</span> Vec &amp;v) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+v; }
  Vec&amp; <span class="keyword">operator</span> -=(<span class="keyword">const</span> Vec &amp;v) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>-v; }
  Vec&amp; <span class="keyword">operator</span> *=(<span class="keyword">const</span> T &amp;k) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*k; }
  Vec&amp; <span class="keyword">operator</span> *=(<span class="keyword">const</span> Vec &amp;v) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*v; }
  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream &amp;is, Vec &amp;v) { <span class="keyword">return</span> is &gt;&gt; v.x &gt;&gt; v.y &gt;&gt; v.z; }
};

<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">polar_angle1</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> </span>{
  <span class="keyword">double</span> d1 = <span class="built_in">atan</span>(p1), d2 = <span class="built_in">atan</span>(p2); 
  <span class="keyword">return</span> d1 == d2 ? p1 &lt; p2 : d1 &lt; d2;
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">polar_angle2</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> </span>{
  <span class="keyword">auto</span> tmp = p1*p2;
  <span class="keyword">return</span> tmp == <span class="number">0</span> ? p1 &lt; p2 : tmp &gt; <span class="number">0</span>;
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2, <span class="keyword">const</span> Point &amp;p3)</span> </span>{
  <span class="keyword">return</span> <span class="built_in">abs</span>(p1.x*p2.y+p1.y*p3.x+p2.x*p3.y-p1.x*p3.y-p1.y*p2.x-p2.y*p3.x);
}

<span class="class"><span class="keyword">struct</span> <span class="title">Line</span> {</span>
  Point p1, p2;
  Line(){}
  Line(<span class="keyword">const</span> Point &amp;_p1, <span class="keyword">const</span> Point &amp;_p2) : p1(_p1), p2(_p2) {}
  <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span> </span>{
    <span class="meta">#<span class="meta-keyword">define</span> SJ1(x) max(l1.p1.x, l1.p2.x) &lt; min(l2.p1.x, l2.p2.x) || \</span>
             max(l2.p1.x, l2.p2.x) &lt; min(l1.p1.x, l1.p2.x)
    <span class="keyword">if</span> (SJ1(x) || SJ1(y)) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="meta">#<span class="meta-keyword">undef</span> SJ1</span>
    <span class="meta">#<span class="meta-keyword">define</span> SJ2(a, b, c, d) ((a-b)*(a-c))*((a-b)*(a-d)) &lt;= 0</span>
    <span class="keyword">return</span> SJ2(l1.p1, l1.p2, l2.p1, l2.p2) &amp;&amp;
         SJ2(l2.p1, l2.p2, l1.p1, l1.p2);
    <span class="meta">#<span class="meta-keyword">undef</span> SJ2</span>
  }
  <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">on_line</span><span class="params">(<span class="keyword">const</span> Line &amp;l, <span class="keyword">const</span> Point &amp;p)</span> </span>{
    <span class="keyword">return</span> <span class="built_in">abs</span>((l.p1-l.p2)*(l.p1-p)) &lt; eps;
  }
  <span class="function"><span class="keyword">friend</span> Point <span class="title">cross_point</span><span class="params">(<span class="keyword">const</span> Line &amp;l1, <span class="keyword">const</span> Line &amp;l2)</span> </span>{
    Point v1 = l1.p2-l1.p1, v2 = l2.p2-l2.p1;
    <span class="keyword">if</span> (<span class="built_in">abs</span>(v1*v2) &lt; eps) <span class="keyword">return</span> Point(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// no cross_point</span>
    <span class="keyword">double</span> t = (l2.p1-l1.p1)*v2/(v1*v2);
    <span class="keyword">return</span> l1.p1+v1*t;
  }
};

<span class="class"><span class="keyword">struct</span> <span class="title">Circular</span> {</span>
  Point o;
  <span class="keyword">double</span> r;
  Circular(){}
  Circular(<span class="keyword">const</span> Point &amp;_o, <span class="keyword">const</span> <span class="keyword">double</span> &amp;_r) : o(_o), r(_r) {}
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
  Circular(<span class="keyword">const</span> T &amp;_x, <span class="keyword">const</span> T &amp;_y, <span class="keyword">const</span> <span class="keyword">double</span> &amp;_r) : o(Point(_x, _y)), r(_r) {}
  <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">in_cir</span><span class="params">(<span class="keyword">const</span> Circular &amp;c, <span class="keyword">const</span> Point &amp;p)</span> </span>{ <span class="keyword">return</span> dis(c.o, p) &lt;= c.r; }
  <span class="function"><span class="keyword">bool</span> <span class="title">in_cir</span><span class="params">(<span class="keyword">const</span> Point &amp;p)</span> </span>{ <span class="keyword">return</span> dis(o, p) &lt;= r; }
};

<span class="function"><span class="keyword">inline</span> Circular <span class="title">get_cir</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2, <span class="keyword">const</span> Point &amp;p3)</span> </span>{
  Circular res;
  res.o = cross_point(Line((p1+p2)/<span class="number">2</span>, (p1+p2)/<span class="number">2</span>+(p2-p1).rotate_90_c()),
            Line((p1+p3)/<span class="number">2</span>, (p1+p3)/<span class="number">2</span>+(p3-p1).rotate_90_c()));
  res.r = dis(res.o, p1);
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="二维凸包"><a href="#二维凸包" class="headerlink" title="二维凸包"></a><a href="https://www.luogu.com.cn/problem/P2742" target="_blank" rel="noopener">二维凸包</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">int</span> n;
<span class="keyword">int</span> stk[N], used[N], tp;
Point p[N];

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Andrew</span><span class="params">()</span> </span>{
  <span class="built_in">memset</span>(used, <span class="number">0</span>, <span class="keyword">sizeof</span> used);
  sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>);
  tp = <span class="number">0</span>;
  stk[++tp] = <span class="number">1</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) {
    <span class="keyword">while</span> (tp &gt;= <span class="number">2</span> &amp;&amp; (p[stk[tp]]-p[stk[tp<span class="number">-1</span>]])*(p[i]-p[stk[tp]]) &lt;= <span class="number">0</span>)
      used[stk[tp--]] = <span class="number">0</span>;
    used[i] = <span class="number">1</span>;
    stk[++tp] = i;
  }
  <span class="keyword">int</span> tmp = tp;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i; --i) {
    <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;
    <span class="keyword">while</span> (tp &gt;= tmp &amp;&amp; (p[stk[tp]]-p[stk[tp<span class="number">-1</span>]])*(p[i]-p[stk[tp]]) &lt;= <span class="number">0</span>)
      used[stk[tp--]] = <span class="number">0</span>;
    used[i] = <span class="number">1</span>;
    stk[++tp] = i;
  }
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="平面最近点对"><a href="#平面最近点对" class="headerlink" title="平面最近点对"></a><a href="https://www.luogu.com.cn/problem/P1429" target="_blank" rel="noopener">平面最近点对</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp">Point a[N];
<span class="keyword">int</span> n, ansa, ansb;
<span class="keyword">double</span> mindist;

<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> </span>{ <span class="keyword">return</span> p1.y &lt; p2.y; }

<span class="function"><span class="keyword">void</span> <span class="title">upd_ans</span><span class="params">(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2)</span> </span>{
  <span class="keyword">double</span> dist = dis(p1, p2);
  <span class="keyword">if</span> (dist &lt; mindist) mindist = dist, ansa = p1.id, ansb = p2.id;
}

<span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{
  <span class="keyword">if</span> (r-l &lt;= <span class="number">3</span>) {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= r; ++j)
        upd_ans(a[i], a[j]);
    sort(a+l, a+r+<span class="number">1</span>, cmp_y);
    <span class="keyword">return</span>;
  }

  <span class="keyword">static</span> Point t[N];
  <span class="keyword">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>, midx = a[m].x;
  rec(l, m); rec(m+<span class="number">1</span>, r);
  merge(a+l, a+m+<span class="number">1</span>, a+m+<span class="number">1</span>, a+r+<span class="number">1</span>, t, cmp_y);
  copy(t, t+r-l+<span class="number">1</span>, a+l);

  <span class="keyword">int</span> tsz = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)
    <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i].x-midx) &lt;= mindist) {
      <span class="keyword">for</span> (<span class="keyword">int</span> j = tsz; j &amp;&amp; a[i].y-t[j].y &lt; mindist; --j)
        upd_ans(a[i], t[j]);
      t[++tsz] = a[i];
    }
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mindist_pair</span><span class="params">()</span> </span>{
  sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>);
  mindist = INF;
  rec(<span class="number">1</span>, n);
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="最小圆覆盖-随即增量法"><a href="#最小圆覆盖-随即增量法" class="headerlink" title="最小圆覆盖|随即增量法"></a><a href="https://www.luogu.com.cn/problem/P1742" target="_blank" rel="noopener">最小圆覆盖|随即增量法</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> Circular <span class="title">RIA</span><span class="params">()</span> </span>{
  Circular cir;
  random_shuffle(a+<span class="number">1</span>, a+n+<span class="number">1</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    <span class="keyword">if</span> (cir.in_cir(a[i])) <span class="keyword">continue</span>;
    cir = Circular(a[i], <span class="number">0</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) {
      <span class="keyword">if</span> (cir.in_cir(a[j])) <span class="keyword">continue</span>;
      cir = Circular((a[i]+a[j])/<span class="number">2</span>, dis(a[i], a[j])/<span class="number">2</span>);
      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; j; ++k) {
        <span class="keyword">if</span> (cir.in_cir(a[k])) <span class="keyword">continue</span>;
        cir = get_cir(a[i], a[j], a[k]);
      }
    }
  }
  <span class="keyword">return</span> cir;
}
</code></pre>

    </div>
</div>
<hr>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a><a href="https://www.luogu.org/problemnew/show/P3378" target="_blank" rel="noopener">堆</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span>+<span class="number">7</span>;
  <span class="keyword">int</span> sz, a[Maxn];
  Heap() { sz = <span class="number">0</span>; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); }
  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ <span class="keyword">return</span> x &lt; y; } <span class="comment">// 小根堆</span>
  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{ <span class="keyword">return</span> sz; }
  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{ <span class="keyword">return</span> sz == <span class="number">0</span>; }
  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{ <span class="keyword">return</span> a[<span class="number">1</span>]; }
  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ a[++sz] = x; swift_up(sz); }
  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{ swap(a[<span class="number">1</span>], a[sz--]); swift_down(<span class="number">1</span>); }
  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swift_up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>{
    <span class="keyword">while</span>(p &gt; <span class="number">1</span> &amp;&amp; cmp(a[p], a[p&gt;&gt;<span class="number">1</span>])) <span class="comment">// a[p] &lt; a[p&lt;&lt;1]</span>
      swap(a[p], a[p&gt;&gt;<span class="number">1</span>]), p &gt;&gt;= <span class="number">1</span>;
  }
  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swift_down</span><span class="params">(<span class="keyword">int</span> p)</span> </span>{
    <span class="keyword">int</span> l, r, s;
    <span class="keyword">while</span>(<span class="literal">true</span>) {
      l = p&lt;&lt;<span class="number">1</span>; r = p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;
      <span class="keyword">if</span>(l &gt; sz) <span class="keyword">break</span>;
      <span class="keyword">if</span>(r &gt; sz || cmp(a[l], a[r])) s = l; <span class="comment">// a[l] &lt; a[r]</span>
      <span class="keyword">else</span> s = r;
      <span class="keyword">if</span>(cmp(a[s], a[p])) <span class="comment">// a[s] &lt; a[p]</span>
        swap(a[p], a[s]), p = s;
      <span class="keyword">else</span> <span class="keyword">break</span>;
    }
  }
};
</code></pre>

    </div>
</div>
<h3 id="可删堆"><a href="#可删堆" class="headerlink" title="可删堆"></a>可删堆</h3><p>copyright by axiomofchoice<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>{</span>
  priority_queue&lt;T&gt; a,b;  <span class="comment">// heap=a-b</span>
  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T x)</span></span>{a.push(x);}
  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(T x)</span></span>{b.push(x);}
  <span class="function">T <span class="title">top</span><span class="params">()</span></span>{
    <span class="keyword">while</span>(!b.empty() &amp;&amp; a.top()==b.top())
      a.pop(),b.pop();
    <span class="keyword">return</span> a.size() ? a.top() : <span class="number">0</span>; <span class="comment">// ???</span>
  }
  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>{
    <span class="keyword">while</span>(!b.empty() &amp;&amp; a.top()==b.top())
      a.pop(),b.pop();
    a.pop();
  }
  <span class="function">T <span class="title">top2</span><span class="params">()</span></span>{ <span class="comment">// 次大值</span>
    T t=top(); pop();
    T ans=top(); push(t);
    <span class="keyword">return</span> ans;
  }
  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>{<span class="keyword">return</span> a.size()-b.size();}
};
</code></pre>

    </div>
</div></p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a><a href="https://www.luogu.org/problemnew/show/P3369" target="_blank" rel="noopener">平衡树</a></h2><h3 id="替罪羊树-Scapegoat-Tree"><a href="#替罪羊树-Scapegoat-Tree" class="headerlink" title="替罪羊树|Scapegoat Tree"></a>替罪羊树|Scapegoat Tree</h3><h3 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h3><h3 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a><a href="https://www.luogu.org/blog/user19027/solution-p3369" target="_blank" rel="noopener">Splay</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> {</span>
  <span class="meta">#<span class="meta-keyword">define</span> root e[0].ch[1]</span>
  <span class="keyword">typedef</span> <span class="keyword">int</span> T;
  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span>
    T v = <span class="number">0</span>;
    <span class="keyword">int</span> ch[<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">0</span>};
    <span class="keyword">int</span> fa = <span class="number">0</span>, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;
  } e[N];
  <span class="keyword">int</span> n;
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ e[x].sum = e[e[x].ch[<span class="number">0</span>]].sum+e[e[x].ch[<span class="number">1</span>]].sum+e[x].cnt; }
  <span class="function"><span class="keyword">int</span> <span class="title">identify</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == e[e[x].fa].ch[<span class="number">1</span>]; } <span class="comment">// check left or right child</span>
  <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>{ e[x].fa = f; e[f].ch[son] = x; }
  <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">int</span> y = e[x].fa,
        r = e[y].fa,
        rson = identify(y),
        yson = identify(x),
        b = e[x].ch[yson^<span class="number">1</span>];
    connect(b, y, yson);
    connect(y, x, yson^<span class="number">1</span>);
    connect(x, r, rson);
    update(y); update(x);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> at, <span class="keyword">int</span> to)</span> </span>{
    to = e[to].fa;
    <span class="keyword">int</span> up;
    <span class="keyword">while</span>((up = e[at].fa) != to) {
      <span class="keyword">if</span>(e[up].fa != to)
        rotate(identify(up) == identify(at) ? up : at);
      rotate(at);
    }
  }
  <span class="function"><span class="keyword">int</span> <span class="title">add_point</span><span class="params">(T v, <span class="keyword">int</span> fa)</span> </span>{
    ++n; e[n].v = v; e[n].fa = fa; e[n].sum = e[n].cnt = <span class="number">1</span>;
    <span class="keyword">return</span> n;
  }
  <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(T v)</span> </span>{
    <span class="keyword">int</span> now = root, last = <span class="number">0</span>;
    <span class="keyword">while</span> (now &amp;&amp; e[now].v != v)
      last = now, now = e[now].ch[v &gt; e[now].v];
    splay((now ? now : last), root);
    <span class="keyword">return</span> now;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T v)</span> </span>{
    <span class="keyword">if</span> (!root) { root = add_point(v, root); <span class="keyword">return</span>; }
    <span class="keyword">int</span> now = root, last = <span class="number">0</span>;
    <span class="keyword">while</span> (now &amp;&amp; e[now].v != v)
      last = now, now = e[now].ch[v &gt; e[now].v];
    <span class="keyword">if</span> (now) ++e[now].cnt;
    <span class="keyword">else</span> now = e[last].ch[v &gt; e[last].v] = add_point(v, last);
    splay(now, root);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(T v)</span> </span>{
    <span class="keyword">int</span> del = find(v);
    <span class="keyword">if</span> (!del) <span class="keyword">return</span>;
    <span class="keyword">if</span> (e[del].cnt &gt; <span class="number">1</span>) {
      --e[del].cnt;
      --e[del].sum;
    } <span class="keyword">else</span> <span class="keyword">if</span> (!e[del].ch[<span class="number">0</span>]) {
      root = e[del].ch[<span class="number">1</span>];
      e[root].fa = <span class="number">0</span>;
    } <span class="keyword">else</span> {
      <span class="keyword">int</span> oldroot = root;
      splay(nex(e[del].ch[<span class="number">0</span>], <span class="number">1</span>), root);
      connect(e[oldroot].ch[<span class="number">1</span>], root, <span class="number">1</span>);
      update(root);
    }
  }
  <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(T v)</span> </span>{ <span class="keyword">return</span> e[e[find(v)].ch[<span class="number">0</span>]].sum+<span class="number">1</span>; }
  <span class="function">T <span class="title">atrank</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">if</span> (x &gt; e[root].sum) <span class="keyword">return</span> -INF;
    <span class="keyword">int</span> now = root;
    <span class="keyword">while</span> (<span class="literal">true</span>) {
      <span class="keyword">if</span> (x &lt;= e[e[now].ch[<span class="number">0</span>]].sum) now = e[now].ch[<span class="number">0</span>];
      <span class="keyword">else</span> <span class="keyword">if</span> ((x -= e[e[now].ch[<span class="number">0</span>]].sum) &lt;= e[now].cnt) <span class="keyword">break</span>;
      <span class="keyword">else</span> x -= e[now].cnt, now = e[now].ch[<span class="number">1</span>];
    }
    splay(now, root);
    <span class="keyword">return</span> e[now].v;
  }
  <span class="comment">// small 0, big 1</span>
  <span class="function"><span class="keyword">int</span> <span class="title">nex</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> opt)</span> </span>{ <span class="keyword">while</span> (e[x].ch[opt]) x = e[x].ch[opt]; <span class="keyword">return</span> x; }
  <span class="function">T <span class="title">lower</span><span class="params">(T v, <span class="keyword">int</span> opt)</span> </span>{
    insert(v);
    T res = e[nex(e[root].ch[opt], opt^<span class="number">1</span>)].v;
    erase(v);
    <span class="keyword">return</span> res;
  }
  <span class="meta">#<span class="meta-keyword">undef</span> root</span>
};
</code></pre>

    </div>
</div>
<p>区间反转<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> {</span>
  <span class="keyword">typedef</span> <span class="keyword">int</span> T;
  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span>
    T v = <span class="number">0</span>;
    <span class="keyword">int</span> ch[<span class="number">2</span>] = { <span class="number">0</span>, <span class="number">0</span> };
    <span class="keyword">int</span> fa = <span class="number">0</span>, sum = <span class="number">0</span>, cnt = <span class="number">0</span>, tag = <span class="number">0</span>;
  } e[N];
  <span class="keyword">int</span> sz, &amp;root = e[<span class="number">0</span>].ch[<span class="number">1</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ e[x].sum = e[e[x].ch[<span class="number">0</span>]].sum+e[e[x].ch[<span class="number">1</span>]].sum+e[x].cnt; }
  <span class="function"><span class="keyword">int</span> <span class="title">identify</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> x == e[e[x].fa].ch[<span class="number">1</span>]; }
  <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f,<span class="keyword">int</span> son)</span> </span>{ e[x].fa = f; e[f].ch[son] = x; }
  <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">int</span> y = e[x].fa,
      r = e[y].fa,
      rson = identify(y),
      yson = identify(x),
      b = e[x].ch[yson^<span class="number">1</span>];
    connect(b, y, yson);
    connect(y, x, yson^<span class="number">1</span>);
    connect(x, r, rson);
    update(y); update(x);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> at,<span class="keyword">int</span> to = <span class="number">0</span>)</span> </span>{
    to = e[to].fa;
    <span class="keyword">int</span> up;
    <span class="keyword">while</span>((up = e[at].fa) != to) {
      <span class="keyword">if</span>(e[up].fa != to)
        rotate(identify(up) == identify(at) ? up : at);
      rotate(at);
    }
  }
  <span class="function"><span class="keyword">int</span> <span class="title">add_point</span><span class="params">(T v, <span class="keyword">int</span> fa)</span> </span>{
    ++sz; e[sz].v = v; e[sz].fa = fa; e[sz].sum = e[sz].cnt = <span class="number">1</span>;
    <span class="keyword">return</span> sz;
  }
  <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">if</span> (x &gt; e[root].sum) <span class="keyword">return</span> -INF;
    <span class="keyword">int</span> now = root;
    <span class="keyword">while</span> (<span class="literal">true</span>) {
      push_down(now);
      <span class="keyword">if</span> (x &lt;= e[e[now].ch[<span class="number">0</span>]].sum) now = e[now].ch[<span class="number">0</span>];
      <span class="keyword">else</span> <span class="keyword">if</span> ((x -= e[e[now].ch[<span class="number">0</span>]].sum) &lt;= e[now].cnt) <span class="keyword">break</span>;
      <span class="keyword">else</span> x -= e[now].cnt, now = e[now].ch[<span class="number">1</span>];
    }
    <span class="keyword">return</span> now;
  }
  <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> fa)</span> </span>{
    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>,
      now = add_point(mid, fa);
    e[now].ch[<span class="number">0</span>] = build(l, mid<span class="number">-1</span>, now);
    e[now].ch[<span class="number">1</span>] = build(mid+<span class="number">1</span>, r, now);
    update(now);
    <span class="keyword">return</span> now;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">if</span> (x &amp;&amp; e[x].tag) {
      e[e[x].ch[<span class="number">0</span>]].tag ^= <span class="number">1</span>;
      e[e[x].ch[<span class="number">1</span>]].tag ^= <span class="number">1</span>;
      swap(e[x].ch[<span class="number">0</span>], e[x].ch[<span class="number">1</span>]);
      e[x].tag = <span class="number">0</span>;
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{
    <span class="keyword">int</span> pl = find(l<span class="number">-1</span>+<span class="number">1</span>), pr = find(r+<span class="number">1</span>+<span class="number">1</span>);
    splay(pl); splay(pr, pl);
    e[e[e[root].ch[<span class="number">1</span>]].ch[<span class="number">0</span>]].tag ^= <span class="number">1</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">print_LMR</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;
    push_down(x);
    print_LMR(e[x].ch[<span class="number">0</span>]);
    <span class="keyword">if</span> (e[x].v != <span class="number">0</span> &amp;&amp; e[x].v != n+<span class="number">1</span>)
      write(a[e[x].v]), <span class="built_in">putchar</span>(<span class="string">' '</span>);
    print_LMR(e[x].ch[<span class="number">1</span>]);
  }
} tree;
</code></pre>

    </div>
</div></p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a><a href="https://www.luogu.org/problemnew/show/P3372" target="_blank" rel="noopener">线段树</a></h2><h3 id="区间加减区间和"><a href="#区间加减区间和" class="headerlink" title="区间加减区间和"></a>区间加减区间和</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> {</span>
  <span class="keyword">int</span> sz;
  T tr[N&lt;&lt;<span class="number">2</span>], lazy[N&lt;&lt;<span class="number">2</span>];
  SegmentTree(){}
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> T &amp;k = <span class="number">0</span>)</span> </span>{ sz = n; _build(<span class="number">1</span>, n, k); }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> TT a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{ sz = n; _build(a, <span class="number">1</span>, n); }
  <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ _modify(x, k, <span class="number">1</span>, sz); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ _add(x, x, k, <span class="number">1</span>, sz); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> T &amp;k)</span> </span>{ <span class="keyword">if</span> (l &gt; r) swap(l, r); _add(l, r, k, <span class="number">1</span>, sz); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{ <span class="keyword">return</span> _query(x, x, <span class="number">1</span>, sz); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">if</span> (l &gt; r) swap(l, r); <span class="keyword">return</span> _query(l, r, <span class="number">1</span>, sz); }
<span class="keyword">private</span> :
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span> </span>{ tr[i] = tr[i&lt;&lt;<span class="number">1</span>]+tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i, <span class="keyword">const</span> <span class="keyword">int</span> &amp;len)</span> </span>{
    <span class="keyword">if</span> (!lazy[i]) <span class="keyword">return</span>;
    tr[i&lt;&lt;<span class="number">1</span>] += lazy[i]*(len-len/<span class="number">2</span>);
    tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += lazy[i]*(len/<span class="number">2</span>);
    lazy[i&lt;&lt;<span class="number">1</span>] += lazy[i];
    lazy[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += lazy[i];
    lazy[i] = <span class="number">0</span>;
  }
  <span class="keyword">void</span> _build(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    lazy[i] = <span class="number">0</span>;
    <span class="keyword">if</span> (l == r) { tr[i] = k; <span class="keyword">return</span>; }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    _build(l, mid, k, i&lt;&lt;<span class="number">1</span>);
    _build(mid+<span class="number">1</span>, r, k, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="keyword">void</span> _build(<span class="keyword">const</span> TT a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    lazy[i] = <span class="number">0</span>;
    <span class="keyword">if</span> (l == r) { tr[i] = a[l]; <span class="keyword">return</span>; }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    _build(a, l, mid, i&lt;&lt;<span class="number">1</span>);
    _build(a, mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">void</span> _modify(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trl, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trr, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (trl == x &amp;&amp; trr == x) {
      tr[i] = k;
      lazy[i] = <span class="number">0</span>;
      <span class="keyword">return</span>;
    }
    push_down(i, trr-trl+<span class="number">1</span>);
    <span class="keyword">int</span> mid = (trl+trr)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) _modify(x, k, trl, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">else</span> _modify(x, k, mid+<span class="number">1</span>, trr, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">void</span> _add(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trl, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trr, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (trl &gt;= l &amp;&amp; trr &lt;= r) {
      tr[i] += k*(trr-trl+<span class="number">1</span>);
      lazy[i] += k;
      <span class="keyword">return</span>;
    }
    push_down(i, trr-trl+<span class="number">1</span>);
    <span class="keyword">int</span> mid = (trl+trr)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid) _add(l, r, k, trl, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (r &gt;  mid) _add(l, r, k, mid+<span class="number">1</span>, trr, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  T _query(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trl, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trr, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (trl &gt;= l &amp;&amp; trr &lt;= r) <span class="keyword">return</span> tr[i];
    push_down(i, trr-trl+<span class="number">1</span>);
    <span class="keyword">int</span> mid = (trl+trr)&gt;&gt;<span class="number">1</span>;
    T res = <span class="number">0</span>;
    <span class="keyword">if</span> (l &lt;= mid) res += _query(l, r, trl, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (r &gt;  mid) res += _query(l, r, mid+<span class="number">1</span>, trr, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    <span class="keyword">return</span> res;
  }
};
</code></pre>
<p>动态开点</p>
<pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> {</span> <span class="comment">// 区间加减区间和</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">int</span> l, r;
    TreeNode *ls, *rs;
    T val, lazy;
    TreeNode() { ls = rs = <span class="literal">nullptr</span>; }
    TreeNode(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;_r, <span class="keyword">const</span> T &amp;_val = <span class="number">0</span>)
        : l(_l), r(_r), val(_val) {
      ls = rs = <span class="literal">nullptr</span>;
      lazy = <span class="number">0</span>;
    }
    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> r-l+<span class="number">1</span>; }
  };
  TreeNode *root;
  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (!rt) <span class="keyword">return</span>;
    clear(rt-&gt;ls);
    clear(rt-&gt;rs);
    <span class="keyword">delete</span> rt;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    clear(root);
    root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>, n);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(TreeNode *rt)</span> </span>{
    rt-&gt;val = (rt-&gt;ls ? rt-&gt;ls-&gt;val : <span class="number">0</span>)+(rt-&gt;rs ? rt-&gt;rs-&gt;val : <span class="number">0</span>);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (!rt-&gt;lazy) <span class="keyword">return</span>;
    <span class="keyword">int</span> mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (!rt-&gt;ls) rt-&gt;ls = <span class="keyword">new</span> TreeNode(rt-&gt;l, mid);
    <span class="keyword">if</span> (!rt-&gt;rs) rt-&gt;rs = <span class="keyword">new</span> TreeNode(mid+<span class="number">1</span>, rt-&gt;r);
    rt-&gt;ls-&gt;lazy += rt-&gt;lazy;
    rt-&gt;ls-&gt;val += rt-&gt;lazy*rt-&gt;ls-&gt;len();
    rt-&gt;rs-&gt;lazy += rt-&gt;lazy;
    rt-&gt;rs-&gt;val += rt-&gt;lazy*rt-&gt;rs-&gt;len();
    rt-&gt;lazy = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ update(x, k, root); }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k, TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (rt-&gt;l == x &amp;&amp; rt-&gt;r == x) <span class="keyword">return</span> rt-&gt;val = k, <span class="keyword">void</span>();
    push_down(rt);
    <span class="keyword">int</span> mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) update(x, k, rt-&gt;ls ? rt-&gt;ls : rt-&gt;ls = <span class="keyword">new</span> TreeNode(rt-&gt;l, mid));
    <span class="keyword">else</span> update(x, k, rt-&gt;rs ? rt-&gt;rs : rt-&gt;rs = <span class="keyword">new</span> TreeNode(mid+<span class="number">1</span>, rt-&gt;r));
    push_up(rt);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ add(x, x, k, root); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k)</span> </span>{ add(l, r, k, root); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k, TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (rt-&gt;l &gt;= l &amp;&amp; rt-&gt;r &lt;= r) {
      rt-&gt;val += rt-&gt;len()*k;
      rt-&gt;lazy += k;
      <span class="keyword">return</span>;
    }
    push_down(rt);
    <span class="keyword">int</span> mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid) add(l, r, k, rt-&gt;ls ? rt-&gt;ls : rt-&gt;ls = <span class="keyword">new</span> TreeNode(rt-&gt;l, mid));
    <span class="keyword">if</span> (r &gt;  mid) add(l, r, k, rt-&gt;rs ? rt-&gt;rs : rt-&gt;rs = <span class="keyword">new</span> TreeNode(mid+<span class="number">1</span>, rt-&gt;r));
    push_up(rt);
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{ <span class="keyword">return</span> query(x, x, root); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{ <span class="keyword">return</span> query(l, r, root); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (rt-&gt;l &gt;= l &amp;&amp; rt-&gt;r &lt;= r) <span class="keyword">return</span> rt-&gt;val;
    push_down(rt);
    <span class="keyword">int</span> mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid &amp;&amp; !rt-&gt;ls) rt-&gt;ls = <span class="keyword">new</span> TreeNode(rt-&gt;l, mid);
    <span class="keyword">if</span> (r &gt;  mid &amp;&amp; !rt-&gt;rs) rt-&gt;rs = <span class="keyword">new</span> TreeNode(mid+<span class="number">1</span>, rt-&gt;r);
    <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> query(l, r, rt-&gt;ls);
    <span class="keyword">if</span> (l &gt;  mid) <span class="keyword">return</span> query(l, r, rt-&gt;rs);
    <span class="keyword">return</span> query(l, r, rt-&gt;ls)+query(l, r, rt-&gt;rs);
  }
};
</code></pre>
<p>内存池</p>
<pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> {</span> <span class="comment">// 区间加减区间和</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">int</span> l, r;
    TreeNode *ls, *rs;
    T val, lazy;
    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> r-l+<span class="number">1</span>; }
  } tr[N&lt;&lt;<span class="number">1</span>];
  <span class="built_in">queue</span>&lt;TreeNode*&gt; memory_pool;
  SegmentTree() { <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N&lt;&lt;<span class="number">2</span>; ++i) memory_pool.push(tr+i); }
  <span class="function">TreeNode* <span class="title">fuck</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;val = <span class="number">0</span>)</span> </span>{ <span class="comment">// new</span>
    TreeNode *ptr = memory_pool.front();
    memory_pool.pop();
    ptr-&gt;l = l; ptr-&gt;r = r; ptr-&gt;val = val;
    ptr-&gt;ls = ptr-&gt;rs = <span class="literal">nullptr</span>;
    <span class="keyword">return</span> ptr;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">shit</span><span class="params">(TreeNode *ptr)</span> </span>{ memory_pool.push(ptr); } <span class="comment">// delete</span>
  TreeNode *root;
  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (!rt) <span class="keyword">return</span>;
    clear(rt-&gt;ls);
    clear(rt-&gt;rs);
    shit(rt);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    clear(root);
    root = fuck(<span class="number">1</span>, n);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(TreeNode *rt)</span> </span>{
    rt-&gt;val = (rt-&gt;ls ? rt-&gt;ls-&gt;val : <span class="number">0</span>)+(rt-&gt;rs ? rt-&gt;rs-&gt;val : <span class="number">0</span>);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (!rt-&gt;lazy) <span class="keyword">return</span>;
    <span class="keyword">int</span> mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (!rt-&gt;ls) rt-&gt;ls = fuck(rt-&gt;l, mid);
    <span class="keyword">if</span> (!rt-&gt;rs) rt-&gt;rs = fuck(mid+<span class="number">1</span>, rt-&gt;r);
    rt-&gt;ls-&gt;lazy += rt-&gt;lazy;
    rt-&gt;ls-&gt;val += rt-&gt;lazy*rt-&gt;ls-&gt;len();
    rt-&gt;rs-&gt;lazy += rt-&gt;lazy;
    rt-&gt;rs-&gt;val += rt-&gt;lazy*rt-&gt;rs-&gt;len();
    rt-&gt;lazy = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ update(x, k, root); }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k, TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (rt-&gt;l == x &amp;&amp; rt-&gt;r == x) <span class="keyword">return</span> rt-&gt;val = k, <span class="keyword">void</span>();
    push_down(rt);
    <span class="keyword">int</span> mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) update(x, k, rt-&gt;ls ? rt-&gt;ls : rt-&gt;ls = fuck(rt-&gt;l, mid));
    <span class="keyword">else</span> update(x, k, rt-&gt;rs ? rt-&gt;rs : rt-&gt;rs = fuck(mid+<span class="number">1</span>, rt-&gt;r));
    push_up(rt);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ add(x, x, k, root); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k)</span> </span>{ add(l, r, k, root); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k, TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (rt-&gt;l &gt;= l &amp;&amp; rt-&gt;r &lt;= r) {
      rt-&gt;val += rt-&gt;len()*k;
      rt-&gt;lazy += k;
      <span class="keyword">return</span>;
    }
    push_down(rt);
    <span class="keyword">int</span> mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid) add(l, r, k, rt-&gt;ls ? rt-&gt;ls : rt-&gt;ls = fuck(rt-&gt;l, mid));
    <span class="keyword">if</span> (r &gt;  mid) add(l, r, k, rt-&gt;rs ? rt-&gt;rs : rt-&gt;rs = fuck(mid+<span class="number">1</span>, rt-&gt;r));
    push_up(rt);
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{ <span class="keyword">return</span> query(x, x, root); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{ <span class="keyword">return</span> query(l, r, root); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, TreeNode *rt)</span> </span>{
    <span class="keyword">if</span> (rt-&gt;l &gt;= l &amp;&amp; rt-&gt;r &lt;= r) <span class="keyword">return</span> rt-&gt;val;
    push_down(rt);
    <span class="keyword">int</span> mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid &amp;&amp; !rt-&gt;ls) rt-&gt;ls = fuck(rt-&gt;l, mid);
    <span class="keyword">if</span> (r &gt;  mid &amp;&amp; !rt-&gt;rs) rt-&gt;rs = fuck(mid+<span class="number">1</span>, rt-&gt;r);
    <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> query(l, r, rt-&gt;ls);
    <span class="keyword">if</span> (l &gt;  mid) <span class="keyword">return</span> query(l, r, rt-&gt;rs);
    <span class="keyword">return</span> query(l, r, rt-&gt;ls)+query(l, r, rt-&gt;rs);
  }
};
</code></pre>

    </div>
</div>
<h3 id="区间修改区间和"><a href="#区间修改区间和" class="headerlink" title="区间修改区间和"></a>区间修改区间和</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> {</span>
  <span class="keyword">int</span> sz;
  <span class="keyword">int</span> tag[N&lt;&lt;<span class="number">2</span>];
  T tr[N&lt;&lt;<span class="number">2</span>], lazy[N&lt;&lt;<span class="number">2</span>];
  SegmentTree(){}
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> T &amp;k = <span class="number">0</span>)</span> </span>{ sz = n; _build(<span class="number">1</span>, n, k); }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> TT a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{ sz = n; _build(a, <span class="number">1</span>, n); }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ _update(x, x, k, <span class="number">1</span>, sz); }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> T &amp;k)</span> </span>{ <span class="keyword">if</span> (l &gt; r) swap(l, r); _update(l, r, k, <span class="number">1</span>, sz); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{ <span class="keyword">return</span> _query(x, x, <span class="number">1</span>, sz); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="keyword">if</span> (l &gt; r) swap(l, r); <span class="keyword">return</span> _query(l, r, <span class="number">1</span>, sz); }
<span class="keyword">private</span> :
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span> </span>{ tr[i] = tr[i&lt;&lt;<span class="number">1</span>]+tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]; }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i, <span class="keyword">const</span> <span class="keyword">int</span> &amp;len)</span> </span>{
    <span class="keyword">if</span> (!tag[i]) <span class="keyword">return</span>;
    tr[i&lt;&lt;<span class="number">1</span>] = lazy[i]*(len-len/<span class="number">2</span>);
    tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = lazy[i]*(len/<span class="number">2</span>);
    lazy[i&lt;&lt;<span class="number">1</span>] = lazy[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = lazy[i];
    tag[i&lt;&lt;<span class="number">1</span>] = tag[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] = <span class="number">1</span>;
    tag[i] = <span class="number">0</span>;
  }
  <span class="keyword">void</span> _build(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    lazy[i] = tag[i] = <span class="number">0</span>;
    <span class="keyword">if</span> (l == r) { tr[i] = k; <span class="keyword">return</span>; }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    _build(l, mid, k, i&lt;&lt;<span class="number">1</span>);
    _build(mid+<span class="number">1</span>, r, k, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="keyword">void</span> _build(<span class="keyword">const</span> TT a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    lazy[i] = tag[i] = <span class="number">0</span>;
    <span class="keyword">if</span> (l == r) { tr[i] = a[l]; <span class="keyword">return</span>; }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    _build(a, l, mid, i&lt;&lt;<span class="number">1</span>);
    _build(a, mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">void</span> _update(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trl, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trr, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (trl &gt;= l &amp;&amp; trr &lt;= r) {
      tr[i] = k*(trr-trl+<span class="number">1</span>);
      lazy[i] = k;
      tag[i] = <span class="number">1</span>;
      <span class="keyword">return</span>;
    }
    push_down(i, trr-trl+<span class="number">1</span>);
    <span class="keyword">int</span> mid = (trl+trr)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid) _update(l, r, k, trl, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (r &gt;  mid) _update(l, r, k, mid+<span class="number">1</span>, trr, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  T _query(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trl, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trr, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (trl &gt;= l &amp;&amp; trr &lt;= r) <span class="keyword">return</span> tr[i];
    push_down(i, trr-trl+<span class="number">1</span>);
    <span class="keyword">int</span> mid = (trl+trr)&gt;&gt;<span class="number">1</span>;
    T res = <span class="number">0</span>;
    <span class="keyword">if</span> (l &lt;= mid) res += _query(l, r, trl, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (r &gt;  mid) res += _query(l, r, mid+<span class="number">1</span>, trr, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    <span class="keyword">return</span> res;
  }
};
</code></pre>

    </div>
</div>
<h3 id="区间加减区间最值"><a href="#区间加减区间最值" class="headerlink" title="区间加减区间最值"></a>区间加减区间最值</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = greater&lt;T&gt;&gt;
struct SegmentTree {
  U cmp = U();
  <span class="keyword">int</span> n;
  T tr[N&lt;&lt;<span class="number">2</span>], lazy[N&lt;&lt;<span class="number">2</span>], init_val = cmp(<span class="number">0</span>, <span class="number">1</span>) ? INF : -INF;
  SegmentTree(){}
  <span class="function">T <span class="title">mv</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>{ <span class="keyword">return</span> cmp(x, y) ? x : y;}
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n, <span class="keyword">const</span> T &amp;k = <span class="number">0</span>)</span> </span>{ n = _n; _build(<span class="number">1</span>, n, k); }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> TT a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;_n)</span> </span>{ n = _n; _build(a, <span class="number">1</span>, n); }
  <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ _modify(x, k, <span class="number">1</span>, n); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ _add(x, x, k, <span class="number">1</span>, n); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k)</span> </span>{ _add(l, r, k, <span class="number">1</span>, n); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{ <span class="keyword">return</span> _query(x, x, <span class="number">1</span>, n); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{ <span class="keyword">return</span> _query(l, r, <span class="number">1</span>, n); }
<span class="keyword">private</span> :
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span> </span>{ tr[i] = mv(tr[i&lt;&lt;<span class="number">1</span>], tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]); }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span> </span>{
    <span class="keyword">if</span> (!lazy[i]) <span class="keyword">return</span>;
    tr[i&lt;&lt;<span class="number">1</span>] += lazy[i];
    tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += lazy[i];
    lazy[i&lt;&lt;<span class="number">1</span>] += lazy[i];
    lazy[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += lazy[i];
    lazy[i] = <span class="number">0</span>;
  }
  <span class="keyword">void</span> _build(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    lazy[i] = <span class="number">0</span>;
    <span class="keyword">if</span> (l == r) { tr[i] = k; <span class="keyword">return</span>; }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    _build(l, mid, k, i&lt;&lt;<span class="number">1</span>);
    _build(mid+<span class="number">1</span>, r, k, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="keyword">void</span> _build(<span class="keyword">const</span> TT a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    lazy[i] = <span class="number">0</span>;
    <span class="keyword">if</span> (l == r) { tr[i] = a[l]; <span class="keyword">return</span>; }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    _build(a, l, mid, i&lt;&lt;<span class="number">1</span>);
    _build(a, mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">void</span> _modify(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trl, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trr, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (trl == x &amp;&amp; trr == x) <span class="keyword">return</span> tr[i] = k, <span class="keyword">void</span>();
    push_down(i);
    <span class="keyword">int</span> mid = (trl+trr)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) _modify(x, k, trl, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">else</span> _modify(x, k, mid+<span class="number">1</span>, trr, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">void</span> _add(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trl, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trr, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (trl &gt;= l &amp;&amp; trr &lt;= r) {
      tr[i] += k;
      lazy[i] += k;
      <span class="keyword">return</span>;
    }
    push_down(i);
    <span class="keyword">int</span> mid = (trl+trr)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid) _add(l, r, k, trl, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (r &gt;  mid) _add(l, r, k, mid+<span class="number">1</span>, trr, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  T _query(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trl, <span class="keyword">const</span> <span class="keyword">int</span> &amp;trr, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (trl &gt;= l &amp;&amp; trr &lt;= r) <span class="keyword">return</span> tr[i];
    push_down(i);
    <span class="keyword">int</span> mid = (trl+trr)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (r &lt;=  mid) <span class="keyword">return</span> _query(l, r, trl, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (l &gt;  mid) <span class="keyword">return</span> _query(l, r, mid+<span class="number">1</span>, trr, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    <span class="keyword">return</span> mv(_query(l, r, trl, mid, i&lt;&lt;<span class="number">1</span>), _query(l, r, mid+<span class="number">1</span>, trr, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));
  }
};
</code></pre>

    </div>
</div>
<h3 id="区间更新最值"><a href="#区间更新最值" class="headerlink" title="区间更新最值"></a>区间更新最值</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = greater&lt;T&gt;&gt;
struct SegmentTree {
  SegmentTree(){}
  <span class="keyword">void</span> build(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n, <span class="keyword">const</span> T &amp;k = <span class="number">0</span>) { n = _n; _build(<span class="number">1</span>, n, k); }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">buiil</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> _n, <span class="keyword">const</span> TT a[])</span> </span>{ n = _n; _build(<span class="number">1</span>, n, a); }
  <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ _modify(x, x, k); }
  <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k)</span> </span>{ _modify(l, r, k); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ _add(x, k); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{ <span class="keyword">return</span> _query(x, x); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{ <span class="keyword">return</span> _query(l, r); }
<span class="keyword">private</span>:
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span>
<span class="class">  {</span>
    <span class="keyword">int</span> l, r;
    T v, lazy;
  } tr[N&lt;&lt;<span class="number">2</span>];
  <span class="keyword">int</span> n;
  T init_val = cmp(<span class="number">0</span>, <span class="number">1</span>) ? INF : -INF;
  U cmp = U();
  <span class="function">T <span class="title">mv</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>{ <span class="keyword">return</span> cmp(x, y) ? x : y;}
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i, <span class="keyword">const</span> T &amp;k)</span> </span>{ tr[i].v = mv(tr[i].v, k); tr[i].lazy = mv(tr[i].lazy, k); }
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span> </span>{ tr[i].v = mv(tr[i&lt;&lt;<span class="number">1</span>].v, tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v); }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span> </span>{
    <span class="keyword">if</span> (tr[i].lazy == init_val) <span class="keyword">return</span>;
    update(i&lt;&lt;<span class="number">1</span>, tr[i].lazy);
    update(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, tr[i].lazy);
    tr[i].lazy = init_val;
  }
  <span class="keyword">void</span> _build(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    tr[i].lazy = init_val;
    tr[i].l = l; tr[i].r = r;
    <span class="keyword">if</span> (l == r) { tr[i].v = k; <span class="keyword">return</span>; }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    _build(l, mid, k, i&lt;&lt;<span class="number">1</span>);
    _build(mid+<span class="number">1</span>, r, k, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="keyword">void</span> _build(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> TT a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    tr[i].lazy = init_val;
    tr[i].l = l; tr[i].r = r;
    <span class="keyword">if</span> (l == r) { tr[i].v = a[l]; <span class="keyword">return</span>; }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    _build(l, mid, a, i&lt;&lt;<span class="number">1</span>);
    _build(mid+<span class="number">1</span>, r, a, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">void</span> _modify(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (tr[i].l  &gt;= l &amp;&amp; tr[i].r &lt;= r) { update(i, k); <span class="keyword">return</span>; }
    push_down(i);
    <span class="keyword">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid) _modify(l, r, k, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (r &gt;  mid) _modify(l, r, k, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="keyword">void</span> _add(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (tr[i].l == x &amp;&amp; tr[i].r == x) { tr[i].v += k; <span class="keyword">return</span>; }
    push_down(i);
    <span class="keyword">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) _add(x, k, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">else</span> _add(x, k, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  T _query(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i = <span class="number">1</span>) {
    <span class="keyword">if</span> (tr[i].l  &gt;= l &amp;&amp; tr[i].r &lt;= r) <span class="keyword">return</span> tr[i].v;
    push_down(i);
    <span class="keyword">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;
    T res = init_val;
    <span class="keyword">if</span> (l &lt;= mid) res = mv(res, _query(l, r, i&lt;&lt;<span class="number">1</span>));
    <span class="keyword">if</span> (r &gt;  mid) res = mv(res, _query(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));
    <span class="keyword">return</span> res;
  }
};
</code></pre>

    </div>
</div>
<h3 id="区间最大连续子段和"><a href="#区间最大连续子段和" class="headerlink" title="区间最大连续子段和"></a>区间最大连续子段和</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> {</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">long</span> <span class="keyword">long</span> s, ls, rs, ms;
    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>{ s = ls = rs = ms = x; }
    <span class="keyword">friend</span> TreeNode <span class="keyword">operator</span> +(<span class="keyword">const</span> TreeNode &amp;lc, <span class="keyword">const</span> TreeNode &amp;rc) {
      <span class="keyword">return</span> TreeNode {
          lc.s+rc.s,
          max(lc.ls, lc.s+rc.ls),
          max(rc.rs, lc.rs+rc.s),
          max({lc.ms, rc.ms, lc.rs+rc.ls})
      };
    }
  } tr[N&lt;&lt;<span class="number">2</span>];
  <span class="keyword">int</span> *a, n;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>{
    <span class="keyword">this</span>-&gt;a = a;
    <span class="keyword">this</span>-&gt;n = n;
    build(<span class="number">1</span>, n, <span class="number">1</span>);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[i].<span class="built_in">set</span>(a[l]);
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    build(l, mid, i&lt;&lt;<span class="number">1</span>);
    build(mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    tr[i] = tr[i&lt;&lt;<span class="number">1</span>]+tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>{ update(x, v, <span class="number">1</span>, n, <span class="number">1</span>); }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[i].<span class="built_in">set</span>(v);
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) update(x, v, l, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">else</span> update(x, v, mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    tr[i] = tr[i&lt;&lt;<span class="number">1</span>]+tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];
  }
  <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>{ <span class="keyword">return</span> query(L, R, <span class="number">1</span>, n, <span class="number">1</span>).ms; }
  <span class="function">TreeNode <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">if</span> (l &gt;= L &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[i];
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (R &lt;= mid) <span class="keyword">return</span> query(L, R, l, mid, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (L &gt;  mid) <span class="keyword">return</span> query(L, R, mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    <span class="keyword">return</span> query(L, R, l, mid, i&lt;&lt;<span class="number">1</span>)+query(L, R, mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
  }
};
</code></pre>

    </div>
</div>
<h2 id="ZKW线段树"><a href="#ZKW线段树" class="headerlink" title="ZKW线段树"></a>ZKW线段树</h2><p><code>warning:区间最值尚为验证</code><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">zkwSegmentTree</span> {</span>
  <span class="keyword">int</span> sz;
  T sum[N&lt;&lt;<span class="number">2</span>], mn[N&lt;&lt;<span class="number">2</span>], mx[N&lt;&lt;<span class="number">2</span>], add[N&lt;&lt;<span class="number">2</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{
    T tmp;
    tmp = min(mn[x], mn[x^<span class="number">1</span>]); mn[x] -= tmp; mn[x^<span class="number">1</span>] -= tmp; mn[x&gt;&gt;<span class="number">1</span>] += tmp;
    tmp = max(mx[x], mx[x^<span class="number">1</span>]); mx[x] -= tmp; mx[x^<span class="number">1</span>] -= tmp; mx[x&gt;&gt;<span class="number">1</span>] += tmp;
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> TT a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="keyword">for</span> (sz = <span class="number">1</span>; sz &lt;= n+<span class="number">1</span>; sz &lt;&lt;= <span class="number">1</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz+<span class="number">1</span>; i &lt;= sz+n; ++i)
      sum[i] = mn[i] = mx[i] = a[i-sz];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz<span class="number">-1</span>; i; --i) {
      sum[i] = sum[i&lt;&lt;<span class="number">1</span>]+sum[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];
      mn[i] = min(mn[i&lt;&lt;<span class="number">1</span>], mn[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]); mn[i&lt;&lt;<span class="number">1</span>] -= mn[i]; mn[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] -= mn[i];
      mx[i] = max(mx[i&lt;&lt;<span class="number">1</span>], mx[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]); mx[i&lt;&lt;<span class="number">1</span>] -= mx[i]; mx[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] -= mx[i];
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> T &amp;v)</span> </span>{
    x += sz; mx[x] += v; mn[x] += v; sum[x] += v;
    <span class="keyword">for</span> ( ; x &gt; <span class="number">1</span>; x &gt;&gt;= <span class="number">1</span>) {
      sum[x] += v;
      update(x);
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">const</span> T &amp;v)</span> </span>{
    <span class="keyword">int</span> lc = <span class="number">0</span>, rc = <span class="number">0</span>, len = <span class="number">1</span>;
    <span class="keyword">for</span> (s += sz<span class="number">-1</span>, t += sz+<span class="number">1</span>; s^t^<span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>, len &lt;&lt;= <span class="number">1</span>) {
      <span class="keyword">if</span> (~s&amp;<span class="number">1</span>) add[s^<span class="number">1</span>] += v, lc += len, mn[s^<span class="number">1</span>] += v, mx[s^<span class="number">1</span>] += v;
      <span class="keyword">if</span> ( t&amp;<span class="number">1</span>) add[t^<span class="number">1</span>] += v, rc += len, mn[t^<span class="number">1</span>] += v, mx[t^<span class="number">1</span>] += v;
      sum[s&gt;&gt;<span class="number">1</span>] += v*lc; sum[t&gt;&gt;<span class="number">1</span>] += v*rc;
      update(s); update(t);
    }
    <span class="keyword">for</span> (lc += rc; s; s &gt;&gt;= <span class="number">1</span>) {
      sum[s&gt;&gt;<span class="number">1</span>] += v*lc;
      update(s);
    }
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    T res = <span class="number">0</span>;
    <span class="keyword">for</span> (x += sz; x; x &gt;&gt;= <span class="number">1</span>) res += mn[x];
    <span class="keyword">return</span> res;
  }
  <span class="function">T <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>{
    <span class="keyword">int</span> lc = <span class="number">0</span>, rc = <span class="number">0</span>, len = <span class="number">1</span>;
    T res = <span class="number">0</span>;
    <span class="keyword">for</span> (s += sz<span class="number">-1</span>, t += sz+<span class="number">1</span>; s^t^<span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>, len &lt;&lt;= <span class="number">1</span>) {
      <span class="keyword">if</span> (~s&amp;<span class="number">1</span>) res += sum[s^<span class="number">1</span>]+len*add[s^<span class="number">1</span>], lc += len;
      <span class="keyword">if</span> ( t&amp;<span class="number">1</span>) res += sum[t^<span class="number">1</span>]+len*add[t^<span class="number">1</span>], rc += len;
      <span class="keyword">if</span> (add[s&gt;&gt;<span class="number">1</span>]) res += add[s&gt;&gt;<span class="number">1</span>]*lc;
      <span class="keyword">if</span> (add[t&gt;&gt;<span class="number">1</span>]) res += add[t&gt;&gt;<span class="number">1</span>]*rc;
    }
    <span class="keyword">for</span> (lc += rc, s &gt;&gt;= <span class="number">1</span>; s; s &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span> (add[s]) res += add[s]*lc;
    <span class="keyword">return</span> res;
  }
  <span class="function">T <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>{
    <span class="keyword">if</span> (s == t) <span class="keyword">return</span> query(s);
    T l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>;
    <span class="keyword">for</span> (s += sz, t += sz; s^t^<span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>) {
      l += mn[s]; r += mn[t];
      <span class="keyword">if</span> (~s^<span class="number">1</span>) l = min(l, mn[s^<span class="number">1</span>]);
      <span class="keyword">if</span> ( t^<span class="number">1</span>) r = min(r, mn[t^<span class="number">1</span>]);
    }
    <span class="keyword">for</span> (res = min(l, r), s &gt;&gt;= <span class="number">1</span>; s; s &gt;&gt;= <span class="number">1</span>) res += mn[s];
    <span class="keyword">return</span> res;
  }
  <span class="function">T <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>{
    <span class="keyword">if</span> (s == t) <span class="keyword">return</span> query(s);
    T l = <span class="number">0</span>, r = <span class="number">0</span>, res = <span class="number">0</span>;
    <span class="keyword">for</span> (s += sz, t += sz; s^t^<span class="number">1</span>; s &gt;&gt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>) {
      l += mx[s]; r += mx[t];
      <span class="keyword">if</span> (~s^<span class="number">1</span>) l = max(l, mx[s^<span class="number">1</span>]);
      <span class="keyword">if</span> ( t^<span class="number">1</span>) r = max(r, mx[t^<span class="number">1</span>]);
    }
    <span class="keyword">for</span> (res = max(l, r), s &gt;&gt;= <span class="number">1</span>; s; s &gt;&gt;= <span class="number">1</span>) res += mx[s];
    <span class="keyword">return</span> res;
  }
};
</code></pre>

    </div>
</div></p>
<h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><p>李超线段树是一种用于维护平面直角坐标系内线段关系的数据结构。它常被用来处理这样一种形式的问题：给定一个平面直角坐标系，支持动态插入一条线段，询问从某一个位置 (x,+∞) 向下看能看到的最高的一条线段（也就是给一条竖线，问这条竖线与所有线段的最高的交点。</p>
<h2 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h2><p>有 $O(m)$ 棵树(个操作) 结点数量 $O(m\log n)$, 暴力合并,均摊复杂度 $O(\log n)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ <span class="comment">// 太难了,现场全重写吧</span>
  <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x+y;
  <span class="keyword">int</span> &amp;z = x; <span class="comment">// int z = new_node(); // 新建结点?</span>
  lc[z] = merge(lc[x], lc[y]);
  rc[z] = merge(rc[x], rc[y]);
  <span class="keyword">if</span> (!lc[z] &amp;&amp; !rc[z]) tr[z].first = tr[x].first+tr[y].first;
  <span class="keyword">else</span> push_up(z); <span class="comment">// tr[z] = giao(x, y);</span>
  <span class="comment">// del(y); // del(x); // 保留结点?</span>
  <span class="keyword">return</span> z;
}
</code></pre>

    </div>
</div>
<h2 id="线段树分裂"><a href="#线段树分裂" class="headerlink" title="线段树分裂"></a><a href="https://www.luogu.com.cn/problem/P5494" target="_blank" rel="noopener">线段树分裂</a></h2><p>一次分裂复杂度 $O(\log n)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> {</span>
  <span class="keyword">int</span> tot, lc[NLOG], rc[NLOG];
  T tr[NLOG];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{ tot = <span class="number">0</span>; }
  <span class="function">T <span class="title">giao</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>{ <span class="keyword">return</span> x+y; }
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{ tr[i] = giao(tr[lc[i]], tr[rc[i]]); }
  <span class="function"><span class="keyword">int</span> <span class="title">new_node</span><span class="params">(T v = <span class="number">0</span>)</span> </span>{
    ++tot; <span class="comment">// assert(++tot &lt; NLOG);</span>
    lc[tot] = rc[tot] = <span class="number">0</span>;
    tr[tot] = v;
    <span class="keyword">return</span> tot;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, T v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> &amp;i)</span> </span>{
    <span class="keyword">if</span> (!i) i = new_node();
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[i] += v, <span class="keyword">void</span>();
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) add(x, v, l, mid, lc[i]);
    <span class="keyword">else</span> add(x, v, mid+<span class="number">1</span>, r, rc[i]);
    push_up(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>{ <span class="comment">// merge y to x</span>
    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x += y, <span class="keyword">void</span>();
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[x] += tr[y], <span class="keyword">void</span>();
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    merge(l, mid, lc[x], lc[y]);
    merge(mid+<span class="number">1</span>, r, rc[x], rc[y]);
    push_up(x); <span class="comment">// del(y);</span>
  }
  <span class="comment">/*</span>
<span class="comment">  int merge(int l, int r, int x, int y) { // new node</span>
<span class="comment">    if (!x || !y) return x += y;</span>
<span class="comment">    int cur = new_node(), mid = (l+r)&gt;&gt;1;</span>
<span class="comment">    if (l == r) return tr[cur] = tr[x]+tr[y], cur;</span>
<span class="comment">    lc[cur] = merge(l, mid, lc[x], lc[y]);</span>
<span class="comment">    rc[cur] = merge(mid+1, r, rc[x], rc[y]);</span>
<span class="comment">    push_up(cur);</span>
<span class="comment">    return cur;</span>
<span class="comment">  }</span>
<span class="comment">  */</span>
  <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>{ <span class="comment">//split x [L, R] to y</span>
    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;
    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> y = x, x = <span class="number">0</span>, <span class="keyword">void</span>();
    <span class="keyword">if</span> (!y) y = new_node();
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (L &lt;= mid) split(L, R, l, mid, lc[x], lc[y]);
    <span class="keyword">if</span> (R &gt;  mid) split(L, R, mid+<span class="number">1</span>, r, rc[x], rc[y]);
    push_up(x); push_up(y);
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">if</span> (!i) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> tr[i];
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (R &lt;= mid) <span class="keyword">return</span> query(L, R, l, mid, lc[i]);
    <span class="keyword">if</span> (L &gt;  mid) <span class="keyword">return</span> query(L, R, mid+<span class="number">1</span>, r, rc[i]);
    <span class="keyword">return</span> giao(query(L, R, l, mid, lc[i]), query(L, R, mid+<span class="number">1</span>, r, rc[i]));
  }
  <span class="function"><span class="keyword">int</span> <span class="title">query_kth</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (k &lt;= tr[lc[i]]) <span class="keyword">return</span> query_kth(k, l, mid, lc[i]);
    <span class="keyword">return</span> query_kth(k-tr[lc[i]], mid+<span class="number">1</span>, r, rc[i]);
  }
};
</code></pre>

    </div>
</div>
<h2 id="猫树"><a href="#猫树" class="headerlink" title="猫树"></a>猫树</h2><p>所谓 “猫树” 就是一种不支持修改，仅仅支持快速区间询问的一种静态线段树。</p>
<p>构造一棵这样的静态线段树需要 $O(n\log n)$ 次合并操作，但是此时的查询复杂度被加速至 $O(1)$ 次合并操作。</p>
<h2 id="吉老师线段树-吉司机线段树"><a href="#吉老师线段树-吉司机线段树" class="headerlink" title="吉老师线段树|吉司机线段树"></a><a href="https://www.luogu.com.cn/blog/Hakurei-Reimu/seg-beats" target="_blank" rel="noopener">吉老师线段树|吉司机线段树</a></h2><h3 id="区间最值操作"><a href="#区间最值操作" class="headerlink" title="区间最值操作"></a>区间最值操作</h3><ol>
<li>区间取min</li>
<li>询问区间min</li>
<li>询问区间和</li>
</ol>
<p>$O(m \log n)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> {</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">int</span> l, r, mx, se, cnt, tag;
    ll sum;
  } tr[N&lt;&lt;<span class="number">2</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    tr[i].sum = tr[i&lt;&lt;<span class="number">1</span>].sum+tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;
    <span class="keyword">if</span> (tr[i&lt;&lt;<span class="number">1</span>].mx &gt; tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx) {
      tr[i].mx = tr[i&lt;&lt;<span class="number">1</span>].mx;
      tr[i].cnt = tr[i&lt;&lt;<span class="number">1</span>].cnt;
      tr[i].se = max(tr[i&lt;&lt;<span class="number">1</span>].se, tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx);
    } <span class="keyword">else</span> <span class="keyword">if</span> (tr[i&lt;&lt;<span class="number">1</span>].mx &lt; tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx) {
      tr[i].mx = tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx;
      tr[i].cnt = tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;
      tr[i].se = max(tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].se, tr[i&lt;&lt;<span class="number">1</span>].mx);
    } <span class="keyword">else</span> {
      tr[i].mx = tr[i&lt;&lt;<span class="number">1</span>].mx;
      tr[i].cnt = tr[i&lt;&lt;<span class="number">1</span>].cnt+tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].cnt;
      tr[i].se = max(tr[i&lt;&lt;<span class="number">1</span>].se, tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].se);
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_tag</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> v)</span> </span>{
    <span class="keyword">if</span> (v &gt;= tr[i].mx) <span class="keyword">return</span>;
    tr[i].sum -= <span class="number">1l</span>l*(tr[i].mx-v)*tr[i].cnt;
    tr[i].mx = tr[i].tag = v;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">if</span> (tr[i].tag == <span class="number">-1</span>) <span class="keyword">return</span>;
    push_tag(i&lt;&lt;<span class="number">1</span>, tr[i].tag);
    push_tag(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, tr[i].tag);
    tr[i].tag = <span class="number">-1</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    tr[i].l = l; tr[i].r = r; tr[i].tag = <span class="number">-1</span>;
    <span class="keyword">if</span> (l == r) {
      tr[i].sum = tr[i].mx = a[l];
      tr[i].cnt = <span class="number">1</span>;
      tr[i].se = <span class="number">-1</span>;
      <span class="keyword">return</span>;
    }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    build(l, mid, i&lt;&lt;<span class="number">1</span>);
    build(mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (v &gt;= tr[i].mx) <span class="keyword">return</span>;
    <span class="keyword">if</span> (l &lt;= tr[i].l &amp;&amp; r &gt;= tr[i].r &amp;&amp; v &gt; tr[i].se) <span class="keyword">return</span> push_tag(i, v);
    push_down(i);
    <span class="keyword">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid) update_min(l, r, v, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (r &gt;  mid) update_min(l, r, v, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (l &lt;= tr[i].l &amp;&amp; r &gt;= tr[i].r) <span class="keyword">return</span> tr[i].mx;
    push_down(i);
    <span class="keyword">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> query_max(l, r, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (l &gt;  mid) <span class="keyword">return</span> query_max(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    <span class="keyword">return</span> max(query_max(l, r, i&lt;&lt;<span class="number">1</span>), query_max(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));
  }
  <span class="function">ll <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (l &lt;= tr[i].l &amp;&amp; r &gt;= tr[i].r) <span class="keyword">return</span> tr[i].sum;
    push_down(i);
    <span class="keyword">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> query_sum(l, r, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">if</span> (l &gt;  mid) <span class="keyword">return</span> query_sum(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    <span class="keyword">return</span> query_sum(l, r, i&lt;&lt;<span class="number">1</span>)+query_sum(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
  }
};
</code></pre>

    </div>
</div>
<ol>
<li>给一个区间[L,R] 加上一个数x </li>
<li>把一个区间[L,R] 里小于x 的数变成x </li>
<li>把一个区间[L,R] 里大于x 的数变成x </li>
<li>求区间[L,R] 的和</li>
<li>求区间[L,R] 的最大值</li>
<li>求区间[L,R] 的最小值</li>
</ol>
<p>$O(m\log^2 n)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> {</span>
<span class="meta">#<span class="meta-keyword">define</span> rt tr[i]</span>
<span class="meta">#<span class="meta-keyword">define</span> ls tr[i&lt;&lt;1]</span>
<span class="meta">#<span class="meta-keyword">define</span> rs tr[i&lt;&lt;1|1]</span>
  <span class="keyword">typedef</span> <span class="keyword">int</span> T;
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">int</span> l, r;
    T mn1, mn2, mx1, mx2, cmn, cmx, tag1, tag2, tag3;
    <span class="keyword">long</span> <span class="keyword">long</span> sum;
  };
  <span class="built_in">vector</span>&lt;T&gt; a;
  <span class="built_in">vector</span>&lt;TreeNode&gt; tr;
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    rt.sum = ls.sum+rs.sum;
    <span class="keyword">if</span> (ls.mn1 == rs.mn1) {
      rt.mn1 = ls.mn1;
      rt.cmn = ls.cmn+rs.cmn;
      rt.mn2 = min(ls.mn2, rs.mn2);
    } <span class="keyword">else</span> <span class="keyword">if</span> (ls.mn1 &lt; rs.mn1) {
      rt.mn1 = ls.mn1;
      rt.cmn = ls.cmn;
      rt.mn2 = min(ls.mn2, rs.mn1);
    } <span class="keyword">else</span> <span class="keyword">if</span> (ls.mn1 &gt; rs.mn1) {
      rt.mn1 = rs.mn1;
      rt.cmn = rs.cmn;
      rt.mn2 = min(ls.mn1, rs.mn2);
    }
    <span class="keyword">if</span> (ls.mx1 == rs.mx1) {
      rt.mx1 = ls.mx1;
      rt.cmx = ls.cmx+rs.cmx;
      rt.mx2 = max(ls.mx2, rs.mx2);
    } <span class="keyword">else</span> <span class="keyword">if</span> (ls.mx1 &gt; rs.mx1) {
      rt.mx1 = ls.mx1;
      rt.cmx = ls.cmx;
      rt.mx2 = max(ls.mx2, rs.mx1);
    } <span class="keyword">else</span> <span class="keyword">if</span> (ls.mx1 &lt; rs.mx1) {
      rt.mx1 = rs.mx1;
      rt.cmx = rs.cmx;
      rt.mx2 = max(ls.mx1, rs.mx2);
    }
  }
  <span class="comment">// 1 2 3 -&gt; min, max, other</span>
  <span class="function"><span class="keyword">void</span> <span class="title">push_tag</span><span class="params">(<span class="keyword">int</span> i, T add1, T add2, T add3)</span> </span>{
    <span class="keyword">if</span> (rt.mn1 == rt.mx1) {
      add1 == add3 ? add1 = add2 : add2 = add1; <span class="comment">// 不应被其他值的标记作用</span>
      rt.sum += <span class="number">1l</span>l*rt.cmn*add1;
    } <span class="keyword">else</span> {
      rt.sum += <span class="number">1l</span>l*rt.cmn*add1+<span class="number">1l</span>l*rt.cmx*add2
          +(rt.r-rt.l+<span class="number">1l</span>l-rt.cmn-rt.cmx)*add3;
    }
    <span class="keyword">if</span> (rt.mn2 == rt.mx1) rt.mn2 += add2;
    <span class="keyword">else</span> <span class="keyword">if</span> (rt.mn2 != INF) rt.mn2 += add3;
    <span class="keyword">if</span> (rt.mx2 == rt.mn1) rt.mx2 += add1;
    <span class="keyword">else</span> <span class="keyword">if</span> (rt.mx2 != -INF) rt.mx2 += add3;
    rt.mn1 += add1; rt.mx1 += add2;
    rt.tag1 += add1; rt.tag2 += add2; rt.tag3 += add3;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    T mn = min(ls.mn1, rs.mn1);
    T mx = max(ls.mx1, rs.mx1);
    push_tag(i&lt;&lt;<span class="number">1</span>  , ls.mn1 == mn ? rt.tag1 : rt.tag3, ls.mx1 == mx ? rt.tag2 : rt.tag3, rt.tag3);
    push_tag(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, rs.mn1 == mn ? rt.tag1 : rt.tag3, rs.mx1 == mx ? rt.tag2 : rt.tag3, rt.tag3);
    rt.tag1 = rt.tag2 = rt.tag3 = <span class="number">0</span>;
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n, TT arr[])</span> </span>{
    a.resize(<span class="number">1</span>);
    a.insert(a.end(), arr+<span class="number">1</span>, arr+n+<span class="number">1</span>);
    tr.resize(n*<span class="number">4</span>+<span class="number">1</span>);
    build(<span class="number">1</span>, n, <span class="number">1</span>);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n, T val = <span class="number">0</span>)</span> </span>{
    a.resize(n+<span class="number">1</span>, val);
    tr.resize(n*<span class="number">4</span>+<span class="number">1</span>);
    build(<span class="number">1</span>, n, <span class="number">1</span>);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>{
    rt.l = l; rt.r = r;
    rt.tag1 = rt.tag2 = rt.tag3 = <span class="number">0</span>;
    <span class="keyword">if</span> (l == r) {
      rt.sum = rt.mn1 = rt.mx1 = a[l];
      rt.mn2 = INF; rt.mx2 = -INF;
      rt.cmn = rt.cmx = <span class="number">1</span>;
      <span class="keyword">return</span>;
    }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    build(l, mid, i&lt;&lt;<span class="number">1</span>); build(mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update_add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T v, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span>;
    <span class="keyword">if</span> (rt.l &gt;= l &amp;&amp; rt.r &lt;= r)
      <span class="keyword">return</span> push_tag(i, v, v, v);
    push_down(i);
    update_add(l, r, v, i&lt;&lt;<span class="number">1</span>); update_add(l, r, v, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T v, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r || rt.mn1 &gt;= v) <span class="keyword">return</span>;
    <span class="keyword">if</span> (rt.l &gt;= l &amp;&amp; rt.r &lt;= r &amp;&amp; rt.mn2 &gt; v)
      <span class="keyword">return</span> push_tag(i, v-rt.mn1, <span class="number">0</span>, <span class="number">0</span>);
    push_down(i);
    update_max(l, r, v, i&lt;&lt;<span class="number">1</span>); update_max(l, r, v, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T v, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r || rt.mx1 &lt;= v) <span class="keyword">return</span>;
    <span class="keyword">if</span> (rt.l &gt;= l &amp;&amp; rt.r &lt;= r &amp;&amp; rt.mx2 &lt; v)
      <span class="keyword">return</span> push_tag(i, <span class="number">0</span>, v-rt.mx1, <span class="number">0</span>);
    push_down(i);
    update_min(l, r, v, i&lt;&lt;<span class="number">1</span>); update_min(l, r, v, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span> (rt.l &gt;= l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> rt.sum;
    push_down(i);
    <span class="keyword">return</span> query_sum(l, r, i&lt;&lt;<span class="number">1</span>)+query_sum(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
  }
  <span class="function">T <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span> -INF;
    <span class="keyword">if</span> (rt.l &gt;= l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> rt.mx1;
    push_down(i);
    <span class="keyword">return</span> max(query_max(l, r, i&lt;&lt;<span class="number">1</span>), query_max(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));
  }
  <span class="function">T <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span> INF;
    <span class="keyword">if</span> (rt.l &gt;= l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> rt.mn1;
    push_down(i);
    <span class="keyword">return</span> min(query_min(l, r, i&lt;&lt;<span class="number">1</span>), query_min(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));
  }
<span class="meta">#<span class="meta-keyword">undef</span> rt</span>
<span class="meta">#<span class="meta-keyword">undef</span> ls</span>
<span class="meta">#<span class="meta-keyword">undef</span> rs</span>
};
</code></pre>

    </div>
</div>
<h3 id="区间历史最值"><a href="#区间历史最值" class="headerlink" title="区间历史最值"></a>区间历史最值</h3><h3 id="区间加区间修改"><a href="#区间加区间修改" class="headerlink" title="区间加区间修改"></a>区间加区间修改</h3><ol>
<li>区间加</li>
<li>区间修改</li>
<li>区间最大值</li>
<li>区间历史最大值</li>
</ol>
<p>$O(m\log n)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> {</span>
<span class="meta">#<span class="meta-keyword">define</span> rt tr[i]</span>
<span class="meta">#<span class="meta-keyword">define</span> ls tr[i&lt;&lt;1]</span>
<span class="meta">#<span class="meta-keyword">define</span> rs tr[i&lt;&lt;1|1]</span>
  <span class="keyword">typedef</span> <span class="keyword">int</span> T;
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">int</span> l, r;
    <span class="keyword">bool</span> tag;
    T add, cov, mx, hadd, hcov, hmx;
  } tr[N&lt;&lt;<span class="number">2</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    rt.mx = max(ls.mx, rs.mx);
    rt.hmx = max(ls.hmx, rs.hmx);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> i, T k, T hk)</span> </span>{
    rt.hmx = max(rt.hmx, rt.mx+hk);
    rt.mx += k;
    rt.tag ? rt.hcov = max(rt.hcov, rt.cov+hk), rt.cov += k
        : rt.hadd = max(rt.hadd, rt.add+hk), rt.add += k;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> i, T k, T hk)</span> </span>{
    rt.hmx = max(rt.hmx, hk);
    rt.mx = k;
    rt.hcov = max(rt.hcov, hk);
    rt.cov = k;
    rt.tag = <span class="number">1</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    <span class="keyword">if</span> (rt.add) {
      plus(i&lt;&lt;<span class="number">1</span>  , rt.add, rt.hadd);
      plus(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, rt.add, rt.hadd);
      rt.add = rt.hadd = <span class="number">0</span>;
    }
    <span class="keyword">if</span> (rt.tag) {
      cover(i&lt;&lt;<span class="number">1</span>  , rt.cov, rt.hcov);
      cover(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, rt.cov, rt.hcov);
      rt.tag = <span class="number">0</span>; rt.hcov = -INF;
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    rt.l = l; rt.r = r; rt.tag = <span class="literal">false</span>;
    rt.add = rt.hadd = <span class="number">0</span>;
    rt.hcov = -INF;
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> rt.hmx = rt.mx = <span class="number">0</span>, <span class="keyword">void</span>();
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    build(l, mid, i&lt;&lt;<span class="number">1</span>); build(mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function">T <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span> -INF;
    <span class="keyword">if</span> (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> rt.mx;
    push_down(i);
    <span class="keyword">return</span> max(query_max(l, r, i&lt;&lt;<span class="number">1</span>), query_max(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));
  }
  <span class="function">T <span class="title">query_hmax</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span> -INF;
    <span class="keyword">if</span> (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> rt.hmx;
    push_down(i);
    <span class="keyword">return</span> max(query_hmax(l, r, i&lt;&lt;<span class="number">1</span>), query_hmax(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update_add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T v, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span>;
    <span class="keyword">if</span> (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> plus(i, v, v);
    push_down(i);
    update_add(l, r, v, i&lt;&lt;<span class="number">1</span>); update_add(l, r, v, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update_cov</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T v, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span>;
    <span class="keyword">if</span> (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> cover(i, v, v);
    push_down(i);
    update_cov(l, r, v, i&lt;&lt;<span class="number">1</span>); update_cov(l, r, v, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
<span class="meta">#<span class="meta-keyword">undef</span> rt</span>
<span class="meta">#<span class="meta-keyword">undef</span> ls</span>
<span class="meta">#<span class="meta-keyword">undef</span> rs</span>
};
</code></pre>

    </div>
</div>
<h3 id="区间最值操作与历史最值询问同向"><a href="#区间最值操作与历史最值询问同向" class="headerlink" title="区间最值操作与历史最值询问同向"></a>区间最值操作与历史最值询问同向</h3><p>单点查询</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> {</span>
<span class="meta">#<span class="meta-keyword">define</span> rt tr[i]</span>
<span class="meta">#<span class="meta-keyword">define</span> ls tr[i&lt;&lt;1]</span>
<span class="meta">#<span class="meta-keyword">define</span> rs tr[i&lt;&lt;1|1]</span>
  <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> T;
  <span class="class"><span class="keyword">struct</span> <span class="title">Tag</span> {</span>
    T add, mx;
    Tag(T _add = <span class="number">0</span>, T _mx = -INF) : add(_add), mx(_mx) {}
    Tag <span class="keyword">operator</span> +(<span class="keyword">const</span> Tag &amp;t) <span class="keyword">const</span> { <span class="comment">// 合并tag</span>
      <span class="keyword">return</span> Tag(max(-INF, add+t.add), max(mx+t.add, t.mx));
    }
    Tag <span class="keyword">operator</span> *(<span class="keyword">const</span> Tag &amp;t) <span class="keyword">const</span> { <span class="comment">// 取max</span>
      <span class="keyword">return</span> Tag(max(add, t.add), max(mx, t.mx));
    }
    Tag&amp; <span class="keyword">operator</span> +=(<span class="keyword">const</span> Tag &amp;t) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+t; }
    Tag&amp; <span class="keyword">operator</span> *=(<span class="keyword">const</span> Tag &amp;t) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*t; }
  };
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">int</span> l, r;
    Tag his, cur;
  } tr[N&lt;&lt;<span class="number">2</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">push_tag</span><span class="params">(<span class="keyword">int</span> i, Tag hk, Tag k)</span> </span>{
    rt.his *= rt.cur+hk;
    rt.cur += k;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    push_tag(i&lt;&lt;<span class="number">1</span>  , rt.his, rt.cur);
    push_tag(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, rt.his, rt.cur);
    rt.his = rt.cur = Tag();
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    rt.l = l; rt.r = r; rt.his = rt.cur = Tag();
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> rt.his = rt.cur = Tag(a[l]), <span class="keyword">void</span>();
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    build(l, mid, i&lt;&lt;<span class="number">1</span>); build(mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
  }
  <span class="comment">// add(val, -INF) cov(-INF, val) max(0, val)</span>
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T a, T x = -INF, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span>;
    <span class="keyword">if</span> (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> push_tag(i, Tag(a, x), Tag(a, x));
    push_down(i);
    update(l, r, a, x, i&lt;&lt;<span class="number">1</span>); update(l, r, a, x, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
  }
  <span class="function">T <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.l == rt.r) <span class="keyword">return</span> max(rt.cur.add, rt.cur.mx);
    push_down(i);
    <span class="keyword">int</span> mid = (rt.l+rt.r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> query_max(x, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">else</span> <span class="keyword">return</span> query_max(x, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
  }
  <span class="function">T <span class="title">query_hmax</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.l == rt.r) <span class="keyword">return</span> max(rt.his.add, rt.his.mx);
    push_down(i);
    <span class="keyword">int</span> mid = (rt.l+rt.r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> query_hmax(x, i&lt;&lt;<span class="number">1</span>);
    <span class="keyword">else</span> <span class="keyword">return</span> query_hmax(x, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
  }
<span class="meta">#<span class="meta-keyword">undef</span> rt</span>
<span class="meta">#<span class="meta-keyword">undef</span> ls</span>
<span class="meta">#<span class="meta-keyword">undef</span> rs</span>
};
</code></pre>

    </div>
</div>
<h3 id="区间最值操作与历史最值询问反向"><a href="#区间最值操作与历史最值询问反向" class="headerlink" title="区间最值操作与历史最值询问反向"></a>区间最值操作与历史最值询问反向</h3><ol>
<li>区间加</li>
<li>区间max</li>
<li>询问min</li>
<li>历史min</li>
</ol>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> {</span>
<span class="meta">#<span class="meta-keyword">define</span> rt tr[i]</span>
<span class="meta">#<span class="meta-keyword">define</span> ls tr[i&lt;&lt;1]</span>
<span class="meta">#<span class="meta-keyword">define</span> rs tr[i&lt;&lt;1|1]</span>
  <span class="keyword">typedef</span> <span class="keyword">int</span> T;
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">int</span> l, r;
    T mn, hmn, se, tag1, htag1, tag2, htag2;
  } tr[N&lt;&lt;<span class="number">2</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    rt.hmn = min(ls.hmn, rs.hmn);
    <span class="keyword">if</span> (ls.mn == rs.mn) {
      rt.mn = ls.mn;
      rt.se = min(ls.se, rs.se);
    } <span class="keyword">else</span> <span class="keyword">if</span> (ls.mn &lt; rs.mn) {
      rt.mn = ls.mn;
      rt.se = min(ls.se, rs.mn);
    } <span class="keyword">else</span> <span class="keyword">if</span> (ls.mn &gt; rs.mn) {
      rt.mn = rs.mn;
      rt.se = min(ls.mn, rs.se);
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_tag</span><span class="params">(<span class="keyword">int</span> i, T add1, T hadd1, T add2, T hadd2)</span> </span>{
    rt.hmn = min(rt.hmn, rt.mn+hadd1);
    rt.htag1 = min(rt.htag1, rt.tag1+hadd1);
    rt.mn += add1; rt.tag1 += add1;
    rt.htag2 = min(rt.htag2, rt.tag2+hadd2);
    <span class="keyword">if</span> (rt.se != INF) rt.se += add2;
    rt.tag2 += add2;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{
    T mn = min(ls.mn, rs.mn);
    push_tag(i&lt;&lt;<span class="number">1</span>  , ls.mn == mn ? rt.tag1 : rt.tag2,
        ls.mn == mn ? rt.htag1 : rt.htag2, rt.tag2, rt.htag2);
    push_tag(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, rs.mn == mn ? rt.tag1 : rt.tag2,
        rs.mn == mn ? rt.htag1 : rt.htag2, rt.tag2, rt.htag2);
    rt.tag1 = rt.htag1 = rt.tag2 = rt.htag2 = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    rt.l = l; rt.r = r;
    rt.tag1 = rt.htag1 = rt.tag2 = rt.htag2 = <span class="number">0</span>;
    <span class="keyword">if</span> (l == r) {
      rt.hmn = rt.mn = a[l];
      rt.se = INF;
      <span class="keyword">return</span>;
    }
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    build(l, mid, i&lt;&lt;<span class="number">1</span>); build(mid+<span class="number">1</span>, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update_add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T v, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span>;
    <span class="keyword">if</span> (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> push_tag(i, v, v, v, v);
    push_down(i);
    update_add(l, r, v, i&lt;&lt;<span class="number">1</span>); update_add(l, r, v, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, T v, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r || v &lt;= rt.mn) <span class="keyword">return</span>;
    <span class="keyword">if</span> (l &lt;= rt.l &amp;&amp; rt.r &lt;= r &amp;&amp; v &lt; rt.se)
      <span class="keyword">return</span> push_tag(i, v-rt.mn, v-rt.mn, <span class="number">0</span>, <span class="number">0</span>);
    push_down(i);
    update_max(l, r, v, i&lt;&lt;<span class="number">1</span>); update_max(l, r, v, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);
    push_up(i);
  }
  <span class="function">T <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span> INF;
    <span class="keyword">if</span> (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> rt.mn;
    push_down(i);
    <span class="keyword">return</span> min(query_min(l, r, i&lt;&lt;<span class="number">1</span>), query_min(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));
  }
  <span class="function">T <span class="title">query_hmin</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i = <span class="number">1</span>)</span> </span>{
    <span class="keyword">if</span> (rt.r &lt; l || rt.l &gt; r) <span class="keyword">return</span> INF;
    <span class="keyword">if</span> (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) <span class="keyword">return</span> rt.hmn;
    push_down(i);
    <span class="keyword">return</span> min(query_hmin(l, r, i&lt;&lt;<span class="number">1</span>), query_hmin(l, r, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));
  }
<span class="meta">#<span class="meta-keyword">undef</span> rt</span>
<span class="meta">#<span class="meta-keyword">undef</span> ls</span>
<span class="meta">#<span class="meta-keyword">undef</span> rs</span>
};
</code></pre>

    </div>
</div>
<h3 id="维护历史最值和"><a href="#维护历史最值和" class="headerlink" title="维护历史最值和"></a>维护历史最值和</h3><h2 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h2><p>在第一维线段树的每个结点建立第二维线段树</p>
<h2 id="K-D-Tree-KDT"><a href="#K-D-Tree-KDT" class="headerlink" title="K-D Tree | KDT"></a>K-D Tree | KDT</h2><p>Luogu P4148 简单题</p>
<ol>
<li>将格子(x,y)加上v</li>
<li>求(xl,yl)到(xr,yr)区间和</li>
</ol>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span>
  <span class="keyword">int</span> x, y, v;
} s[N];
<span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ <span class="keyword">return</span> s[a].x &lt; s[b].x; }
<span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ <span class="keyword">return</span> s[a].y &lt; s[b].y; }
<span class="class"><span class="keyword">struct</span> <span class="title">KDTree</span> {</span>
  <span class="keyword">double</span> alpha = <span class="number">0.725</span>;
  <span class="keyword">int</span> rt, cur, xl, yl, xr, yr; <span class="comment">//rt根结点</span>
  <span class="keyword">int</span> d[N], siz[N], lc[N], rc[N]; <span class="comment">//d=1竖着砍，sz子树大小</span>
  <span class="keyword">int</span> L[N], R[N], D[N], U[N]; <span class="comment">//该子树的界线</span>
  <span class="keyword">int</span> sum[N]; <span class="comment">//维护的二维区间信息（二维区间和）</span>
  <span class="keyword">int</span> g[N], gt;
  <span class="function"><span class="keyword">void</span> <span class="title">pia</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="comment">//将树还原成序列g</span>
    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;
    pia(lc[x]);
    g[++gt] = x;
    pia(rc[x]);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="comment">//更新信息</span>
    siz[x] = siz[lc[x]] + siz[rc[x]] + <span class="number">1</span>;
    sum[x] = sum[lc[x]] + sum[rc[x]] + s[x].v;
    L[x] = R[x] = s[x].x;
    D[x] = U[x] = s[x].y;
    <span class="keyword">if</span> (lc[x]) {
      L[x] = min(L[x], L[lc[x]]);
      R[x] = max(R[x], R[lc[x]]);
      D[x] = min(D[x], D[lc[x]]);
      U[x] = max(U[x], U[lc[x]]);
    }
    <span class="keyword">if</span> (rc[x]) {
      L[x] = min(L[x], L[rc[x]]);
      R[x] = max(R[x], R[rc[x]]);
      D[x] = min(D[x], D[rc[x]]);
      U[x] = max(U[x], U[rc[x]]);
    }
  }
  <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="comment">//以序列g[l..r]为模板重建树，返回根结点</span>
    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;
    <span class="keyword">double</span> ax = <span class="number">0</span>, ay = <span class="number">0</span>, sx = <span class="number">0</span>, sy = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) ax += s[g[i]].x, ay += s[g[i]].y;
    ax /= (r - l + <span class="number">1</span>);
    ay /= (r - l + <span class="number">1</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) {
      sx += (ax - s[g[i]].x) * (ax - s[g[i]].x);
      sy += (ay - s[g[i]].y) * (ay - s[g[i]].y);
    }
    <span class="keyword">if</span> (sx &gt; sy)
      nth_element(g + l, g + mid, g + r + <span class="number">1</span>, cmpx), d[g[mid]] = <span class="number">1</span>;
    <span class="keyword">else</span>
      nth_element(g + l, g + mid, g + r + <span class="number">1</span>, cmpy), d[g[mid]] = <span class="number">2</span>;
    lc[g[mid]] = build(l, mid - <span class="number">1</span>);
    rc[g[mid]] = build(mid + <span class="number">1</span>, r);
    push_up(g[mid]);
    <span class="keyword">return</span> g[mid];
  }
  <span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>{
    gt = <span class="number">0</span>;
    pia(x);
    x = build(<span class="number">1</span>, gt);
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">bad</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">return</span> alpha * siz[x] &lt;= max(siz[lc[x]], siz[rc[x]]);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> v)</span> </span>{ <span class="comment">//在(x,y)处插入元素</span>
    s[++cur] = {x, y, v};
    insert(rt, cur);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> v)</span> </span>{
    <span class="keyword">if</span> (!x) <span class="keyword">return</span> push_up(x = v);
    <span class="keyword">if</span> (d[x]) insert(s[v].x &lt;= s[x].x ? lc[x] : rc[x], v);
    <span class="keyword">else</span> insert(s[v].y &lt;= s[x].y ? lc[x] : rc[x], v);
    push_up(x);
    <span class="keyword">if</span> (bad(x)) rebuild(x);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> xl, <span class="keyword">int</span> yl, <span class="keyword">int</span> xr, <span class="keyword">int</span> yr)</span> </span>{ <span class="comment">//查询[x1,x2]×[y1,y2]的区间和</span>
    <span class="keyword">if</span> (xl &gt; xr) swap(xl, xr);
    <span class="keyword">if</span> (yl &gt; yr) swap(yl, yr);
    <span class="keyword">this</span>-&gt;xl = xl; <span class="keyword">this</span>-&gt;yl = yl; <span class="keyword">this</span>-&gt;xr = xr; <span class="keyword">this</span>-&gt;yr = yr;
    <span class="keyword">return</span> query(rt);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">if</span> (!x || xr &lt; L[x] || xl &gt; R[x] || yr &lt; D[x] || yl &gt; U[x]) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span> (xl &lt;= L[x] &amp;&amp; R[x] &lt;= xr &amp;&amp; yl &lt;= D[x] &amp;&amp; U[x] &lt;= yr) <span class="keyword">return</span> sum[x];
    <span class="keyword">int</span> res = <span class="number">0</span>;
    <span class="keyword">if</span> (xl &lt;= s[x].x &amp;&amp; s[x].x &lt;= xr &amp;&amp; yl &lt;= s[x].y &amp;&amp; s[x].y &lt;= yr)
      res += s[x].v;
    <span class="keyword">return</span> query(lc[x]) + query(rc[x]) + res;
  }
};
</code></pre>

    </div>
</div>
<h2 id="Link-Cut-Tree-LCT"><a href="#Link-Cut-Tree-LCT" class="headerlink" title="Link Cut Tree | LCT"></a>Link Cut Tree | LCT</h2><hr>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><p><a href="https://www.luogu.org/problemnew/show/P3374" target="_blank" rel="noopener">单点修改区间查询</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3368" target="_blank" rel="noopener">区间修改单点查询</a></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">BinaryIndexedTree</span> {</span>
  <span class="keyword">int</span> n;
  <span class="built_in">vector</span>&lt;T&gt; tr;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{ <span class="keyword">this</span>-&gt;n = n; tr = <span class="built_in">vector</span>&lt;T&gt;(n+<span class="number">1</span>, <span class="number">0</span>); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;v)</span> </span>{ <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += i&amp;-i) tr[i] += v; }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">const</span> T &amp;v)</span> </span>{ add(x, v); add(y+<span class="number">1</span>, -v); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{ T res = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = x ; i; i -= i&amp;-i) res += tr[i]; <span class="keyword">return</span> res; }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>{ <span class="keyword">return</span> query(y)-query(x<span class="number">-1</span>); }
};
</code></pre>

    </div>
</div>
<p><a href="http://codeforces.com/blog/entry/63064" target="_blank" rel="noopener">O(n)初始化</a><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n, <span class="keyword">const</span> TT a[])</span> </span>{
  n = _n; clear();
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    tr[i] += a[i];
    <span class="keyword">if</span> (i+(i&amp;-i) &lt;= n) tr[i+(i&amp;-i)] += tr[i];
  }
}
</code></pre>

    </div>
</div><br>区间修改区间查询<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span>{</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SIZE=<span class="number">1e6</span>+<span class="number">5</span>;
    ll bit1[SIZE],bit2[SIZE];
    <span class="keyword">int</span> limit;
    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n=SIZE<span class="number">-1</span>)</span></span>{
        limit=n;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)bit1[i]=bit2[i]=<span class="number">0</span>;
    }
    BIT(){init();}
    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll *bit,<span class="keyword">int</span> x,ll v)</span></span>{
        <span class="keyword">while</span>(x&lt;=limit)bit[x]+=v,x+=x&amp;-x;
    }
    <span class="function">ll <span class="title">query</span><span class="params">(ll *bit,<span class="keyword">int</span> x)</span></span>{
        ll res=<span class="number">0</span>;
        <span class="keyword">while</span>(x)res+=bit[x],x-=x&amp;-x;
        <span class="keyword">return</span> res;
    }
    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll v)</span></span>{
        add(bit1,l,v);
        add(bit2,l,v*l);
        add(bit1,r+<span class="number">1</span>,-v);
        add(bit2,r+<span class="number">1</span>,-v*(r+<span class="number">1</span>));
    }
    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{
        <span class="keyword">return</span> (r+<span class="number">1</span>)*query(bit1,r)-query(bit2,r)-l*query(bit1,l<span class="number">-1</span>)+query(bit2,l<span class="number">-1</span>);
    }
}bit;
</code></pre>

    </div>
</div></p>
<h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><h4 id="单点修改区间查询"><a href="#单点修改区间查询" class="headerlink" title="单点修改区间查询"></a>单点修改区间查询</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">BIT_2D</span> {</span>
  <span class="keyword">int</span> n, m;
  T a[N][N], tr[N][N];
  BIT_2D() { <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n, <span class="keyword">const</span> <span class="keyword">int</span> &amp;_m)</span> </span>{
    n = _n; m = _m;
    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);
    <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">const</span> T &amp;k)</span> </span>{
    a[x][y] += k;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += i&amp;-i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += j&amp;-j)
        tr[i][j] += k;
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>{
    <span class="keyword">return</span> a[x][y];
    <span class="comment">// return query(x, y, x, y);</span>
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> c1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c2)</span> </span>{
    <span class="keyword">if</span> (r1 &gt; r2) swap(r1, r2);
    <span class="keyword">if</span> (c1 &gt; c2) swap(c1, c2);
    <span class="keyword">return</span> _query(r2, c2)-_query(r1<span class="number">-1</span>, c2)-_query(r2, c1<span class="number">-1</span>)+_query(r1<span class="number">-1</span>, c1<span class="number">-1</span>);
  }
  T _query(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y) {
    T res = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= i&amp;-i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j; j -= j&amp;-j)
        res += tr[i][j];
    <span class="keyword">return</span> res;
  }
};
</code></pre>

    </div>
</div>
<h2 id="可持久化数组"><a href="#可持久化数组" class="headerlink" title="可持久化数组"></a>可持久化数组</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">PersistantArray</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = N*(log2(N)+<span class="number">3</span>);
  <span class="keyword">int</span> rt[N], ls[NN], rs[NN], val[NN], tot, n;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    tot = <span class="number">0</span>;
    rt[<span class="number">0</span>] = build(<span class="number">1</span>, n);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    <span class="keyword">int</span> cur = ++tot; assert(tot &lt; NN);
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> val[cur] = a[l], cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    ls[cur] = build(l, mid);
    rs[cur] = build(mid+<span class="number">1</span>, r);
    <span class="keyword">return</span> cur;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">const</span> <span class="keyword">int</span> &amp;pre, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{
    rt[cur] = update(rt[pre], x, k, <span class="number">1</span>, n);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;pre, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    <span class="keyword">int</span> cur = ++tot; assert(tot &lt; NN);
    <span class="keyword">if</span> (l == x &amp;&amp; r == x) <span class="keyword">return</span> val[cur] = k, cur;
    ls[cur] = ls[pre]; rs[cur] = rs[pre];
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) ls[cur] = update(ls[pre], x, k, l, mid);
    <span class="keyword">else</span> rs[cur] = update(rs[pre], x, k, mid+<span class="number">1</span>, r);
    <span class="keyword">return</span> cur;
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{
    <span class="keyword">return</span> query(rt[cur], x, <span class="number">1</span>, n);
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    <span class="keyword">if</span> (l == x &amp;&amp; r == x) <span class="keyword">return</span> val[cur];
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> query(ls[cur], x, l, mid);
    <span class="keyword">return</span> query(rs[cur], x, mid+<span class="number">1</span>, r);
  }
};
</code></pre>

    </div>
</div>
<h2 id="可持久化线段树-主席树"><a href="#可持久化线段树-主席树" class="headerlink" title="可持久化线段树(主席树)"></a><a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">可持久化线段树(主席树)</a></h2><p>自带离散</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">PersistantSegmentTree</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = N*(log2(N)+<span class="number">5</span>);
  <span class="keyword">int</span> rt[N], sum[NN], ls[NN], rs[NN], tot, sz;
  <span class="built_in">vector</span>&lt;T&gt; des;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> T a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="built_in">vector</span>&lt;T&gt;(a+<span class="number">1</span>, a+n+<span class="number">1</span>).swap(des);
    sort(des.begin(), des.end());
    des.erase(unique(des.begin(), des.end()), des.end());
    sz = des.size();
    tot = <span class="number">0</span>;
    rt[<span class="number">0</span>] = _build(<span class="number">1</span>, sz);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
      <span class="keyword">int</span> t = lower_bound(des.begin(), des.end(), a[i])-des.begin()+<span class="number">1</span>;
      rt[i] = _update(rt[i<span class="number">-1</span>], <span class="number">1</span>, sz, t);
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;id, <span class="keyword">const</span> T &amp;k)</span> </span>{
    <span class="keyword">int</span> t = lower_bound(des.begin(), des.end(), k)-des.begin()+<span class="number">1</span>;
    rt[id] = _update(rt[id<span class="number">-1</span>], <span class="number">1</span>, sz, t);
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span> </span>{
    <span class="keyword">return</span> des[_query(rt[l<span class="number">-1</span>], rt[r], <span class="number">1</span>, sz, k)<span class="number">-1</span>];
  }
<span class="keyword">private</span>:
  <span class="keyword">int</span> _build(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r) {
    <span class="keyword">int</span> cur = ++tot;
    sum[cur] = <span class="number">0</span>;
    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    ls[cur] = _build(l, mid);
    rs[cur] = _build(mid+<span class="number">1</span>, r);
    <span class="keyword">return</span> cur;
  }
  <span class="keyword">int</span> _update(<span class="keyword">const</span> <span class="keyword">int</span> &amp;pre, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k) {
    <span class="keyword">int</span> cur = ++tot;
    ls[cur] = ls[pre]; rs[cur] = rs[pre]; sum[cur] = sum[pre]+<span class="number">1</span>;
    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (k &lt;= mid) ls[cur] = _update(ls[pre], l, mid, k);
    <span class="keyword">else</span> rs[cur] = _update(rs[pre], mid+<span class="number">1</span>, r, k);
    <span class="keyword">return</span> cur;
  }
  <span class="keyword">int</span> _query(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k) {
    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> l;
    <span class="keyword">int</span> num = sum[ls[v]]-sum[ls[u]], mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (num &gt;= k) <span class="keyword">return</span> _query(ls[u], ls[v], l, mid, k);
    <span class="keyword">else</span> <span class="keyword">return</span> _query(rs[u], rs[v], mid+<span class="number">1</span>, r, k-num);
  }
};
</code></pre>

    </div>
</div>
<p>不带离散</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">PersistantSegmentTree</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = N*(log2(N)+<span class="number">5</span>);
  <span class="keyword">int</span> rt[N], sum[NN], ls[NN], rs[NN], tot, n;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    tot = <span class="number">0</span>;
    rt[<span class="number">0</span>] = _build(<span class="number">1</span>, n);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">const</span> <span class="keyword">int</span> &amp;pre, <span class="keyword">const</span> T &amp;k)</span> </span>{
    rt[cur] = _update(rt[pre], <span class="number">1</span>, n, k);
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span> </span>{
    <span class="keyword">return</span> _query(rt[l<span class="number">-1</span>], rt[r], <span class="number">1</span>, n, k);
  }
<span class="keyword">private</span>:
  <span class="keyword">int</span> _build(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r) {
    <span class="keyword">int</span> cur = ++tot;
    sum[cur] = <span class="number">0</span>;
    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    ls[cur] = _build(l, mid);
    rs[cur] = _build(mid+<span class="number">1</span>, r);
    <span class="keyword">return</span> cur;
  }
  <span class="keyword">int</span> _update(<span class="keyword">const</span> <span class="keyword">int</span> &amp;pre, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k) {
    <span class="keyword">int</span> cur = ++tot;
    ls[cur] = ls[pre]; rs[cur] = rs[pre]; sum[cur] = sum[pre]+<span class="number">1</span>;
    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (k &lt;= mid) ls[cur] = _update(ls[pre], l, mid, k);
    <span class="keyword">else</span> rs[cur] = _update(rs[pre], mid+<span class="number">1</span>, r, k);
    <span class="keyword">return</span> cur;
  }
  <span class="keyword">int</span> _query(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k) {
    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> l;
    <span class="keyword">int</span> num = sum[ls[v]]-sum[ls[u]], mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (num &gt;= k) <span class="keyword">return</span> _query(ls[u], ls[v], l, mid, k);
    <span class="keyword">else</span> <span class="keyword">return</span> _query(rs[u], rs[v], mid+<span class="number">1</span>, r, k-num);
  }
};
</code></pre>

    </div>
</div>
<p>动态开点?oj可以跑本地莫名re<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>
<span class="class"><span class="title">class</span> <span class="title">PersistantSegmentTree</span> {</span>
 <span class="keyword">public</span>:
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
    tot = <span class="number">0</span>;
    <span class="keyword">this</span>-&gt;n = n;
    rt = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">0</span>);
    tr = <span class="built_in">vector</span>&lt;TreeNode&gt;(<span class="number">1</span>, TreeNode{<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>});
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pre, <span class="keyword">int</span> k, T v = <span class="number">1</span>)</span> </span>{
    rt.resize(cur+<span class="number">1</span>); <span class="comment">// assert rt.size()+1 &lt;= cur</span>
    rt[cur] = update(rt[pre], <span class="number">1</span>, n, k, v);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, T v)</span> </span>{
    <span class="keyword">int</span> cur = ++tot; <span class="comment">// assert tot == tr.size()</span>
    tr.emplace_back(tr[pre]);
    tr[cur].sum += v;
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (k &lt;= mid) tr[cur].lc = update(tr[pre].lc, l, mid, k, v);
    <span class="keyword">else</span> tr[cur].rc = update(tr[pre].rc, mid+<span class="number">1</span>, r, k, v);
    <span class="keyword">return</span> cur;
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>{
    <span class="keyword">return</span> query(rt[l<span class="number">-1</span>], rt[r], <span class="number">1</span>, n, ql, qr);
  }
  <span class="comment">// [u, v] 段 [ql, qr] 区间和</span>
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>{
    <span class="keyword">if</span> (!u &amp;&amp; !v) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> tr[v].sum-tr[u].sum;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (qr &lt;= mid) <span class="keyword">return</span> query(tr[u].lc, tr[v].lc, l, mid, ql, qr);
    <span class="keyword">if</span> (ql &gt;  mid) <span class="keyword">return</span> query(tr[u].rc, tr[v].rc, mid+<span class="number">1</span>, r, ql, qr);
    <span class="keyword">return</span> query(tr[u].lc, tr[v].lc, l, mid, ql, qr)+query(tr[u].rc, tr[v].rc, mid+<span class="number">1</span>, r, ql, qr);
  }
 <span class="keyword">private</span>:
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">int</span> lc, rc;
    T sum;
  };
  <span class="keyword">int</span> tot, n;
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rt;
  <span class="built_in">vector</span>&lt;TreeNode&gt; tr;
};
</code></pre>

    </div>
</div></p>
<p><a href="https://www.dingbacode.com/contest/242/problem/1003" target="_blank" rel="noopener">dingbacode 高地</a></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">PersistantSegmentTree</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = N*(log2(N)+<span class="number">5</span>);
  <span class="keyword">int</span> rt[N], ls[NN], rs[NN], tot, n;
  T sum[NN];
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    tot = <span class="number">0</span>;
    rt[<span class="number">0</span>] = _build(<span class="number">1</span>, n);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">const</span> <span class="keyword">int</span> &amp;pre, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k, <span class="keyword">const</span> T &amp;v)</span> </span>{
    rt[cur] = _update(rt[pre], <span class="number">1</span>, n, k, v);
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;ql, <span class="keyword">const</span> <span class="keyword">int</span> &amp;qr)</span> </span>{
    <span class="keyword">return</span> _query(rt[l<span class="number">-1</span>], rt[r], <span class="number">1</span>, n, ql, qr);
  }
<span class="keyword">private</span>:
  <span class="keyword">int</span> _build(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r) {
    <span class="keyword">int</span> cur = ++tot;
    sum[cur] = <span class="number">0</span>;
    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    ls[cur] = _build(l, mid);
    rs[cur] = _build(mid+<span class="number">1</span>, r);
    <span class="keyword">return</span> cur;
  }
  <span class="keyword">int</span> _update(<span class="keyword">const</span> <span class="keyword">int</span> &amp;pre, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k, <span class="keyword">const</span> T &amp;v) {
    <span class="keyword">int</span> cur = ++tot;
    ls[cur] = ls[pre]; rs[cur] = rs[pre]; sum[cur] = sum[pre]+v;
    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (k &lt;= mid) ls[cur] = _update(ls[pre], l, mid, k, v);
    <span class="keyword">else</span> rs[cur] = _update(rs[pre], mid+<span class="number">1</span>, r, k, v);
    <span class="keyword">return</span> cur;
  }
  <span class="comment">// [u, v] 段 [ql, qr] 区间和</span>
  T _query(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;ql, <span class="keyword">const</span> <span class="keyword">int</span> &amp;qr) {
    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> sum[v]-sum[u];
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (qr &lt;= mid) <span class="keyword">return</span> _query(ls[u], ls[v], l, mid, ql, qr);
    <span class="keyword">if</span> (ql &gt;  mid) <span class="keyword">return</span> _query(rs[u], rs[v], mid+<span class="number">1</span>, r, ql, qr);
    <span class="keyword">return</span> _query(ls[u], ls[v], l, mid, ql, qr)+_query(rs[u], rs[v], mid+<span class="number">1</span>, r, ql, qr);
  }
};
</code></pre>

    </div>
</div>
<h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a><a href="http://hzwer.com/8053.html" target="_blank" rel="noopener">分块</a></h2><p><a href="https://loj.ac/problems/search?keyword=%E5%88%86%E5%9D%97" target="_blank" rel="noopener">例题</a><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">FenKuai</span> {</span>
  <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> T;
  <span class="keyword">int</span> t; <span class="comment">// 每组大小</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(N))+<span class="number">7</span>;
  T a[N], sum[NN], add[NN];
  FenKuai() {
    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);
    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);
    <span class="built_in">memset</span>(add, <span class="number">0</span>, <span class="keyword">sizeof</span> add);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
    t = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(n)+<span class="number">0.5</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sum[i/t] += a[i];
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, T k)</span> </span>{ a[x] += k; sum[x/t] += k; }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, T k)</span> </span>{
    <span class="keyword">for</span> ( ; x &lt;= y &amp;&amp; x%t; ++x) a[x] += k, sum[x/t] += k;
    <span class="keyword">for</span> ( ; x+t<span class="number">-1</span> &lt;= y; x += t) sum[x/t] += k*t, add[x/t] += k;
    <span class="keyword">for</span> ( ; x &lt;= y; ++x) a[x] += k, sum[x/t] += k;
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="keyword">return</span> a[x]+add[x/t]; }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    T res = <span class="number">0</span>;
    <span class="keyword">for</span> ( ; x &lt;= y &amp;&amp; x%t; ++x) res += a[x]+add[x/t];
    <span class="keyword">for</span> ( ; x+t<span class="number">-1</span> &lt;= y; x += t) res += sum[x/t];
    <span class="keyword">for</span> ( ; x &lt;= y; ++x) res += a[x]+add[x/t];
    <span class="keyword">return</span> res;
  }
} B;
</code></pre>

    </div>
</div><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">FenKuai</span> {</span>
  <span class="keyword">typedef</span> <span class="keyword">int</span> T;
  <span class="keyword">int</span> t; <span class="comment">// 每组大小</span>
  T a[N], b[N], add[N];
  FenKuai() {
    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);
    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);
    <span class="built_in">memset</span>(add, <span class="number">0</span>, <span class="keyword">sizeof</span> add);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = x*t; i &lt; min(x*t+t, n); ++i) b[i] = a[i];
    sort(b+x*t, b+min(x*t+t, n));
  }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
    t = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(n)+<span class="number">0.5</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i*t &lt; n; ++i) build(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, T c)</span> </span>{
    <span class="keyword">int</span> i = x;
    <span class="keyword">for</span> ( ; i &lt;= y &amp;&amp; i%t; ++i) a[i] += c;
    build(x/t);
    <span class="keyword">for</span> ( ; i+t<span class="number">-1</span> &lt;= y; i += t) add[i/t] += c;
    <span class="keyword">for</span> ( ; i &lt;= y; ++i) a[i] += c;
    build(y/t);
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">long</span> <span class="keyword">long</span> c)</span> </span>{
    T res = <span class="number">0</span>; <span class="keyword">int</span> i = x;
    <span class="keyword">for</span> ( ; i &lt;= y &amp;&amp; i%t; ++i) res += (a[i]+add[i/t] &lt; c*c);
    <span class="keyword">for</span> ( ; i+t<span class="number">-1</span> &lt;= y; i += t) res += lower_bound(b+i, b+i+t, c*c-add[i/t])-(b+i);
    <span class="keyword">for</span> ( ; i &lt;= y; ++i) res += (a[i]+add[i/t] &lt; c*c);
    <span class="keyword">return</span> res;
  }
} B;
</code></pre>

    </div>
</div><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">FenKuai</span> {</span>
  <span class="keyword">typedef</span> <span class="keyword">int</span> T;
  <span class="keyword">int</span> t, sz;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(N))+<span class="number">7</span>;
  T a[N];
  <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q[NN];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>{
    sz = _n;
    t = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(sz*<span class="number">1.5</span>)+<span class="number">0.5</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) q[i/t].push_back(a[i]);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>{
    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; tmp;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != x%t; ++i) {
      tmp.push(q[x/t].front());
      q[x/t].pop_front();
    }
    q[x/t].push_front(k);
    <span class="keyword">while</span> (tmp.size()) {
      q[x/t].push_front(tmp.top());
      tmp.pop();
    }
    ++sz;
    <span class="keyword">if</span> (sz/t == x/t) <span class="keyword">return</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = x/t, val; i &lt; sz/t; ++i) {
      val = q[i].back();
      q[i].pop_back();
      q[i+<span class="number">1</span>].push_front(val);
    }
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; tmp;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != x%t; ++i) {
      tmp.push(q[x/t].front());
      q[x/t].pop_front();
    }
    <span class="keyword">int</span> res = q[x/t].front();
    <span class="keyword">while</span> (tmp.size()) {
      q[x/t].push_front(tmp.top());
      tmp.pop();
    }
    <span class="keyword">return</span> res;
  }
} B;
</code></pre>

    </div>
</div></p>
<h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><p>$O(1)修改$ 一般取 $block = \frac{n}{\sqrt{m} }, O(n\sqrt{m})$</p>
<p>移动前两步先扩大区间 $l–,r++$ 后两步缩小区间 $l++,r–$</p>
<h3 id="奇偶性排序"><a href="#奇偶性排序" class="headerlink" title="奇偶性排序"></a>奇偶性排序</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> T &amp;q1, <span class="keyword">const</span> T &amp;q2)</span> </span>{
  <span class="keyword">return</span> q1.l/block != q2.l/block ? q1.l &lt; q2.l :
      (q1.l/block)&amp;<span class="number">1</span> ? q1.r &lt; q2.r : q1.r &gt; q2.r;
}
</code></pre>

    </div>
</div>
<h3 id="带修改莫队"><a href="#带修改莫队" class="headerlink" title="带修改莫队"></a>带修改莫队</h3><p>以 $n^{\frac{2}{3} }$ 为一块，分成了 $n^{\frac{1}{3} }$ 块，第一关键字是左端点所在块，第二关键字是右端点所在块，第三关键字是时间. 复杂度 $O(n^{\frac{5}{3} })$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> T &amp;q1, <span class="keyword">const</span> T &amp;q2)</span> </span>{
  <span class="keyword">return</span> q1.l/block != q2.l/block ? q1.l &lt; q2.l :
      q1.r/block != q2.r/block ? q1.r &lt; q2.r : q1.t &lt; q2.t;
}
</code></pre>

    </div>
</div>
<h3 id="值域分块"><a href="#值域分块" class="headerlink" title="值域分块"></a>值域分块</h3><p>维护块的前缀和以及块内部前缀和, $O(\sqrt{n})$ 修改, $O(1)$ 求区间和</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">PreSum</span> {</span>
  <span class="keyword">int</span> n, block;
  T s[N], t[(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(N)+<span class="number">3</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    block = <span class="built_in">sqrt</span>(n);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, T k)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i/block == x/block &amp;&amp; i &lt;= n; ++i) s[i] += k;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = x/block+<span class="number">1</span>; i &lt;= n/block; ++i) t[i] += k;
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">return</span> t[x/block]+s[x];
  }
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">SufSum</span> {</span>
  <span class="keyword">int</span> n, block;
  T s[N], t[(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(N)+<span class="number">3</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    block = <span class="built_in">sqrt</span>(n);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, T k)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i/block == x/block &amp;&amp; i &gt;= <span class="number">1</span>; --i) s[i] += k;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = x/block<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) t[i] += k;
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">return</span> t[x/block]+s[x];
  }
};
</code></pre>

    </div>
</div>
<h3 id="二次离线莫队"><a href="#二次离线莫队" class="headerlink" title="二次离线莫队"></a>二次离线莫队</h3><p>大概是一种需要维护信息具有可减性的莫队。只要具可减性，就可以容斥，就可以二次离线。所谓『二次离线』，大概是指由于普通莫队无法快速计算贡献，所以第一次离线把询问离线下来，第二次离线把莫队的转移过程离线下来。</p>
<p>由于信息具有可减性(比如常见的「点对数」)，记 $(a,b)(c,d)$ 表示区间 $[a,b]$ 内的点和区间 $[c,d]$ 内的点对彼此产生的贡献(区间内部不算)。</p>
<p>$[l,r]\to[l+t,r],\sum\limits_{i=l}^{l+t−1}(i,i)(i+1,r)=\sum\limits_{i=l}^{l+t−1}(i,i)(1,r)−(i,i)(1,i)$</p>
<p>$[l,r]\to[l-t,r],\sum\limits_{i=l-t}^{l-1}(i,i)(i+1,r)=\sum\limits_{i=l-t}^{l-1}(i,i)(1,r)−(i,i)(1,i)$</p>
<p>$[l,r]\to[l,r+t],\sum\limits_{i=r+1}^{r+t}(i,i)(l,i-1)=\sum\limits_{i=r+1}^{r+t}(1,i-1)(i,i)-(1,l-1)(i,i)$</p>
<p>$[l,r]\to[l,r-t],\sum\limits_{i=r-t+1}^{r}(i,i)(l,i-1)=\sum\limits_{i=r-t+1}^{r}(1,i-1)(i,i)-(1,l-1)(i,i)$</p>
<p>对于 $(1,i-1)(i,i)$ 没什么好说,暴力处理前缀和</p>
<p>对于 $(1,l-1)(i,i)$ 由于莫队的复杂度,至多有 $n\sqrt{m}$ 个不同询问,把每个询问 打标记到左端点(比如 $[l,r]\to [l,r-t]$ 就打到 $l-1$ 上), 最后扫一遍全部 $i \in [1,n]$ ,处理出询问值, 因为此时 $i$ 枚举 $O(n)$ 次,可以用『值域分块』技巧。这样最终复杂度 $O(n\sqrt n+n\sqrt{n})$</p>
<p><a href="https://www.luogu.com.cn/problem/P5047" target="_blank" rel="noopener">求区间逆序对</a></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> {</span>
  <span class="keyword">int</span> id, l, r;
  Query() {}
  Query(<span class="keyword">int</span> i, <span class="keyword">int</span> _l, <span class="keyword">int</span> _r) : id(i), l(_l), r(_r) {}
};

<span class="keyword">int</span> n, m, block;
<span class="keyword">int</span> a[N];
<span class="keyword">long</span> <span class="keyword">long</span> res[N], sumil[N], sumir[N], ans[N];
Query q[N];
SufSum&lt;<span class="keyword">int</span>&gt; suml;
PreSum&lt;<span class="keyword">int</span>&gt; sumr;
<span class="built_in">vector</span>&lt;Query&gt; ql[N], qr[N];

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc_sumi</span><span class="params">()</span> </span>{
  <span class="keyword">static</span> BinaryIndexedTree&lt;<span class="keyword">int</span>&gt; tree;
  tree.init(n);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    sumil[i] = sumil[i<span class="number">-1</span>]+i<span class="number">-1</span>-tree.query(a[i]);
    tree.add(a[i], <span class="number">1</span>);
  }
  tree.clear();
  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) {
    sumir[i] = sumir[i+<span class="number">1</span>]+tree.query(a[i]<span class="number">-1</span>);
    tree.add(a[i], <span class="number">1</span>);
  }
}

<span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>{
  read(n); read(m);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);
  discrete();
  block = n/<span class="built_in">sqrt</span>(m);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) {
    q[i].id = i;
    read(q[i].l);
    read(q[i].r);
  }
  sort(q+<span class="number">1</span>, q+m+<span class="number">1</span>, cmp);
  calc_sumi();
  q[<span class="number">0</span>] = Query(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ul, vl, ur, vr; i &lt;= m; ++i) {
    ul = q[i<span class="number">-1</span>].l; ur = q[i<span class="number">-1</span>].r;
    vl = q[i].l; vr = q[i].r;
    res[i] = sumil[vr]-sumil[ur]+sumir[vl]-sumir[ul];
    <span class="keyword">if</span> (vl &lt; ul) qr[vr+<span class="number">1</span>].emplace_back(-i, vl, ul<span class="number">-1</span>);
    <span class="keyword">if</span> (vl &gt; ul) qr[vr+<span class="number">1</span>].emplace_back(+i, ul, vl<span class="number">-1</span>);
    <span class="keyword">if</span> (vr &lt; ur) ql[ul<span class="number">-1</span>].emplace_back(+i, vr+<span class="number">1</span>, ur);
    <span class="keyword">if</span> (vr &gt; ur) ql[ul<span class="number">-1</span>].emplace_back(-i, ur+<span class="number">1</span>, vr);
  }
  suml.init(n+<span class="number">1</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    suml.add(a[i], <span class="number">1</span>);
    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;qq : ql[i]) {
      <span class="keyword">for</span> (<span class="keyword">int</span> j = qq.l; j &lt;= qq.r; ++j) {
        <span class="keyword">if</span> (qq.id &gt; <span class="number">0</span>) res[qq.id] += suml.query(a[j]+<span class="number">1</span>);
        <span class="keyword">else</span> res[-qq.id] -= suml.query(a[j]+<span class="number">1</span>);
      }
    }
  }
  sumr.init(n);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) {
    sumr.add(a[i], <span class="number">1</span>);
    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;qq : qr[i]) {
      <span class="keyword">for</span> (<span class="keyword">int</span> j = qq.l; j &lt;= qq.r; ++j) {
        <span class="keyword">if</span> (qq.id &gt; <span class="number">0</span>) res[qq.id] += sumr.query(a[j]<span class="number">-1</span>);
        <span class="keyword">else</span> res[-qq.id] -= sumr.query(a[j]<span class="number">-1</span>);
      }
    }
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) {
    res[i] += res[i<span class="number">-1</span>];
    ans[q[i].id] = res[i];
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) write(ans[i]), <span class="built_in">putchar</span>(<span class="string">'\n'</span>);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>

    </div>
</div>
<h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><h3 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a><a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">一维</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="built_in">std</span>::greater&lt;T&gt;&gt;
struct ST {
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">31</span>-__builtin_clz(N)+<span class="number">3</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> T INF = <span class="number">1e9</span>;
  <span class="keyword">int</span> lg2[N];
  U cmp = U();
  T rmq[N][NN];
  ST() {
    fill(rmq[<span class="number">0</span>], rmq[<span class="number">0</span>]+N*NN, cmp(-INF, +INF) ? INF : -INF);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) lg2[i] = lg2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;
  }
  T&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> &amp;i) { <span class="keyword">return</span> rmq[i][<span class="number">0</span>]; }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> T &amp;val = <span class="number">0</span>)</span> </span>{ fill(rmq[<span class="number">0</span>], rmq[<span class="number">0</span>]+N*NN, val); }
  <span class="function">T <span class="title">mv</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>{ <span class="keyword">return</span> cmp(x, y) ? x : y; }
  <span class="comment">// rmq[i][j] ==&gt; [i, i+2^j-1]</span>
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(T a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) {
      rmq[i][<span class="number">0</span>] = a[i];
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lg2[n-i+<span class="number">1</span>]; ++j)
        rmq[i][j] =  mv(rmq[i][j<span class="number">-1</span>], rmq[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);
    }
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> query(r, l);
    <span class="keyword">int</span> k = lg2[r-l+<span class="number">1</span>];
    <span class="keyword">return</span> mv(rmq[l][k], rmq[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);
  }
};
  <span class="comment">/* rmq[i][j] ==&gt; [i-2^j+1, i]</span>
<span class="comment">  void build(T a[], const int &amp;n) {</span>
<span class="comment">    for (int i = 1; i &lt;= n; ++i) {</span>
<span class="comment">      rmq[i][0] = a[i];</span>
<span class="comment">      for (int j = 1; j &lt;= lg2[i]; ++j)</span>
<span class="comment">        rmq[i][j] =  mv(rmq[i][j-1], rmq[i-(1&lt;&lt;(j-1))][j-1]);</span>
<span class="comment">    }</span>
<span class="comment">  }</span>
<span class="comment">  T query(const int &amp;l, const int &amp;r) {</span>
<span class="comment">    if (l &gt; r) return query(r, l);</span>
<span class="comment">    int k = lg2[r-l+1];</span>
<span class="comment">    return mv(rmq[r][k], rmq[l+(1&lt;&lt;k)-1][k]);</span>
<span class="comment">  }</span>
<span class="comment">  */</span>
</code></pre>

    </div>
</div>
<h3 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h3><p>$O(nm\log n \log m)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="built_in">std</span>::greater&lt;T&gt;&gt;
struct ST {
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = (<span class="keyword">int</span>)log2(N)+<span class="number">3</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> T INF = <span class="number">1e9</span>;
  U cmp = U();
  T rmq[N][N][NN][NN]; <span class="comment">// rmq[i][j][k][l] [i, j] [i+2^k-1, j+2^l-1]</span>
  ST() { init(); }
  ST(<span class="keyword">const</span> T &amp;val) { init(val); }
  T&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> &amp;i) { <span class="keyword">return</span> rmq[i][<span class="number">0</span>]; }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{ fill(rmq[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>], rmq[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]+N*N*NN*NN, cmp(-INF, +INF) ? INF : -INF); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span> </span>{ fill(rmq[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>], rmq[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]+N*N*NN*NN, val); }
  <span class="function">T <span class="title">mv</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>{ <span class="keyword">return</span> cmp(x, y) ? x : y; }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(T a[N][N], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> <span class="keyword">int</span> &amp;m)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= log_2[n]; ++k)
    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= log_2[m]; ++l)
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span> &lt;= n; ++i)
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j+(<span class="number">1</span>&lt;&lt;l)<span class="number">-1</span> &lt;= m; ++j) {
      T &amp;cur = rmq[i][j][k][l];
      <span class="keyword">if</span> (!k &amp;&amp; !l) cur = a[i][j];
      <span class="keyword">else</span> <span class="keyword">if</span> (!l) cur = mv(rmq[i][j][k<span class="number">-1</span>][l], rmq[i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][j][k<span class="number">-1</span>][l]);
      <span class="keyword">else</span> cur = mv(rmq[i][j][k][l<span class="number">-1</span>], rmq[i][j+(<span class="number">1</span>&lt;&lt;(l<span class="number">-1</span>))][k][l<span class="number">-1</span>]);
    }
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;r1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;c1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r2, <span class="keyword">const</span> <span class="keyword">int</span> &amp;c2)</span> </span>{
    <span class="keyword">int</span> k = log_2[r2-r1+<span class="number">1</span>], l = log_2[c2-c1+<span class="number">1</span>];
    <span class="keyword">return</span> mv(mv(rmq[r1][c1][k][l], rmq[r2-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][c2-(<span class="number">1</span>&lt;&lt;l)+<span class="number">1</span>][k][l]),
          mv(rmq[r2-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][c1][k][l], rmq[r1][c2-(<span class="number">1</span>&lt;&lt;l)+<span class="number">1</span>][k][l]));
  }
};
</code></pre>

    </div>
</div>
<h3 id="反向ST"><a href="#反向ST" class="headerlink" title="反向ST"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6356" target="_blank" rel="noopener">反向ST</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="built_in">std</span>::greater&lt;T&gt;&gt;
struct rST {
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = (<span class="keyword">int</span>)log2(N)+<span class="number">3</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> T INF = <span class="number">1e9</span>;
  <span class="keyword">int</span> n;
  <span class="keyword">int</span> lg2[N];
  U cmp = U();
  T rmq[N][NN]; <span class="comment">// rmq[i][j] ==&gt; [i, i+2^j-1]</span>
  rST() { <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) lg2[i] = lg2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>; }
  T&amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> &amp;i) { <span class="keyword">return</span> rmq[i][<span class="number">0</span>]; }
  <span class="function">T <span class="title">mv</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>{ <span class="keyword">return</span> cmp(x, y) ? x : y; }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n, <span class="keyword">const</span> T &amp;val = <span class="number">0</span>)</span> </span>{ 
    n = _n;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fill(rmq[i], rmq[i]+NN, val);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;k)</span> </span>{
    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="keyword">void</span>(update(r, l, k));
    <span class="keyword">int</span> b = lg2[r-l+<span class="number">1</span>];
    rmq[l][b] = mv(rmq[l][b], k);
    rmq[r-(<span class="number">1</span>&lt;&lt;b)+<span class="number">1</span>][b] = mv(rmq[r-(<span class="number">1</span>&lt;&lt;b)+<span class="number">1</span>][b], k);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg2[n]; i &gt;= <span class="number">0</span>; --i) {
      <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; ++l) {
        r = l+(<span class="number">1</span>&lt;&lt;i);
        <span class="keyword">if</span> (r &lt;= n) rmq[r][i] = mv(rmq[r][i], rmq[l][i+<span class="number">1</span>]);
        rmq[l][i] = mv(rmq[l][i], rmq[l][i+<span class="number">1</span>]);
      }
    }
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> query(r, l);
    <span class="keyword">int</span> b = lg2[r-l+<span class="number">1</span>];
    <span class="keyword">return</span> mv(rmq[l][b], rmq[r-(<span class="number">1</span>&lt;&lt;b)+<span class="number">1</span>][b]);
  }
};
</code></pre>

    </div>
</div>
<hr>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> {</span>
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{ fa = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>); iota(fa.begin(), fa.end(), <span class="number">0</span>); }
  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{ <span class="keyword">return</span> s == fa[s] ? s : fa[s] = get(fa[s]); }
  <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> i) { <span class="keyword">return</span> fa[get(i)]; }
  <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ <span class="comment">// merge x to y</span>
    x = get(x); y = get(y);
    <span class="keyword">return</span> x == y ? <span class="literal">false</span> : (fa[x] = y, <span class="literal">true</span>);
  }
};
</code></pre>

    </div>
</div>
<h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>秩的意思就是树的高度，按秩合并过后并查集的结构为树形结构，最坏情况为 $O(m \log n)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> {</span>
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa, rk;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{ fa = rk = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>); iota(fa.begin(), fa.end(), <span class="number">0</span>); }
  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{ <span class="keyword">return</span> s == fa[s] ? s : get(fa[s]); }
  <span class="keyword">int</span> <span class="keyword">operator</span> [](<span class="keyword">int</span> i) { <span class="keyword">return</span> get(i); }
  <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    x = get(x); y = get(y);
    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span> (rk[x] &lt; rk[y]) fa[x] = y;
    <span class="keyword">else</span> fa[y] = x, rk[x] += rk[x] == rk[y];
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
};
</code></pre>

    </div>
</div>
<h3 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h3><h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt; struct DSU {
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;
  <span class="built_in">vector</span>&lt;T&gt; w;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, T v = <span class="number">1</span>)</span> </span>{
    fa = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>);
    iota(fa.begin(), fa.end(), <span class="number">0</span>);
    w = <span class="built_in">vector</span>&lt;T&gt;(n+<span class="number">1</span>, v);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, T a[])</span> </span>{
    fa = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>);
    iota(fa.begin(), fa.end(), <span class="number">0</span>);
    w = <span class="built_in">vector</span>&lt;T&gt;(a, a+n+<span class="number">1</span>);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{ <span class="keyword">return</span> s == fa[s] ? s : fa[s] = get(fa[s]); }
  <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> i) { <span class="keyword">return</span> fa[get(i)]; }
  <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ <span class="comment">// merge x to y</span>
    x = get(x); y = get(y);
    <span class="keyword">return</span> x == y ? <span class="literal">false</span> : (w[y] += w[x], fa[x] = y, <span class="literal">true</span>);
  }
};
</code></pre>

    </div>
</div>
<h3 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h3><p>例题:关押罪犯,食物链</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> {</span>
  <span class="keyword">int</span> n;
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa; <span class="comment">// [1, n] partner, [n+1, 2n] enemy</span>
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    fa = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>*n+<span class="number">1</span>, <span class="number">0</span>);
    iota(fa.begin(), fa.end(), <span class="number">0</span>);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{ <span class="keyword">return</span> s == fa[s] ? s : fa[s] = get(fa[s]); }
  <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> i) { <span class="keyword">return</span> fa[get(i)]; }
  <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ fa[get(x)] = get(y); }
  <span class="function"><span class="keyword">bool</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    <span class="keyword">if</span> (get(x) == get(y)) <span class="keyword">return</span> <span class="literal">false</span>;
    merge(x+n, y);
    merge(x, y+n);
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
};
</code></pre>

    </div>
</div>
<h3 id="可撤销并查集"><a href="#可撤销并查集" class="headerlink" title="可撤销并查集"></a>可撤销并查集</h3><p>用一个栈维护每次操作</p>
<h4 id="按秩合并-1"><a href="#按秩合并-1" class="headerlink" title="按秩合并"></a>按秩合并</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> {</span>
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa, rk;
  <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&gt;&gt; stk;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
    stk = <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&gt;&gt;();
    fa = rk = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>);
    iota(fa.begin(), fa.end(), <span class="number">0</span>);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{ <span class="keyword">while</span> (s != fa[s]) s = fa[s]; <span class="keyword">return</span> s; }
  <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> i) { <span class="keyword">return</span> fa[get(i)]; }
  <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ <span class="comment">// return the number push in stack</span>
    x = get(x); y = get(y);
    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span> (rk[x] &gt; rk[y]) swap(x, y);
    stk.push({fa[x], fa[x]});
    fa[x] = y;
    <span class="keyword">return</span> rk[x] == rk[y] ? stk.push({rk[y], rk[y]++}), <span class="number">2</span> : <span class="number">1</span>;
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">undo</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (stk.empty()) <span class="keyword">return</span> <span class="literal">false</span>;
    stk.top().first = stk.top().second;
    stk.pop();
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
};
</code></pre>

    </div>
</div>
<h4 id="启发式合并-1"><a href="#启发式合并-1" class="headerlink" title="启发式合并"></a>启发式合并</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> {</span>
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa, sz;
  <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; stk;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
    stk = <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;();
    fa = sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">1</span>);
    iota(fa.begin(), fa.end(), <span class="number">0</span>);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{ <span class="keyword">while</span> (s != fa[s]) s = fa[s]; <span class="keyword">return</span> s; }
  <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> i) { <span class="keyword">return</span> fa[get(i)]; }
  <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    x = get(x); y = get(y);
    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span> (sz[x] &gt; sz[y]) swap(x, y);
    stk.push({x, y});
    fa[x] = y;
    sz[y] += sz[x];
    <span class="keyword">return</span> <span class="number">1</span>;
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">undo</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (stk.empty()) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">int</span> x = stk.top().first, y = stk.top().y;
    stk.pop();
    fa[x] = x;
    sz[y] -= sz[x];
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
}
</code></pre>

    </div>
</div>
<h4 id="可撤销扩展域并查集"><a href="#可撤销扩展域并查集" class="headerlink" title="可撤销扩展域并查集"></a>可撤销扩展域并查集</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> {</span>
  <span class="keyword">int</span> n;
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa, rk; <span class="comment">// [1, n] partner, [n+1, 2n] enemy</span>
  <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&gt;&gt; stk;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    stk = <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&gt;&gt;();
    fa = rk = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>*n+<span class="number">1</span>, <span class="number">0</span>);
    iota(fa.begin(), fa.end(), <span class="number">0</span>);
  }
  <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> i) { <span class="keyword">return</span> fa[get(i)]; }
  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{ <span class="keyword">while</span> (s != fa[s]) s = fa[s]; <span class="keyword">return</span> s; }
  <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>{ stk.top().first = stk.top().second; stk.pop(); }
  <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    x = get(x); y = get(y);
    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;
    <span class="keyword">if</span> (rk[x] &gt; rk[y]) swap(x, y);
    stk.push({fa[x], fa[x]});
    stk.push({rk[y], rk[y]});
    fa[x] = y;
    rk[y] += rk[x] == rk[y];
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    <span class="keyword">if</span> (get(x) == get(y)) <span class="keyword">return</span> <span class="literal">false</span>;
    merge(x+n, y);
    merge(x, y+n);
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
};
</code></pre>

    </div>
</div>
<h3 id="可持久化并查集"><a href="#可持久化并查集" class="headerlink" title="可持久化并查集"></a>可持久化并查集</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">PersistantUnionSet</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = N*(log2(N)+<span class="number">3</span>);
  <span class="keyword">int</span> rt[N], ls[NN], rs[NN], fa[NN], dep[NN], n, tot;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    tot = <span class="number">0</span>;
    rt[<span class="number">0</span>] = build(<span class="number">1</span>, n);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    <span class="keyword">int</span> cur = ++tot; assert(tot &lt; NN);
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> fa[cur] = l, dep[cur] = <span class="number">0</span>, cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    ls[cur] = build(l, mid);
    rs[cur] = build(mid+<span class="number">1</span>, r);
    <span class="keyword">return</span> cur;
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>{
    <span class="keyword">return</span> fa[getf(rt[cur], x)] == fa[getf(rt[cur], y)];
  }
  <span class="comment">// return the id of fa[], dep[]</span>
  <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> cur;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> query(ls[cur], x, l, mid);
    <span class="keyword">else</span> <span class="keyword">return</span> query(rs[cur], x, mid+<span class="number">1</span>, r);
  }
  <span class="comment">// return the id of fa[], dep[]</span>
  <span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">int</span> fi;
    <span class="keyword">while</span> (fa[(fi = query(cur, x, <span class="number">1</span>, n))] != x) x = fa[fi];
    <span class="keyword">return</span> fi;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">const</span> <span class="keyword">int</span> &amp;pre, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>{
    rt[cur] = rt[pre];
    <span class="keyword">int</span> fx = getf(rt[cur], x), fy = getf(rt[cur], y);
    <span class="keyword">if</span> (fa[fx] == fa[fy]) <span class="keyword">return</span>;
    <span class="keyword">if</span> (dep[fx] &gt; dep[fy]) swap(fx, fy);
    rt[cur] = update(rt[pre], fa[fx], fa[fy], <span class="number">1</span>, n);
    <span class="keyword">if</span> (dep[fx] == dep[fy]) add(rt[cur], fa[fy], <span class="number">1</span>, n);
  }
  <span class="comment">// update fa, merge x to y</span>
  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;pre, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    <span class="keyword">int</span> cur = ++tot; assert(tot &lt; NN);
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> fa[cur] = y, dep[cur] = dep[pre], cur;
    ls[cur] = ls[pre]; rs[cur] = rs[pre];
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) ls[cur] = update(ls[pre], x, y, l, mid);
    <span class="keyword">else</span> rs[cur] = update(rs[pre], x, y, mid+<span class="number">1</span>, r);
    <span class="keyword">return</span> cur;
  }
  <span class="comment">// add dep</span>
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;cur, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ++dep[cur], <span class="keyword">void</span>();
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (x &lt;= mid) add(ls[cur], x, l, mid);
    <span class="keyword">else</span> add(rs[cur], x, mid+<span class="number">1</span>, r);
  }
};
</code></pre>

    </div>
</div>
<hr>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">MonotonousQueue</span> {</span>
  <span class="keyword">unsigned</span> head;
  <span class="built_in">vector</span>&lt;T&gt; q;
  MonotonousQueue() { clear(); }
  T&amp; <span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;i) { <span class="keyword">return</span> q[head+i];}
  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{ head = <span class="number">0</span>; q.clear(); }
  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>{ <span class="keyword">return</span> q.size()-head; }
  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{ <span class="keyword">return</span> head == q.size(); }
  <span class="function">T <span class="title">front</span><span class="params">()</span> </span>{ <span class="keyword">return</span> q[head]; }
  <span class="function">T <span class="title">back</span><span class="params">()</span> </span>{ <span class="keyword">return</span> q.back(); }
  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> </span>{<span class="comment">/*unsupported*/</span>}
  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> </span>{ q.push_back(x); }
  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>{ ++head; }
  <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>{ q.pop_back(); }
};
</code></pre>

    </div>
</div>
<h2 id="左偏树-可并堆"><a href="#左偏树-可并堆" class="headerlink" title="左偏树|可并堆"></a><a href="https://www.luogu.com.cn/problem/P3377" target="_blank" rel="noopener">左偏树|可并堆</a></h2><p>1 x y：将第 x 个数和第 y 个数所在的小根堆合并（若第 x 或第 y 个数已经被删除或第 x 和第 y 个数在用一个堆内，则无视此操作）。</p>
<p>2 x：输出第 x 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 x 个数已经被删除，则输出 -1 并无视删除操作）。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> {</span> <span class="comment">// 左偏树|可并堆</span>
<span class="meta">#<span class="meta-keyword">define</span> ls tr[x].son[0]</span>
<span class="meta">#<span class="meta-keyword">define</span> rs tr[x].son[1]</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    T val;
    <span class="keyword">int</span> dis, rt, son[<span class="number">2</span>];
  };
  <span class="built_in">vector</span>&lt;TreeNode&gt; tr;
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(TT a[], <span class="keyword">int</span> n)</span> </span>{
    tr.resize(n+<span class="number">1</span>);
    tr[<span class="number">0</span>].dis = <span class="number">-1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
      tr[i].val = a[i];
      tr[i].rt = i;
    }
  }
  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">return</span> tr[x].rt == x ? x : tr[x].rt = get(tr[x].rt);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    <span class="keyword">if</span> (tr[x].val == <span class="number">-1</span> || tr[y].val == <span class="number">-1</span>) <span class="keyword">return</span>;
    x = get(x); y = get(y);
    <span class="keyword">if</span> (x != y) tr[x].rt = tr[y].rt = _merge(x, y);
  }
  <span class="keyword">int</span> _merge(<span class="keyword">int</span> x, <span class="keyword">int</span> y) {
    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x+y;
    <span class="keyword">if</span> (tr[x].val &gt; tr[y].val || (tr[x].val == tr[y].val &amp;&amp; x &gt; y)) swap(x, y);
    rs = _merge(rs, y);
    <span class="keyword">if</span>(tr[ls].dis &lt; tr[rs].dis) swap(ls, rs);
    tr[ls].rt = tr[rs].rt = tr[x].rt = x;
    tr[x].dis = tr[rs].dis+<span class="number">1</span>;
    <span class="keyword">return</span> x;
  }
  <span class="function">T <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">if</span> (tr[x].val == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;
    x = get(x);
    T res = tr[x].val;
    tr[x].val = <span class="number">-1</span>;
    tr[ls].rt = ls;
    tr[rs].rt = rs;
    tr[x].rt = _merge(ls, rs);
    <span class="keyword">return</span> res;
  }
<span class="meta">#<span class="meta-keyword">undef</span> ls</span>
<span class="meta">#<span class="meta-keyword">undef</span> rs</span>
};
</code></pre>

    </div>
</div>
<hr>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="回文字符串-manacher算法"><a href="#回文字符串-manacher算法" class="headerlink" title="回文字符串|manacher算法"></a><a href="https://www.luogu.org/problemnew/show/P3805" target="_blank" rel="noopener">回文字符串|manacher算法</a></h2><p>从 0 开始，第 i 位对应 p[i*2+2]<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">char</span> *buf, <span class="keyword">int</span> *p)</span> </span>{
  <span class="keyword">int</span> str_len = <span class="built_in">strlen</span>(str), buf_len = <span class="number">2</span>;
  buf[<span class="number">0</span>] = buf[<span class="number">1</span>] = <span class="string">'#'</span>;
  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; ++i)
    buf[buf_len++] = str[i], buf[buf_len++] = <span class="string">'#'</span>;

  <span class="keyword">int</span> mx = <span class="number">0</span>, id, ans = <span class="number">0</span>;
  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; buf_len; ++i) {
    <span class="keyword">if</span>(i &lt;= mx) p[i] = min(p[id*<span class="number">2</span>-i], mx-i);
    <span class="keyword">else</span> p[i] = <span class="number">1</span>;
    <span class="keyword">while</span>(buf[i-p[i]] == buf[i+p[i]]) p[i]++;
    <span class="keyword">if</span>(i+p[i] &gt; mx) mx = i+p[i], id = i;
    ans = max(ans, p[i]<span class="number">-1</span>);
  }
  <span class="keyword">return</span> ans;
}
</code></pre>

    </div>
</div></p>
<h3 id="判断s-l-r-是否为回文"><a href="#判断s-l-r-是否为回文" class="headerlink" title="判断s[l, r]是否为回文"></a>判断s[l, r]是否为回文</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp">p[l+r+<span class="number">2</span>]<span class="number">-1</span> &gt;= r-l+<span class="number">1</span>
</code></pre>

    </div>
</div>
<hr>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a><a href="https://www.luogu.org/problemnew/show/P3375" target="_blank" rel="noopener">KMP</a></h2><p><code>.c_str() 未知异常 Segment Fault</code><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> nex[])</span> </span>{ get_next(s.c_str(), nex); }
<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> nex[])</span> </span>{
  nex[<span class="number">0</span>] = nex[<span class="number">1</span>] = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>, l = <span class="built_in">strlen</span>(s); i &lt; l; ++i) {
    <span class="keyword">while</span> (j &amp;&amp; s[i] != s[j]) j = nex[j];
    nex[i+<span class="number">1</span>] = s[i] == s[j] ? ++j : <span class="number">0</span>;
  }
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">int</span> nex[])</span> </span>{ kmp(s1.c_str(), s2.c_str(), nex); }
<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, <span class="keyword">int</span> nex[])</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, l1 = <span class="built_in">strlen</span>(s1), l2 = <span class="built_in">strlen</span>(s2); i &lt; l1; ++i){
    <span class="keyword">while</span> (j &amp;&amp; s1[i] != s2[j]) j = nex[j];
    <span class="keyword">if</span> (s1[i] == s2[j]) ++j;
    <span class="keyword">if</span> (j == l2) {
      <span class="built_in">cout</span> &lt;&lt; i-l2+<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;
      j = nex[j];
    }
  }
}
</code></pre>

    </div>
</div><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> nex[])</span> </span>{
  nex[<span class="number">0</span>] = nex[<span class="number">1</span>] = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)s.size(); ++i) {
    <span class="keyword">while</span> (j &amp;&amp; s[i] != s[j]) j = nex[j];
    nex[i+<span class="number">1</span>] = s[i] == s[j] ? ++j : <span class="number">0</span>;
  }
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">int</span> nex[])</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)s1.size(); ++i) {
    <span class="keyword">while</span> (j &amp;&amp; s1[i] != s2[j]) j = nex[j];
    <span class="keyword">if</span> (s1[i] == s2[j]) ++j;
    <span class="keyword">if</span> (j == (<span class="keyword">int</span>)s2.size()) {
      <span class="built_in">cout</span> &lt;&lt; i-s2.size()+<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;
      j = nex[j];
    }
  }
}
</code></pre>

    </div>
</div></p>
<p>nex 数组往上跳为公差为 i-nex[i] 的等差数列直到 i/2</p>
<h2 id="扩展KMP-Z函数"><a href="#扩展KMP-Z函数" class="headerlink" title="扩展KMP|Z函数"></a>扩展KMP|Z函数</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">z_function</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{
  <span class="keyword">int</span> n = (<span class="keyword">int</span>)s.length();
  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">z</span><span class="params">(n)</span></span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; ++i) {
    <span class="keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="number">1</span>) {
      z[i] = z[i - l];
    } <span class="keyword">else</span> {
      z[i] = max(<span class="number">0</span>, r - i + <span class="number">1</span>);
      <span class="keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];
    }
    <span class="keyword">if</span> (i + z[i] - <span class="number">1</span> &gt; r) l = i, r = i + z[i] - <span class="number">1</span>;
  }
  <span class="keyword">return</span> z;
}
</code></pre>

    </div>
</div>
<h2 id="最长公共前后缀"><a href="#最长公共前后缀" class="headerlink" title="最长公共前后缀"></a>最长公共前后缀</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2594" target="_blank" rel="noopener">hdu2594</a></p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="built_in">string</span> <span class="title">max_pre_suf</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span> </span>{
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> M1 = <span class="number">805306457</span>, M2 = <span class="number">1000173169</span>, P = <span class="number">31</span>;
  <span class="keyword">static</span> pii pre[N], suf[N], pwp[N];
  <span class="keyword">int</span> l1 = s1.size(), l2 = s2.size();
  pre[<span class="number">0</span>] = {<span class="number">0</span>, <span class="number">0</span>};
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; ++i) {
    pre[i] = {<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((<span class="number">1l</span>l*pre[i<span class="number">-1</span>].first*P+s1[i<span class="number">-1</span>]-<span class="string">'a'</span>)%M1),
          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((<span class="number">1l</span>l*pre[i<span class="number">-1</span>].second*P+s1[i<span class="number">-1</span>]-<span class="string">'a'</span>)%M2)};
  }
  pwp[<span class="number">0</span>] = {<span class="number">1</span>, <span class="number">1</span>};
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l2; ++i) {
    pwp[i] = {<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1l</span>l*pwp[i<span class="number">-1</span>].first*P%M1),
          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1l</span>l*pwp[i<span class="number">-1</span>].second*P%M2)};
  }
  suf[l2+<span class="number">1</span>] = {<span class="number">0</span>, <span class="number">0</span>}; 
  <span class="keyword">for</span> (<span class="keyword">int</span> i = l2; i; --i) {
    suf[i] = {<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((<span class="number">1l</span>l*(s2[i<span class="number">-1</span>]-<span class="string">'a'</span>)*pwp[l2-i].first+suf[i+<span class="number">1</span>].first)%M1),
          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((<span class="number">1l</span>l*(s2[i<span class="number">-1</span>]-<span class="string">'a'</span>)*pwp[l2-i].second+suf[i+<span class="number">1</span>].second)%M2)};
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> i = min(l1, l2); i; --i)
    <span class="keyword">if</span> (pre[i] == suf[l2-i+<span class="number">1</span>]) <span class="keyword">return</span> s1.substr(<span class="number">0</span>, i);
  <span class="keyword">return</span> <span class="string">""</span>;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><h2 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h2><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a><a href="https://www.luogu.org/problemnew/show/P3370" target="_blank" rel="noopener">字符串哈希</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">StringHash</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> M1 = <span class="number">1e9</span>+<span class="number">7</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> M2 = <span class="number">998244353</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> P1 = <span class="number">31</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> P2 = <span class="number">29</span>;
  <span class="keyword">int</span> ha1[N], ha2[N], pw1[N], pw2[N];
  StringHash() {
    pw1[<span class="number">0</span>] = pw2[<span class="number">0</span>] = <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) {
      pw1[i] = <span class="number">1l</span>l*pw1[i<span class="number">-1</span>]*P1%M1;
      pw2[i] = <span class="number">1l</span>l*pw2[i<span class="number">-1</span>]*P2%M2;
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> len)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) {
      ha1[i+<span class="number">1</span>] = (<span class="number">1l</span>l*ha1[i]*P1+s[i]-<span class="string">'a'</span>+<span class="number">1</span>)%M1;
      ha2[i+<span class="number">1</span>] = (<span class="number">1l</span>l*ha2[i]*P2+s[i]-<span class="string">'a'</span>+<span class="number">1</span>)%M2;
    }
  }
  pair&lt;int, int&gt; get(int l, int r) {
    <span class="keyword">return</span> {(ha1[r]<span class="number">-1l</span>l*ha1[l<span class="number">-1</span>]*pw1[r-l+<span class="number">1</span>]%M1+M1)%M1,
            (ha2[r]<span class="number">-1l</span>l*ha2[l<span class="number">-1</span>]*pw2[r-l+<span class="number">1</span>]%M2+M2)%M2};
  }
};
</code></pre>

    </div>
</div>
<hr>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">TireTree</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">5e5</span>+<span class="number">7</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">26</span>;
  <span class="keyword">char</span> beg;
  <span class="keyword">int</span> nex[NN][SZ], num[NN], cnt;
  <span class="keyword">bool</span> exist[NN];
  TireTree(<span class="keyword">char</span> _beg = <span class="string">'a'</span>) : beg(_beg) { clear(); }
  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{
    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span>(nex[<span class="number">0</span>])*(cnt+<span class="number">1</span>));
    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(cnt+<span class="number">1</span>));
    <span class="built_in">memset</span>(exist, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(cnt+<span class="number">1</span>));
    cnt = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, c; i &lt; len; ++i) {
      c = s[i]-beg;
      <span class="keyword">if</span> (!nex[p][c]) nex[p][c] = ++cnt;
      p = nex[p][c];
      ++num[p];
    }
    exist[p] = <span class="literal">true</span>;
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, c; i &lt; len; ++i) {
      c = s[i]-beg;
      <span class="keyword">if</span> (!nex[p][c]) <span class="keyword">return</span> <span class="literal">false</span>;
      p = nex[p][c];
    }
    <span class="keyword">return</span> exist[p];
  }
  <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, c; i &lt; len; ++i) {
      c = s[i]-beg;
      <span class="keyword">if</span> (!nex[p][c]) <span class="keyword">return</span> <span class="number">0</span>;
      p = nex[p][c];
    }
    <span class="keyword">return</span> num[p];
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{ insert(s.c_str()); }
  <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{ <span class="keyword">return</span> find(s.c_str()); }
  <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{ <span class="keyword">return</span> count(s.c_str()); }
};
</code></pre>

    </div>
</div>
<h3 id="求异或"><a href="#求异或" class="headerlink" title="求异或"></a>求异或</h3><p>最大异或<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">TireTree</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">2</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">30</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = N*B;
  <span class="keyword">int</span> nex[NN][SZ], cnt;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{ clear(); }
  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{
    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(cnt+<span class="number">1</span>)*SZ);
    cnt = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = B, c, p = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) {
      c = (x&gt;&gt;i)&amp;<span class="number">1</span>;
      <span class="keyword">if</span> (!nex[p][c]) nex[p][c] = ++cnt;
      p = nex[p][c];
    }
  }
  <span class="function"><span class="keyword">int</span> <span class="title">max_xor</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>{
    <span class="keyword">int</span> ans = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = B, c, p = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) {
      c = (x&gt;&gt;i)&amp;<span class="number">1</span>;
      <span class="keyword">if</span> (!nex[p][c^<span class="number">1</span>]) p = nex[p][c];
      <span class="keyword">else</span> p = nex[p][c^<span class="number">1</span>], ans |= <span class="number">1</span>&lt;&lt;i;
    }
    <span class="keyword">return</span> ans;
  }
};
</code></pre>

    </div>
</div><br>动态开点+支持合并<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">TireTree</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">2</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">30</span>;
  <span class="keyword">typedef</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, SZ&gt; T;
  <span class="built_in">vector</span>&lt;T&gt; nex;
  TireTree() { init(); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{ nex.assign(<span class="number">1</span>, T()); <span class="comment">/* nex.reserve(N); */</span> }
  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{ nex = <span class="built_in">vector</span>&lt;T&gt;(); }
  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> nex.size(); }
  <span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>{
    <span class="keyword">if</span> (x != <span class="number">0</span>) <span class="keyword">return</span>;
    x = nex.size();
    nex.emplace_back(T());
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = B, c, p = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) {
      c = (x&gt;&gt;i)&amp;<span class="number">1</span>;
      extend(nex[p][c]);
      p = nex[p][c];
    }
  }
  <span class="function"><span class="keyword">int</span> <span class="title">max_xor</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>{
    <span class="keyword">int</span> ans = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = B, c, p = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) {
      c = (x&gt;&gt;i)&amp;<span class="number">1</span>;
      <span class="keyword">if</span> (!nex[p][c^<span class="number">1</span>]) p = nex[p][c];
      <span class="keyword">else</span> p = nex[p][c^<span class="number">1</span>], ans |= <span class="number">1</span>&lt;&lt;i;
    }
    <span class="keyword">return</span> ans;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> TireTree &amp;t, <span class="keyword">int</span> p = <span class="number">0</span>, <span class="keyword">int</span> pt = <span class="number">0</span>)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; SZ; ++c) {
      <span class="keyword">if</span> (t.nex[pt][c] == <span class="number">0</span>) <span class="keyword">continue</span>;
      extend(nex[p][c]);
      dfs(t, nex[p][c], t.nex[pt][c]);
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(TireTree &amp;t)</span> </span>{
    <span class="keyword">if</span> (t.size() &lt; size()) swap(*<span class="keyword">this</span>, t);
    dfs(t);
    t.clear();
  }
};
</code></pre>

    </div>
</div></p>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>AC 自动机是 以 Trie 的结构为基础，结合 KMP 的思想 建立的。</p>
<p>将所有模式串构成一棵 Trie, 再对所有结点构造失配指针</p>
<p><a href="https://www.luogu.com.cn/problem/P3808" target="_blank" rel="noopener">Luogu P3808</a><br>如需构造可重建AC自动机,每次构造建一个nex数组的拷贝<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Aho_Corasick_Automaton</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">5e6</span>+<span class="number">7</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">26</span>;
  <span class="keyword">char</span> beg;
  <span class="keyword">int</span> nex[NN][SZ], num[NN], fail[NN], cnt;
  Aho_Corasick_Automaton(<span class="keyword">const</span> <span class="keyword">char</span> &amp;_beg = <span class="string">'a'</span>) : beg(_beg) {}
  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{
    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span>(nex[<span class="number">0</span>])*(cnt+<span class="number">1</span>));
    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(cnt+<span class="number">1</span>));
    <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(cnt+<span class="number">1</span>));
    cnt = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, c; i &lt; len; ++i) {
      c = s[i]-beg;
      <span class="keyword">if</span> (!nex[p][c]) nex[p][c] = ++cnt;
      p = nex[p][c];
    }
    ++num[p];
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>{
    <span class="keyword">static</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SZ; ++i) <span class="keyword">if</span> (nex[<span class="number">0</span>][i]) q.push(nex[<span class="number">0</span>][i]);
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> u = q.front();
      q.pop();
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SZ; ++i) {
        <span class="keyword">if</span> (nex[u][i]) {
          fail[nex[u][i]] = nex[fail[u]][i];
          q.push(nex[u][i]);
        } <span class="keyword">else</span> {
          nex[u][i] = nex[fail[u]][i];
        }
      }
    }
  }
  <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">0</span>, res = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) {
      p = nex[p][s[i]-beg];
      <span class="keyword">for</span> (<span class="keyword">int</span> t = p; t &amp;&amp; ~num[t]; t = fail[t]) {
        res += num[t];
        num[t] = <span class="number">-1</span>;
      }
    }
    <span class="keyword">return</span> res;
  }
};
</code></pre>

    </div>
</div></p>
<p><a href="https://www.luogu.com.cn/problem/P5357" target="_blank" rel="noopener">Luogu P5357</a><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Aho_Corasick_Automaton</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">2e5</span>+<span class="number">7</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">26</span>;
  <span class="keyword">char</span> beg;
  <span class="keyword">int</span> cnt;
  <span class="keyword">int</span> nex[NN][SZ], fail[NN], vis[NN];
  Aho_Corasick_Automaton(<span class="keyword">const</span> <span class="keyword">char</span> &amp;_beg = <span class="string">'a'</span>) : beg(_beg) {}
  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{
    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span>(nex[<span class="number">0</span>])*(cnt+<span class="number">1</span>));
    <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(cnt+<span class="number">1</span>));
    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(cnt+<span class="number">1</span>));
    cnt = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), p = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, c; i &lt; len; ++i) {
      c = s[i]-beg;
      <span class="keyword">if</span> (!nex[p][c]) nex[p][c] = ++cnt;
      p = nex[p][c];
    }
    <span class="keyword">return</span> p;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>{
    <span class="keyword">static</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SZ; ++i) <span class="keyword">if</span> (nex[<span class="number">0</span>][i]) q.push(nex[<span class="number">0</span>][i]);
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> u = q.front();
      q.pop();
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SZ; ++i) {
        <span class="keyword">if</span> (nex[u][i]) {
          fail[nex[u][i]] = nex[fail[u]][i];
          q.push(nex[u][i]);
        } <span class="keyword">else</span> {
          nex[u][i] = nex[fail[u]][i];
        }
      }
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>{
    <span class="keyword">static</span> <span class="keyword">int</span> deg[NN];
    <span class="keyword">static</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; len; ++i) {
      p = nex[p][s[i]-beg];
      ++vis[p];
      <span class="comment">// for (int t = p; t; t = fail[t]) ++vis[t];</span>
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) ++deg[fail[i]];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) <span class="keyword">if</span> (!deg[i]) q.push(i);
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> u = q.front();
      q.pop();
      vis[fail[u]] += vis[u];
      <span class="keyword">if</span> (--deg[fail[u]] == <span class="number">0</span>) q.push(fail[u]);
    }
  }
} ac;
</code></pre>

    </div>
</div></p>
<h2 id="后缀数组-SA"><a href="#后缀数组-SA" class="headerlink" title="后缀数组|SA"></a><a href="https://loj.ac/problem/111" target="_blank" rel="noopener">后缀数组|SA</a></h2><p>$sa[i]$ 表示将所有后缀排序后第 $i$ 小的后缀的编号</p>
<p>$rk[i]$ 表示后缀 $i$ 的排名</p>
<p>性质:$sa[rk[i]]=rk[sa[i]]=i$</p>
<p>$lcp(i, j)$ 表示后缀 $i$ 和后缀 $j$ 的最长公共前缀(的长度)</p>
<p>$height[i]=lcp(sa[i], sa[i-1])$</p>
<p>引理 $height[rk[i]] \geq height[rk[i-1]]-1$</p>
<p>$lcp(sa[i],sa[j])=\min{height[i+1\cdots j]}$</p>
<p>不同子串数目:$\frac{n(n+1)}{2}-\sum\limits_{i=2}^{n}{height[i]}$</p>
<h3 id="O-nlog-2n"><a href="#O-nlog-2n" class="headerlink" title="$O(nlog^2n)$"></a>$O(nlog^2n)$</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">int</span> sa[N], rk[N&lt;&lt;<span class="number">1</span>], height[N];
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// s start from 1</span>
<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SA</span><span class="params">(<span class="keyword">const</span> T *s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
  <span class="keyword">static</span> <span class="keyword">int</span> oldrk[N&lt;&lt;<span class="number">1</span>];
  <span class="built_in">memset</span>(rk+n+<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) rk[i] = s[i];
  <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= n; w &lt;&lt;= <span class="number">1</span>) {
    iota(sa+<span class="number">1</span>, sa+n+<span class="number">1</span>, <span class="number">1</span>);
    sort(sa+<span class="number">1</span>, sa+n+<span class="number">1</span>, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y) {
      <span class="keyword">return</span> rk[x] == rk[y] ? rk[x+w] &lt; rk[y+w] : rk[x] &lt; rk[y];
    });
    <span class="built_in">memcpy</span>(oldrk+<span class="number">1</span>, rk+<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>*n);
    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i) {
      <span class="keyword">if</span> (oldrk[sa[i]] == oldrk[sa[i<span class="number">-1</span>]] &amp;&amp;
        oldrk[sa[i]+w] == oldrk[sa[i<span class="number">-1</span>]+w]) {
        rk[sa[i]] = p;
      } <span class="keyword">else</span> {
        rk[sa[i]] = ++p;
      }
    }
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; ++i) {
    <span class="keyword">if</span> (k) --k;
    <span class="keyword">while</span> (s[i+k] == s[sa[rk[i]<span class="number">-1</span>]+k]) ++k;
    height[rk[i]] = k;
  }
}
</code></pre>

    </div>
</div>
<h3 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="$O(nlogn)$"></a>$O(nlogn)$</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">int</span> sa[N], rk[N&lt;&lt;<span class="number">1</span>], height[N];
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// s start from 1</span>
<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SA</span><span class="params">(<span class="keyword">const</span> T *s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
<span class="meta">#<span class="meta-keyword">define</span> cmp(x, y, w) oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w]</span>
  <span class="keyword">static</span> <span class="keyword">int</span> oldrk[N&lt;&lt;<span class="number">1</span>], id[N], px[N], cnt[N], m;
  <span class="comment">// memset(oldrk+n+1, 0, sizeof(int)*n); // multi testcase</span>
  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (m = <span class="number">128</span>));
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rk[i] = s[i]];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) sa[cnt[rk[i]]--] = i;
  <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>, p, i; w &lt;= n; w &lt;&lt;= <span class="number">1</span>, m = p) {
    <span class="keyword">for</span> (p = <span class="number">0</span>, i = n; i &gt; n - w; --i) id[++p] = i;
    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (sa[i] &gt; w) id[++p] = sa[i] - w;
    <span class="built_in">memset</span>(cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * m);
    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[px[i] = rk[id[i]]];
    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];
    <span class="keyword">for</span> (i = n; i; --i) sa[cnt[px[i]]--] = id[i];
    swap(oldrk, rk); <span class="comment">// memcpy(oldrk+1, rk+1, sizeof(int)*n);</span>
    <span class="keyword">for</span> (p = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i) rk[sa[i]] = cmp(sa[i], sa[i - <span class="number">1</span>], w) ? p : ++p;
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt;= n; ++i) {
    <span class="keyword">if</span> (k) --k;
    <span class="keyword">while</span> (s[i+k] == s[sa[rk[i]<span class="number">-1</span>]+k]) ++k;
    height[rk[i]] = k;
  }
<span class="meta">#<span class="meta-keyword">undef</span> cmp</span>
}
</code></pre>

    </div>
</div>
<h3 id="O-n"><a href="#O-n" class="headerlink" title="$O(n)$"></a><a href="https://loj.ac/submission/653573" target="_blank" rel="noopener">$O(n)$</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> SuffixArray {

<span class="keyword">int</span> sa[N], rk[N], ht[N];
<span class="keyword">bool</span> t[N &lt;&lt; <span class="number">1</span>];

<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">islms</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">bool</span> *t)</span> </span>{ <span class="keyword">return</span> i &gt; <span class="number">0</span> &amp;&amp; t[i] &amp;&amp; !t[i - <span class="number">1</span>]; }

<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>
<span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sort</span>(<span class="title">T</span> <span class="title">s</span>, <span class="title">int</span> *<span class="title">sa</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">len</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">sz</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">sigma</span>, <span class="title">bool</span> *<span class="title">t</span>, <span class="title">int</span> *<span class="title">b</span>, <span class="title">int</span> *<span class="title">cb</span>, <span class="title">int</span> *<span class="title">p</span>) {</span>
  <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * sigma);
  <span class="built_in">memset</span>(sa, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * len);
  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) b[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s[i])]++;
  cb[<span class="number">0</span>] = b[<span class="number">0</span>];
  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sigma; i++) cb[i] = cb[i - <span class="number">1</span>] + b[i];
  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) sa[--cb[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s[p[i]])]] = p[i];
  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sigma; i++) cb[i] = cb[i - <span class="number">1</span>] + b[i - <span class="number">1</span>];
  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)
    <span class="keyword">if</span> (sa[i] &gt; <span class="number">0</span> &amp;&amp; !t[sa[i] - <span class="number">1</span>])
      sa[cb[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s[sa[i] - <span class="number">1</span>])]++] = sa[i] - <span class="number">1</span>;
  cb[<span class="number">0</span>] = b[<span class="number">0</span>];
  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sigma; i++) cb[i] = cb[i - <span class="number">1</span>] + b[i];
  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)
    <span class="keyword">if</span> (sa[i] &gt; <span class="number">0</span> &amp;&amp; t[sa[i] - <span class="number">1</span>])
      sa[--cb[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s[sa[i] - <span class="number">1</span>])]] = sa[i] - <span class="number">1</span>;
}

<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>
<span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">sais</span>(<span class="title">T</span> <span class="title">s</span>, <span class="title">int</span> *<span class="title">sa</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">len</span>, <span class="title">bool</span> *<span class="title">t</span>, <span class="title">int</span> *<span class="title">b</span>, <span class="title">int</span> *<span class="title">b1</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">sigma</span>) {</span>
  <span class="keyword">register</span> <span class="keyword">int</span> i, j, x, p = <span class="number">-1</span>, cnt = <span class="number">0</span>, sz = <span class="number">0</span>, *cb = b + sigma;
  <span class="keyword">for</span> (t[len - <span class="number">1</span>] = <span class="number">1</span>, i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) t[i] = s[i] &lt; s[i + <span class="number">1</span>] || (s[i] == s[i + <span class="number">1</span>] &amp;&amp; t[i + <span class="number">1</span>]);
  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)
    <span class="keyword">if</span> (t[i] &amp;&amp; !t[i - <span class="number">1</span>])
      b1[sz++] = i;
  sort(s, sa, len, sz, sigma, t, b, cb, b1);
  <span class="keyword">for</span> (i = sz = <span class="number">0</span>; i &lt; len; i++)
    <span class="keyword">if</span> (islms(sa[i], t))
      sa[sz++] = sa[i];
  <span class="keyword">for</span> (i = sz; i &lt; len; i++) sa[i] = <span class="number">-1</span>;
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++) {
    <span class="keyword">for</span> (x = sa[i], j = <span class="number">0</span>; j &lt; len; j++) {
      <span class="keyword">if</span> (p == <span class="number">-1</span> || s[x + j] != s[p + j] || t[x + j] != t[p + j]) {
        cnt++, p = x;
        <span class="keyword">break</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; (islms(x + j, t) || islms(p + j, t))) {
        <span class="keyword">break</span>;
      }
    }
    sa[sz + (x &gt;&gt;= <span class="number">1</span>)] = cnt - <span class="number">1</span>;
  }
  <span class="keyword">for</span> (i = j = len - <span class="number">1</span>; i &gt;= sz; i--)
    <span class="keyword">if</span> (sa[i] &gt;= <span class="number">0</span>)
      sa[j--] = sa[i];
  <span class="keyword">register</span> <span class="keyword">int</span> *s1 = sa + len - sz, *b2 = b1 + sz;
  <span class="keyword">if</span> (cnt &lt; sz)
    sais(s1, sa, sz, t + len, b, b1 + sz, cnt);
  <span class="keyword">else</span>
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++) sa[s1[i]] = i;
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++) b2[i] = b1[sa[i]];
  sort(s, sa, len, sz, sigma, t, b, cb, b2);
}

<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>
<span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">getHeight</span>(<span class="title">T</span> <span class="title">s</span>, <span class="title">int</span> <span class="title">n</span>) {</span>
  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rk[sa[i]] = i;
  <span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>, k = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ht[rk[i++]] = k)
    <span class="keyword">for</span> (k ? k-- : <span class="number">0</span>, j = sa[rk[i] - <span class="number">1</span>]; s[i + k] == s[j + k]; k++)
      ;
}

<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  // <span class="title">s</span> <span class="title">start</span> <span class="title">from</span> 0</span>
<span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">init</span>(<span class="title">T</span> <span class="title">s</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">len</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">sigma</span> = 128) {</span>
  sais(s, sa, len + <span class="number">1</span>, t, rk, ht, sigma);
  getHeight(s, len);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) ++sa[i];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i; --i) rk[i] = rk[i<span class="number">-1</span>];
}

}  <span class="comment">// namespace SuffixArray</span>
</code></pre>

    </div>
</div>
<h3 id="树上SA"><a href="#树上SA" class="headerlink" title="树上SA"></a><a href="https://www.luogu.com.cn/problem/P5353" target="_blank" rel="noopener">树上SA</a></h3><p>树上可能出现完全相同的字符串,增加上一轮的有序状态rk为”第三关键字”</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">SAonTree</span> {</span>
  <span class="keyword">int</span> n, d[N], cnt[N], sa[N], rk[N&lt;&lt;<span class="number">1</span>], _rk[N&lt;&lt;<span class="number">1</span>], _oldrk[N&lt;&lt;<span class="number">1</span>], tp[N&lt;&lt;<span class="number">1</span>];
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">tsort</span><span class="params">(<span class="keyword">int</span> *sa, T *rk, <span class="keyword">int</span> *tp, <span class="keyword">int</span> m)</span> </span>{
    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(m+<span class="number">1</span>));
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rk[i]];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i<span class="number">-1</span>];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) sa[cnt[rk[tp[i]]]--] = tp[i];
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">const</span> T *a, <span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    <span class="keyword">int</span> p = <span class="number">128</span>, i; <span class="comment">// p = n</span>
    iota(tp+<span class="number">1</span>, tp+n+<span class="number">1</span>, <span class="number">1</span>);
    tsort(sa, a, tp, p);
    <span class="keyword">for</span> (i = <span class="number">1</span>, p = <span class="number">0</span>; i &lt;= n; ++i) {
      _rk[sa[i]] = a[sa[i<span class="number">-1</span>]] == a[sa[i]] ? p : ++p;
      rk[sa[i]] = i;
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>, t = <span class="number">0</span>; w &lt; n; w &lt;&lt;= <span class="number">1</span>, ++t) {
      <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) _oldrk[i] = rk[f[i]];
      tsort(tp, _oldrk, sa, n);
      tsort(sa, _rk, tp, p);
      swap(_rk, tp);
      <span class="keyword">for</span> (i = <span class="number">1</span>, p = <span class="number">0</span>; i &lt;= n; ++i) {
        _rk[sa[i]] = tp[sa[i<span class="number">-1</span>]] == tp[sa[i]]
            &amp;&amp; tp[f[sa[i<span class="number">-1</span>]]] == tp[f[sa[i]]] ? p : ++p;
        rk[sa[i]] = i;
      }
      <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) f[i] = f[f[i]]; <span class="comment">// attention special tree</span>
    }
  }
};
</code></pre>

    </div>
</div>
<h2 id="后缀平衡树"><a href="#后缀平衡树" class="headerlink" title="后缀平衡树"></a>后缀平衡树</h2><h2 id="后缀自动机-SAM"><a href="#后缀自动机-SAM" class="headerlink" title="后缀自动机|SAM"></a>后缀自动机|SAM</h2><p>一个状态表示一个 $endpos$ 的等价类</p>
<p>$len(v)$ 为该状态最长的字符串长度</p>
<p>后缀链接 $link(v)$ 连接到对应于该状态最长字符串的最长后缀的另一个 $endpos$ 等价类的状态。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>空间换时间<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span> {</span> <span class="comment">// root 0</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> A = <span class="number">26</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> C = <span class="string">'a'</span>;
  <span class="keyword">int</span> sz, last, len[M], link[M], nex[M][A];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*A*sz);
    link[<span class="number">0</span>] = <span class="number">-1</span>; sz = <span class="number">1</span>; last = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> c)</span> </span>{
    <span class="keyword">int</span> cur = sz++, p = last;
    len[cur] = len[last]+<span class="number">1</span>;
    <span class="keyword">for</span> (; ~p &amp;&amp; !nex[p][c]; p = link[p]) nex[p][c] = cur;
    <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="keyword">return</span> link[cur] = <span class="number">0</span>, cur;
    <span class="keyword">int</span> q = nex[p][c];
    <span class="keyword">if</span> (len[p]+<span class="number">1</span> == len[q]) <span class="keyword">return</span> link[cur] = q, cur;
    <span class="keyword">int</span> clone = sz++;
    <span class="built_in">memcpy</span>(nex[clone], nex[q], <span class="keyword">sizeof</span> nex[q]);
    link[clone] = link[q];
    len[clone] = len[p]+<span class="number">1</span>;
    <span class="keyword">for</span> (; ~p &amp;&amp; nex[p][c] == q; p = link[p]) nex[p][c] = clone;
    link[q] = link[cur] = clone;
    <span class="keyword">return</span> cur;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{
    init(); <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) last = extend(ch-C);
  }
};
</code></pre>

    </div>
</div><br>时间换空间<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">SAM</span> {</span> <span class="comment">// root 0</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> {</span>
    <span class="keyword">int</span> len, link;
    <span class="built_in">map</span>&lt;T, <span class="keyword">int</span>&gt; nex;
  } st[N&lt;&lt;<span class="number">1</span>];
  <span class="keyword">int</span> sz, last;
  SAM() { init(); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
    st[<span class="number">0</span>].len = <span class="number">0</span>;
    st[<span class="number">0</span>].link = <span class="number">-1</span>;
    sz = <span class="number">1</span>;
    last = <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">extend</span><span class="params">(T c)</span> </span>{
    <span class="keyword">int</span> cur = sz++;
    st[cur].len = st[last].len+<span class="number">1</span>;
    <span class="keyword">int</span> p = last;
    <span class="keyword">while</span> (~p &amp;&amp; !st[p].nex.count(c)) {
      st[p].nex[c] = cur;
      p = st[p].link;
    }
    <span class="keyword">if</span> (p == <span class="number">-1</span>) {
      st[cur].link = <span class="number">0</span>;
    } <span class="keyword">else</span> {
      <span class="keyword">int</span> q = st[p].nex[c];
      <span class="keyword">if</span> (st[p].len+<span class="number">1</span> == st[q].len) {
        st[cur].link = q;
      } <span class="keyword">else</span> {
        <span class="keyword">int</span> clone = sz++;
        st[clone].len = st[p].len+<span class="number">1</span>;
        st[clone].nex = st[q].nex;
        st[clone].link = st[q].link;
        <span class="keyword">while</span> (~p &amp;&amp; st[p].nex[c] == q) {
          st[p].nex[c] = clone;
          p = st[p].link;
        }
        st[q].link = st[cur].link = clone;
      }
    }
    last = cur;
  }
};
</code></pre>

    </div>
</div></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>{ <span class="comment">// topo on parent tree</span>
  <span class="keyword">static</span> <span class="keyword">int</span> t[M], rk[M];
  <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*sz);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) ++t[len[i]];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; ++i) t[i] += t[i<span class="number">-1</span>];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) rk[--t[len[i]]] = i;
  <span class="keyword">for</span> (<span class="keyword">int</span> _ = sz<span class="number">-1</span>, i, j; _; --_) { <span class="comment">// assert(rk[0] == 0);</span>
    i = rk[_];
    j = link[i];
    cnt[j] += cnt[i];
  }
}
</code></pre>

    </div>
</div>
<h3 id="检查字符串是否出现"><a href="#检查字符串是否出现" class="headerlink" title="检查字符串是否出现"></a>检查字符串是否出现</h3><p>丢进去转移。这个算法还找到了模式串在文本串中出现的最大前缀长度。</p>
<h3 id="不同子串个数"><a href="#不同子串个数" class="headerlink" title="不同子串个数"></a>不同子串个数</h3><p>不同子串的个数等于自动机中以 $t_0$ 为起点的不同路径的条数-1(空串)。令 $d_{v}$ 为从状态 $v$ 开始的路径数量（包括长度为零的路径）</p>
<p>$d_{v}=1+\sum\limits_{w:(v,w,c)\in DAWG}d_{w}$</p>
<p>另一种方法是利用上述后缀自动机的树形结构。统计节点对应的子串数量 $\operatorname{len}(i)-\operatorname{len}(\operatorname{link}(i))$</p>
<p>ps:若新增一个字符,其增量为$len(cur)-len(link(cur))$ 不包括 $clone$ 结点</p>
<h3 id="所有不同子串的总长度"><a href="#所有不同子串的总长度" class="headerlink" title="所有不同子串的总长度"></a>所有不同子串的总长度</h3><p>$ans_{v}=\sum\limits_{w:(v,w,c)\in DAWG}d_{w}+ans_{w}$</p>
<p>法二:每个节点对应的所有后缀长度是 $\frac{\operatorname{len}(i)\times (\operatorname{len}(i)+1)}{2}$，减去其 $\operatorname{link}$ 节点的对应值就是该节点的净贡献</p>
<h3 id="字典序第-k-大子串"><a href="#字典序第-k-大子串" class="headerlink" title="字典序第 k 大子串"></a>字典序第 k 大子串</h3><p>不同位置的相同子串算作一个,每个非 clone 状态的数量记为1</p>
<p>不同位置的相同子串算作多个,每个状态的数量为 parent 树上求子树和</p>
<p>在 SAM 的 DAG 求和然后字典序搞搞</p>
<h3 id="两个字符串的最长公共子串"><a href="#两个字符串的最长公共子串" class="headerlink" title="两个字符串的最长公共子串"></a>两个字符串的最长公共子串</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{
  <span class="keyword">int</span> u = <span class="number">0</span>, l = <span class="number">0</span>, res = <span class="number">0</span>, c;
  <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) {
    c = ch-C;
    <span class="keyword">while</span> (u &amp;&amp; !nex[u][c]) l = len[u = link[u]];
    <span class="keyword">if</span> (nex[u][c]) u = nex[u][c], ++l;
    res = max(res, l);
  }
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div>
<h3 id="多个字符串间的最长公共子串"><a href="#多个字符串间的最长公共子串" class="headerlink" title="多个字符串间的最长公共子串"></a>多个字符串间的最长公共子串</h3><p>记录 $f[i][j]$ 为第 $i$ 个字符串在 sam 上状态 $j$ 的匹配长度</p>
<p>$ans = \max\limits_{j}{(\min\limits_{i}{f[i][j]})}$</p>
<h3 id="后缀的最长公共前缀-height"><a href="#后缀的最长公共前缀-height" class="headerlink" title="后缀的最长公共前缀|height"></a>后缀的最长公共前缀|height</h3><p>求两个后缀的最长公共前缀，显然就是两个后缀的节点在Parent树上的LCA</p>
<h2 id="广义后缀自动机"><a href="#广义后缀自动机" class="headerlink" title="广义后缀自动机"></a>广义后缀自动机</h2><p>广义后缀自动机 (General Suffix Automaton) 是将后缀自动机整合到字典树中来解决对于多个字符串的子串问题</p>
<h3 id="离线构造"><a href="#离线构造" class="headerlink" title="离线构造"></a>离线构造</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">generalSAM</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> A = <span class="number">26</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> C = <span class="string">'a'</span>;
  <span class="keyword">int</span> sz, len[M], link[M], nex[M][A];
  generalSAM() { init(); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
    <span class="comment">// memset(nex, 0, sizeof(int)*A*sz);</span>
    link[<span class="number">0</span>] = <span class="number">-1</span>; sz = <span class="number">1</span>;
  }
  <span class="function"><span class="keyword">int</span> <span class="title">insertSAM</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> c)</span> </span>{
    <span class="keyword">int</span> cur = nex[last][c];
    <span class="keyword">if</span> (len[cur]) <span class="keyword">return</span> cur;
    len[cur] = len[last]+<span class="number">1</span>;
    <span class="keyword">int</span> p = link[last];
    <span class="keyword">for</span> (; ~p &amp;&amp; !nex[p][c]; p = link[p]) nex[p][c] = cur;
    <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="keyword">return</span> link[cur] = <span class="number">0</span>, cur;
    <span class="keyword">int</span> q = nex[p][c];
    <span class="keyword">if</span> (len[p]+<span class="number">1</span> == len[q]) <span class="keyword">return</span> link[cur] = q, cur;
    <span class="keyword">int</span> clone = sz++;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; ++i)
      nex[clone][i] = len[nex[q][i]] ? nex[q][i] : <span class="number">0</span>;
    len[clone] = len[p]+<span class="number">1</span>;
    <span class="keyword">for</span> (; ~p &amp;&amp; nex[p][c] == q; p = link[p]) nex[p][c] = clone;
    link[clone] = link[q];
    link[q] = link[cur] = clone;
    <span class="keyword">return</span> cur;
  }
  <span class="function"><span class="keyword">int</span> <span class="title">insertTrie</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> c)</span> </span>{
    <span class="keyword">return</span> nex[cur][c] ? nex[cur][c] : nex[cur][c] = sz++;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{
    <span class="keyword">int</span> last = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) last = insertTrie(last, ch-C);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, last = <span class="number">0</span>; i &lt; n; ++i) last = insertTrie(last, s[i]-C);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>{
    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; ++i)
      <span class="keyword">if</span> (nex[<span class="number">0</span>][i]) q.push({<span class="number">0</span>, i});
    <span class="keyword">while</span> (!q.empty()) {
      <span class="keyword">auto</span> item = q.front(); q.pop();
      <span class="keyword">int</span> last = insertSAM(item.first, item.second);
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; ++i)
        <span class="keyword">if</span> (nex[last][i]) q.push({last, i});
    }
  }
};
</code></pre>

    </div>
</div>
<h3 id="在线构造"><a href="#在线构造" class="headerlink" title="在线构造"></a>在线构造</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">generalSAM</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> A = <span class="number">26</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> M = N&lt;&lt;<span class="number">1</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> C = <span class="string">'a'</span>;
  <span class="keyword">int</span> sz, len[M], link[M], nex[M][A];
  generalSAM() { init(); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*A*sz);
    link[<span class="number">0</span>] = <span class="number">-1</span>; sz = <span class="number">1</span>;
  }
  <span class="function"><span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> c)</span> </span>{
    <span class="keyword">if</span> (nex[last][c]) {
      <span class="keyword">int</span> p = last, cur = nex[p][c];
      <span class="keyword">if</span> (len[p]+<span class="number">1</span> == len[cur]) <span class="keyword">return</span> cur;
      <span class="keyword">int</span> q = sz++;
      len[q] = len[p]+<span class="number">1</span>;
      <span class="built_in">memcpy</span>(nex[q], nex[cur], <span class="keyword">sizeof</span> nex[q]);
      <span class="keyword">for</span> ( ; ~p &amp;&amp; nex[p][c] == cur; p = link[p]) nex[p][c] = q;
      link[q] = link[cur];
      link[cur] = q;
      <span class="keyword">return</span> q;
    }
    <span class="keyword">int</span> cur = sz++, p = last;
    len[cur] = len[p]+<span class="number">1</span>;
    <span class="keyword">for</span> ( ; ~p &amp;&amp; !nex[p][c]; p = link[p]) nex[p][c] = cur;
    <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="keyword">return</span> link[cur] = <span class="number">0</span>, cur;
    <span class="keyword">int</span> q = nex[p][c];
    <span class="keyword">if</span> (len[p]+<span class="number">1</span> == len[q]) <span class="keyword">return</span> link[cur] = q, cur;
    <span class="keyword">int</span> clone = sz++;
    len[clone] = len[p]+<span class="number">1</span>;
    <span class="built_in">memcpy</span>(nex[clone], nex[q], <span class="keyword">sizeof</span> nex[q]);
    <span class="keyword">for</span> (; ~p &amp;&amp; nex[p][c] == q; p = link[p]) nex[p][c] = clone;
    link[clone] = link[q];
    link[q] = link[cur] = clone;
    <span class="keyword">return</span> cur;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{
    <span class="keyword">int</span> last = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) last = extend(last, ch-C);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, last = <span class="number">0</span>; s[i]; ++i) last = extend(last, s[i]-C);
  }
};
</code></pre>

    </div>
</div>
<h3 id="多个字符串间的最长公共子串-1"><a href="#多个字符串间的最长公共子串-1" class="headerlink" title="多个字符串间的最长公共子串"></a><a href="https://www.luogu.com.cn/problem/SP8093" target="_blank" rel="noopener">多个字符串间的最长公共子串</a></h3><p>设有 $k$ 个字符串,每个结点建立长度为 $k$ 的标记,在 parent 树自底向上合并,若满足所有标记,则记录</p>
<p>(对于本题而言，可以仅为标记数组，若需要求出此子串的个数，则需要改成计数数组)(可用二进制或bitset)</p>
<h3 id="根号暴力"><a href="#根号暴力" class="headerlink" title="根号暴力"></a><a href="https://blog.csdn.net/qq_42925924/article/details/112264228" target="_blank" rel="noopener">根号暴力</a></h3><p>在 parent 树上从字符串的每一个前缀的状态暴力往上跳(须标记vis)</p>
<p>例如可用此法记录上述的标记数组</p>
<p>证明:对于第 $i$ 个字符串,它最多会贡献 $\min{(n,\lvert s_i \rvert^2)}, n=\sum{\lvert s_i \rvert},O(n\sqrt{n})$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">jump</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> id)</span> </span>{
  <span class="keyword">int</span> x = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) {
    x = nex[x][ch-C];
    <span class="keyword">for</span> (<span class="keyword">int</span> y = x; y &amp;&amp; vis[y] != id; y = link[y]) {
      vis[y] = id;
      ++k[y]; <span class="comment">// 记录信息</span>
    }
  }
}
</code></pre>

    </div>
</div>
<h3 id="树上本质不同路径数"><a href="#树上本质不同路径数" class="headerlink" title="树上本质不同路径数"></a>树上本质不同路径数</h3><p>一颗无根树上任意一条路径必定可以在以某个叶节点为根时，变成一条从上到下的路径</p>
<p>暴力把所有叶子结点为根的树加入自动机,就这?</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>, <span class="keyword">int</span> last = <span class="number">0</span>)</span> </span>{
  <span class="keyword">int</span> nex = gsam.extend(last, a[u]);
  <span class="keyword">for</span> (<span class="keyword">int</span> v : e[u]) <span class="keyword">if</span> (v != fa) dfs(v, u, nex);
}
</code></pre>

    </div>
</div>
<h3 id="循环同构问题"><a href="#循环同构问题" class="headerlink" title="循环同构问题"></a>循环同构问题</h3><p>CF235C:SAM 读入字符串是支持删除首字符的! 将一个字符串所有的循环同构串插入到 sam, 外加 vis 去重</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function">ll <span class="title">cyclic_query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{ <span class="comment">// 循环同构</span>
    <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>, vis[M];
    ++id;
    ll res = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, c, m = s.size(), u = <span class="number">0</span>, l = <span class="number">0</span>; i &lt; m*<span class="number">2</span><span class="number">-1</span>; ++i) {
      c = s[i%m]-C;
      <span class="keyword">while</span> (u &amp;&amp; !nex[u][c]) l = len[u = link[u]];
      <span class="keyword">if</span> (nex[u][c]) u = nex[u][c], ++l;
      <span class="keyword">if</span> (l &gt; m &amp;&amp; --l == len[link[u]]) u = link[u]; <span class="comment">// 删除首字符</span>
      <span class="keyword">if</span> (l == m &amp;&amp; vis[u] != id) res += cnt[u], vis[u] = id; <span class="comment">// 去重,记录答案</span>
    }
    <span class="keyword">return</span> res;
  }
</code></pre>

    </div>
</div>
<h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><p>$S[i\cdots n]+S[1\cdots i-1] = T$ 则称 $S$ 与 $T$ <strong>循环同构</strong></p>
<p>字符串 $S$ 的<strong>最小表示</strong>为与 $S$ 循环同构的所有字符串中字典序最小的字符串</p>
<p>$O(n)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">int</span> <span class="title">min_cyclic_string</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{
  <span class="keyword">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">1</span>, n = s.size();
  <span class="keyword">while</span> (k &lt; n &amp;&amp; i &lt; n &amp;&amp; j &lt; n) {
    <span class="keyword">if</span> (s[(i + k) % n] == s[(j + k) % n]) {
      k++;
    } <span class="keyword">else</span> {
      s[(i + k) % n] &gt; s[(j + k) % n] ? i = i + k + <span class="number">1</span> : j = j + k + <span class="number">1</span>;
      <span class="keyword">if</span> (i == j) i++;
      k = <span class="number">0</span>;
    }
  }
  <span class="keyword">return</span> min(i, j);
}
</code></pre>

    </div>
</div>
<h2 id="Lyndon分解"><a href="#Lyndon分解" class="headerlink" title="Lyndon分解"></a>Lyndon分解</h2><p>Lyndon 串：对于字符串 $s$，如果 $s$ 的字典序严格小于 $s$ 的所有后缀的字典序，我们称 $s$ 是简单串，或者 Lyndon 串。</p>
<p>Lyndon 分解：串 $s$ 的 Lyndon 分解记为 $s=w_1w_2\cdots w_k$，其中所有 $w_i$ 为简单串，并且他们的字典序按照非严格单减排序，即 $w_1\ge w_2\ge\cdots\ge w_k$。可以发现，这样的分解存在且唯一。</p>
<p>Duval 可以在 $O(n)$ 的时间内求出一个串的 Lyndon 分解。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="comment">// duval_algorithm</span>
<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">duval</span><span class="params">(<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span> </span>{
  <span class="keyword">int</span> n = s.size(), i = <span class="number">0</span>;
  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; factorization;
  <span class="keyword">while</span> (i &lt; n) {
    <span class="keyword">int</span> j = i + <span class="number">1</span>, k = i;
    <span class="keyword">while</span> (j &lt; n &amp;&amp; s[k] &lt;= s[j]) {
      <span class="keyword">if</span> (s[k] &lt; s[j])
        k = i;
      <span class="keyword">else</span>
        k++;
      j++;
    }
    <span class="keyword">while</span> (i &lt;= k) {
      factorization.push_back(s.substr(i, j - k));
      i += j - k;
    }
  }
  <span class="keyword">return</span> factorization;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="回文树-回文自动机-PAM"><a href="#回文树-回文自动机-PAM" class="headerlink" title="回文树|回文自动机|PAM"></a>回文树|回文自动机|PAM</h2><p>定理:对于一个字符串 $s$,它的本质不同回文子串个数最多只有 $\lvert s \rvert$ 个。</p>
<p>状态数,复杂度 $O(n)$</p>
<p>由于回文树的构造过程中，节点本身就是按照拓扑序插入，因此可以按序枚举所有状态实现树遍历</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> A = <span class="number">26</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> C = <span class="string">'a'</span>;
  <span class="keyword">int</span> sz, tot, last;
  <span class="keyword">int</span> ch[N][A], len[N], fail[N];
  <span class="keyword">char</span> s[N];
  PAM() { init(); }
  <span class="function"><span class="keyword">int</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> l)</span> </span>{
    ++sz;
    <span class="built_in">memset</span>(ch[sz], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[sz]);
    len[sz] = l;
    fail[sz] = <span class="number">0</span>;
    <span class="keyword">return</span> sz;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
    sz = <span class="number">-1</span>;
    last = <span class="number">0</span>;
    s[tot = <span class="number">0</span>] = <span class="string">'$'</span>;
    node(<span class="number">0</span>);
    fail[<span class="number">0</span>] = node(<span class="number">-1</span>);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">getfail</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    <span class="keyword">while</span> (s[tot-len[x]<span class="number">-1</span>] != s[tot]) x = fail[x];
    <span class="keyword">return</span> x;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>{
    s[++tot] = c;
    <span class="keyword">int</span> now = getfail(last);
    <span class="keyword">if</span> (!ch[now][c-C]) {
      <span class="keyword">int</span> x = node(len[now]+<span class="number">2</span>);
      fail[x] = ch[getfail(fail[now])][c-C];
      ch[now][c-C] = x;
    }
    last = ch[now][c-C];
  }
};
</code></pre>

    </div>
</div>
<h3 id="特殊log性质"><a href="#特殊log性质" class="headerlink" title="特殊log性质"></a>特殊log性质</h3><p>记字符串 $s$ 长度为 $i$ 的前缀为 $pre(s,i)$，长度为 $i$ 的后缀为 $suf(s,i)$</p>
<p>周期：若 $0&lt; p \le |s|$，$\forall 1 \le i \le |s|-p,s[i]=s[i+p]$，就称 $p$ 是 $s$ 的周期。</p>
<p>border：若 $0 \le r &lt; |s|$，$pre(s,r)=suf(s,r)$，就称 $pre(s,r)$ 是 $s$ 的 border。</p>
<p>周期和 border 的关系：$t$ 是 $s$ 的 border，当且仅当 $|s|-|t|$ 是 $s$ 的周期。</p>
<p>引理 $1$：$t$ 是回文串 $s$ 的后缀，$t$ 是 $s$ 的 border 当且仅当 $t$ 是回文串。</p>
<p>引理 $2$：$t$ 是回文串 $s$ 的 border ($|s|\le 2|t|$)，$s$ 是回文串当且仅当 $t$ 是回文串。</p>
<p>引理 $3$：$t$ 是回文串 $s$ 的 border，则 $|s|-|t|$ 是 $s$ 的周期，$|s|-|t|$ 为 $s$ 的最小周期，当且仅当 $t$ 是 $s$ 的最长回文真后缀。</p>
<p>引理 $4$：$x$ 是一个回文串，$y$ 是 $x$ 的最长回文真后缀，$z$ 是 $y$ 的最长回文真后缀。令 $u,v$ 分别为满足 $x=uy,y=vz$ 的字符串，则有下面三条性质</p>
<p>$|u| \ge |v|$；</p>
<p>如果 $|u| &gt; |v|$，那么 $|u| &gt; |z|$；</p>
<p>如果 $|u| = |v|$，那么 $u=v$。</p>
<p>推论：$s$ 的所有回文后缀按照长度排序后，可以划分成 $\log |s|$ 段等差数列。</p>
<p>回文树上的每个节点 $u$ 需要多维护两个信息，$diff[u]$ 和 $slink[u]$。$diff[u]$ 表示节点 $u$ 和 $fail[u]$ 所代表的回文串的长度差，即 $len[u]-len[fail[u]]$。$slink[u]$ 表示 $u$ 一直沿着 fail 向上跳到第一个节点 $v$，使得 $diff[v] \neq diff[u]$，也就是 $u$ 所在等差数列中长度最小的那个节点。</p>
<pre><code class="cpp">      diff[x] = len[x]-len[fail[x]];
      slink[x] = diff[x] == diff[fail[x]] ? slink[fail[x]] : fail[x];
</code></pre>
<pre><code class="cpp">for (int i = 2; i &lt;= sz; ++i)
  for (int j = i, k = slink[i]; j; j = k, k = slink[j])
    // 等差数列[len[k], len[j]] d = diff[j]
</code></pre>
<h3 id="最小回文划分"><a href="#最小回文划分" class="headerlink" title="最小回文划分"></a>最小回文划分</h3><p>问题描述:求最小的 $k$,使得字符串能分成 $k$ 段且每段都是回文串</p>
<p>暴力:$dp[i]=1+\min\limits_{s[j+1\cdots i]为回文串}dp[j]$</p>
<p>$g[v]$ 表示 $v$ 所在等差数列的 $dp$ 值之和，且 $v$ 是这个等差数列中长度最长的节点，则 $g[v]=\sum_{x,slink[x]=v} dp[i-len[x]]$，这里 $i$ 是当前枚举到的下标。(该题改求和为取min)</p>
<p>假设当前枚举到第 $i$ 个字符，回文树上对应节点为 $x$。$g[x]=g[fail[x]]+dp[i-(len[slink[x]]+diff[x])]$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>{
  dp[<span class="number">0</span>] = <span class="number">1</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= tot; ++i) {
    <span class="keyword">while</span> (s[i-len[x]<span class="number">-1</span>] != s[i]) x = fail[x];
    x = ch[x][s[i]-C];
    <span class="keyword">for</span> (<span class="keyword">int</span> j = x; j &gt; <span class="number">1</span>; j = slink[j]) {
      g[j] = dp[i-len[slink[j]]-diff[j]];
      <span class="keyword">if</span> (diff[j] == diff[fail[j]]) update(g[j], g[fail[j]]);
      update(dp[i], g[j]);
    }
  }
}
</code></pre>

    </div>
</div>
<h3 id="回文级数优化回文树上dp"><a href="#回文级数优化回文树上dp" class="headerlink" title="回文级数优化回文树上dp"></a><a href="https://github.com/K0u1e/K0u1e-with-XCPC/blob/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8E%E6%A8%A1%E6%9D%BF/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%9B%9E%E6%96%87%E7%BA%A7%E6%95%B0%E4%BC%98%E5%8C%96%E5%9B%9E%E6%96%87%E6%A0%91%E4%B8%8Adp.cpp" target="_blank" rel="noopener">回文级数优化回文树上dp</a></h3><p>问题描述:把字符串 $s$ 划分成若干个字符串 $t_1t_2\cdots t_k$,使得 $t_i=t_{k-i+1}$,求方案数</p>
<p>问题转化:将字符串转为 $s_1s_ns_2s_{n-1}\cdots$,原划分方案恰好对应了对新串进行偶数长度的回文划分的方案</p>
<p>tips:只需要考虑偶数下标位置的 $dp$ 值即可</p>
<h2 id="序列自动机"><a href="#序列自动机" class="headerlink" title="序列自动机"></a>序列自动机</h2><p>序列自动机是接受且仅接受一个字符串的子序列的自动机。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">SeqAutomaton</span> {</span> <span class="comment">// suppose string [1, n]</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> A = <span class="number">26</span>;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> C = <span class="string">'a'</span>;
  <span class="keyword">int</span> nex[N][A];
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>{
    <span class="built_in">memset</span>(nex[s.size()], <span class="number">0</span>, <span class="keyword">sizeof</span> nex[<span class="number">0</span>]);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.size(); i; --i) {
      <span class="built_in">memcpy</span>(nex[i<span class="number">-1</span>], nex[i], <span class="keyword">sizeof</span> nex[<span class="number">0</span>]);
      nex[i<span class="number">-1</span>][s[i<span class="number">-1</span>]-C] = i;
    }
  }
};
</code></pre>

    </div>
</div>
<h2 id="Main-Lorentz-算法"><a href="#Main-Lorentz-算法" class="headerlink" title="Main-Lorentz 算法"></a>Main-Lorentz 算法</h2><p>我们将一个字符串连续写两遍所产生的新字符串称为 重串 (tandem repetition)。将被重复的这个字符串称为原串。</p>
<p>如果一个重串的原串不是重串，则我们称这个重串为 本原重串 (primitive repetition)。可以证明，本原重串最多有 $O(n \log n)$ 个。</p>
<p>如果我们把一个重串用 Crochemore 三元组 $(i, p, r)$ 进行压缩，其中 $i$ 是重串的起始位置，$p$ 是该重串某个循环节的长度（注意不是原串长度！），$r$ 为这个循环节重复的次数。则某字符串的所有重串可以被 $O(n \log n)$ 个 Crochemore 三元组表示。</p>
<h1 id="图论-树论"><a href="#图论-树论" class="headerlink" title="图论|树论"></a>图论|树论</h1><h2 id="DFS树"><a href="#DFS树" class="headerlink" title="DFS树"></a><a href="https://codeforces.com/blog/entry/68138" target="_blank" rel="noopener">DFS树</a></h2><h2 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a><a href="https://www.luogu.org/problemnew/show/P2986" target="_blank" rel="noopener">树的重心</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">treedp</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span> </span>{
  s[cur] = c[cur];
  <span class="keyword">for</span>(<span class="keyword">int</span> i = fir[cur]; i; i = nex[i]) {
    <span class="keyword">if</span>(e[i] == fa) <span class="keyword">continue</span>;
    treedp(e[i], cur);
    s[cur] += s[e[i]];
    maxs[cur] = max(maxs[cur], s[e[i]]);
  }
  maxs[cur] = max(maxs[cur], sum-s[cur]);
}
</code></pre>

    </div>
</div>
<h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><p>最大独立集数=补图的最大团<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">MaxClique</span> {</span>
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, tmp, cnt;
  <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = p+<span class="number">1</span>, flag; i &lt;= n; ++i) {
      <span class="keyword">if</span> (cnt[i]+tmp.size() &lt;= res.size()) <span class="keyword">return</span> <span class="literal">false</span>;
      <span class="keyword">if</span> (!g[p][i]) <span class="keyword">continue</span>;
      flag = <span class="number">1</span>;
      <span class="keyword">for</span> (<span class="keyword">int</span> j : tmp)
        <span class="keyword">if</span> (!g[i][j]) flag = <span class="number">0</span>;
      <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;
      tmp.push_back(i);
      <span class="keyword">if</span> (dfs(i)) <span class="keyword">return</span> <span class="literal">true</span>;
      tmp.pop_back();
    }
    <span class="keyword">if</span> (tmp.size() &gt; res.size()) {
      res = tmp;
      <span class="keyword">return</span> <span class="literal">true</span>;
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>{
    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>).swap(cnt);
    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(res);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) {
      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, i).swap(tmp);
      dfs(i);
      cnt[i] = res.size();
    }
  }
} MC;
</code></pre>

    </div>
</div></p>
<hr>
<h2 id="稳定婚姻匹配"><a href="#稳定婚姻匹配" class="headerlink" title="稳定婚姻匹配"></a>稳定婚姻匹配</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt; struct Stable_Marriage {
  <span class="keyword">int</span> t[N], b[N], g[N], rkb[N][N], rkg[N][N];
  T wb[N][N], wg[N][N];
  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;().swap(q);
    <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
      q.push(i);
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)
        rkb[i][j] = rkg[i][j] = j;
      sort(rkb[i]+<span class="number">1</span>, rkb[i]+n+<span class="number">1</span>,
         [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y) { <span class="keyword">return</span> wb[i][y] &lt; wb[i][x]; });
      <span class="comment">//sort(rkg[i]+1, rkg[i]+n+1,</span>
      <span class="comment">//   [&amp;](const int &amp;x, const int &amp;y) { return wg[i][y] &lt; wg[i][x]; });</span>
    }
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>{
    <span class="keyword">if</span> (g[y]) {
      <span class="keyword">if</span> (wg[y][x] &lt; wg[y][g[y]]) <span class="keyword">return</span> <span class="literal">false</span>;
      b[g[y]] = <span class="number">0</span>;
      q.push(g[y]);
    }
    b[x] = y; g[y] = x;
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">gale_shapely</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    init(n);
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> x = q.front(); q.pop();
      <span class="keyword">int</span> y = rkb[x][++t[x]];
      <span class="keyword">if</span> (!match(x, y)) q.push(x);
    }
  }
};
</code></pre>

    </div>
</div>
<hr>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a><a href="https://www.luogu.org/problemnew/show/P3366" target="_blank" rel="noopener">最小生成树</a></h2><p><a href="https://www.luogu.org/problemnew/show/P1265" target="_blank" rel="noopener">Prim</a><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span> </span>{
  fill(dis, dis+n+<span class="number">1</span>, INF);
  dis[<span class="number">1</span>] = <span class="number">0</span>;
  <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= n; ++t)
  {
    <span class="keyword">int</span> mini = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
      <span class="keyword">if</span>(!vis[i] &amp;&amp; dis[i] &lt; dis[mini])
        mini = i;
    vis[mini] = <span class="number">1</span>;
    ans += dis[mini];
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
      <span class="keyword">if</span>(!vis[i]) dis[i] = min(dis[i], calc(mini, i));
  }
}
</code></pre>

    </div>
</div><br>Kruskal (略)</p>
<hr>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a><a href="https://www.luogu.org/problemnew/show/P3386" target="_blank" rel="noopener">二分图最大匹配</a></h3><p>增广路算法 Augmenting Path Algorithm $O(nm)$<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> v : e[u]) {
    <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;
    vis[v] = <span class="number">1</span>;
    <span class="keyword">if</span> (!co[v] || check(co[v])) {
      co[v] = u;
      <span class="keyword">return</span> <span class="literal">true</span>;
    }
  }
  <span class="keyword">return</span> <span class="literal">false</span>;
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>{
  <span class="keyword">int</span> res = <span class="number">0</span>;
  <span class="built_in">memset</span>(co, <span class="number">0</span>, <span class="keyword">sizeof</span> co);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    res += check(i);
  }
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div><br>网络流 $O(\sqrt{n}m)$</p>
<h3 id="二分图最大权匹配"><a href="#二分图最大权匹配" class="headerlink" title="二分图最大权匹配"></a>二分图最大权匹配</h3><p>Hungarian Algorithm (Kuhn-Munkres Algorithm)<br>匈牙利算法又称为 KM 算法，可以在 $O(n^3)$ 时间内求出二分图的 最大权完美匹配。</p>
<h3 id="二分图最小顶点覆盖"><a href="#二分图最小顶点覆盖" class="headerlink" title="二分图最小顶点覆盖"></a>二分图最小顶点覆盖</h3><p>定义：假如选了一个点就相当于覆盖了以它为端点的所有边。最小顶点覆盖就是选择最少的点来覆盖所有的边。</p>
<p>定理：最小顶点覆盖等于二分图的最大匹配。</p>
<h3 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h3><p>定义：选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。找出一个包含顶点数最多的独立集称为最大独立集。</p>
<p>定理：最大独立集 = 所有顶点数 - 最小顶点覆盖 = 所有顶点数 - 最大匹配</p>
<hr>
<h2 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先|LCA"></a><a href="https://www.luogu.org/problemnew/show/P3379" target="_blank" rel="noopener">最近公共祖先|LCA</a></h2><h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">LCA</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = (<span class="keyword">int</span>)log2(N)+<span class="number">3</span>;
  <span class="keyword">int</span> f[N][NN], d[N], lg2[N];
  LCA() { <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) lg2[i] = lg2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>; }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> TT e[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;u = <span class="number">1</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;fa = <span class="number">0</span>)</span> </span>{
    d[u] = d[fa]+<span class="number">1</span>;
    f[u][<span class="number">0</span>] = fa;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;i) &lt;= d[u]; ++i)
      f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];
    <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v != fa)
      build(e, v, u);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    <span class="keyword">if</span> (d[x] &lt; d[y]) swap(x, y);
    <span class="keyword">while</span> (d[x] &gt; d[y])
      x = f[x][lg2[d[x]-d[y]]];
    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg2[d[x]]; i &gt;= <span class="number">0</span>; --i)
      <span class="keyword">if</span>(f[x][i] != f[y][i])
        x = f[x][i], y = f[y][i];
    <span class="keyword">return</span> f[x][<span class="number">0</span>];
  }
};
</code></pre>

    </div>
</div>
<h3 id="树剖"><a href="#树剖" class="headerlink" title="树剖"></a>树剖</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">HLD</span> {</span>
  <span class="keyword">int</span> fa[N], d[N], num[N], son[N], tp[N];
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *e;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *e, <span class="keyword">const</span> <span class="keyword">int</span> &amp;rt = <span class="number">1</span>)</span> </span>{
    <span class="keyword">this</span>-&gt;e = e;
    fa[rt] = <span class="number">0</span>;
    dfs1(rt);
    dfs2(rt);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u = <span class="number">1</span>)</span> </span>{
    d[u] = d[fa[u]]+<span class="number">1</span>;
    num[u] = <span class="number">1</span>;
    son[u] = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;v : e[u]) <span class="keyword">if</span> (v != fa[u]) {
      fa[v] = u;
      dfs1(v);
      num[u] += num[v];
      <span class="keyword">if</span> (num[v] &gt; num[son[u]]) son[u] = v;
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u = <span class="number">1</span>)</span> </span>{
    tp[u] = son[fa[u]] == u ? tp[fa[u]] : u;
    <span class="keyword">if</span> (son[u]) dfs2(son[u]);
    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;v : e[u]) <span class="keyword">if</span> (v != son[u] &amp;&amp; v != fa[u])
      dfs2(v);
  }
  <span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    <span class="keyword">while</span> (tp[x] != tp[y]) {
      <span class="keyword">if</span> (d[tp[x]] &lt; d[tp[y]]) swap(x, y);
      x = fa[tp[x]];
    }
    <span class="keyword">return</span> d[x] &lt; d[y] ? x : y;
  }
};
</code></pre>

    </div>
</div>
<h3 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h3><p>dfs 时进入一个节点加入序列,回溯回来也加一次</p>
<p>lca 转变为区间深度最小的点</p>
<h3 id="带权LCA"><a href="#带权LCA" class="headerlink" title="带权LCA"></a><a href="https://www.luogu.com.cn/problem/P1967" target="_blank" rel="noopener">带权LCA</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">LCA</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NN = (<span class="keyword">int</span>)log2(N)+<span class="number">3</span>;
  <span class="keyword">int</span> f[N][NN], d[N], lg2[N];
  T w[N][NN], init_val = <span class="number">0</span>;
  LCA() {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) lg2[i] = lg2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;
    init();
  }
  <span class="comment">// set sum or min or max, and don't forget to set init_val</span>
  <span class="function">T <span class="title">update</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> </span>{ <span class="keyword">return</span> x+y; }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n = N<span class="number">-1</span>)</span> </span>{
    fill(w[<span class="number">0</span>], w[<span class="number">0</span>]+(n+<span class="number">1</span>)*NN, init_val);
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> TT e[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;u = <span class="number">1</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;fa = <span class="number">0</span>)</span> </span>{
    d[u] = d[fa]+<span class="number">1</span>;
    f[u][<span class="number">0</span>] = fa;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;i) &lt;= d[u]; ++i) {
      f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];
      w[u][i] = update(w[u][i<span class="number">-1</span>], w[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]);
    }
    <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) <span class="keyword">if</span> (v.first != fa) {
      w[v.first][<span class="number">0</span>] = v.second;
      build(e, v.first, u);
    }
  }
  <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    T res = init_val;
    <span class="keyword">if</span> (d[x] &lt; d[y]) swap(x, y);
    <span class="keyword">while</span> (d[x] &gt; d[y]) {
      res = update(res, w[x][lg2[d[x]-d[y]]]);
      x = f[x][lg2[d[x]-d[y]]];
    }
    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> res;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg2[d[x]]; i &gt;= <span class="number">0</span>; --i)
      <span class="keyword">if</span>(f[x][i] != f[y][i]) {
        res = update(res, w[x][i]);
        res = update(res, w[y][i]);
        x = f[x][i], y = f[y][i];
      }
    <span class="keyword">return</span> update(res, update(w[x][<span class="number">0</span>], w[y][<span class="number">0</span>]));
  }
};
</code></pre>

    </div>
</div>
<h2 id="最小环"><a href="#最小环" class="headerlink" title="最小环"></a>最小环</h2><hr>
<h2 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a><a href="https://www.luogu.com.cn/problem/P3128" target="_blank" rel="noopener">树上差分</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> {</span>
  T val[N];
  <span class="function"><span class="keyword">void</span> <span class="title">update_point</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">const</span> T &amp;k)</span> </span>{
    <span class="keyword">int</span> _lca = lca(x, y);
    val[x] += k; val[y] += k;
    val[_lca] -= k; val[f[_lca][<span class="number">0</span>]] -= k;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">update_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y, <span class="keyword">const</span> T &amp;k)</span> </span>{
    <span class="keyword">int</span> _lca = lca(x, y);
    val[x] += k; val[y] += k; val[_lca] -= <span class="number">2</span>*k;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u = <span class="number">1</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;fa = <span class="number">0</span>)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> v : e[u]) <span class="keyword">if</span> (v != fa) {
      dfs(v, u);
      val[u] += val[v];
    }
  }
};
</code></pre>

    </div>
</div>
<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a><a href="https://www.luogu.com.cn/problem/P3384" target="_blank" rel="noopener">树链剖分</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">HLD</span> {</span>
  <span class="keyword">int</span> dfn;
  <span class="keyword">int</span> fa[N], d[N], num[N], son[N], id[N], tp[N];
  T init_val[N];
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *e;
  SegmentTree ST;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *e, T *a, <span class="keyword">int</span> n, <span class="keyword">int</span> rt = <span class="number">1</span>)</span> </span>{
    <span class="keyword">this</span>-&gt;e = e;
    fa[rt] = dfn = <span class="number">0</span>;
    dfs1(rt);
    dfs2(rt);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
      init_val[id[i]] = a[i];
    ST.build(init_val, n);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u = <span class="number">1</span>)</span> </span>{
    d[u] = d[fa[u]]+<span class="number">1</span>;
    num[u] = <span class="number">1</span>;
    son[u] = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;v : e[u]) <span class="keyword">if</span> (v != fa[u]) {
      fa[v] = u;
      dfs1(v);
      num[u] += num[v];
      <span class="keyword">if</span> (num[v] &gt; num[son[u]]) son[u] = v;
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u = <span class="number">1</span>)</span> </span>{
    tp[u] = son[fa[u]] == u ? tp[fa[u]] : u;
    id[u] = ++dfn;
    <span class="keyword">if</span> (son[u]) dfs2(son[u]);
    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;v : e[u]) <span class="keyword">if</span> (v != son[u] &amp;&amp; v != fa[u])
      dfs2(v);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add_sons</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> T &amp;k)</span> </span>{ ST.add(id[x], id[x]+num[x]<span class="number">-1</span>, k); }
  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;is_edge = <span class="number">0</span>)</span> </span>{
    <span class="keyword">while</span> (tp[x] != tp[y]) {
      <span class="keyword">if</span> (d[tp[x]] &lt; d[tp[y]]) swap(x, y);
      ST.add(id[tp[x]], id[x], k);
      x = fa[tp[x]];
    }
    <span class="keyword">if</span> (d[x] &gt; d[y]) swap(x, y);
    ST.add(id[x], id[y], k);
    <span class="keyword">if</span> (is_edge) ST.add(id[x], -k);
  }
  <span class="function">T <span class="title">query_sons</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{ <span class="keyword">return</span> ST.query(id[x], id[x]+num[x]<span class="number">-1</span>); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>{ <span class="keyword">return</span> ST.query(id[x]); }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{
    T res = <span class="number">0</span>;
    <span class="keyword">while</span> (tp[x] != tp[y]) {
      <span class="keyword">if</span> (d[tp[x]] &lt; d[tp[y]]) swap(x, y);
      res += ST.query(id[tp[x]], id[x]);
      x = fa[tp[x]];
    }
    <span class="keyword">if</span> (d[x] &gt; d[y]) swap(x, y);
    <span class="keyword">return</span> res+ST.query(id[x], id[y]);
  }
};
</code></pre>

    </div>
</div>
<hr>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><p><a href="https://loj.ac/problems/tag/30" target="_blank" rel="noopener">网络流24题</a></p>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a><a href="https://www.luogu.org/problemnew/show/P3376" target="_blank" rel="noopener">最大流</a></h3><h4 id="EK"><a href="#EK" class="headerlink" title="EK"></a>EK</h4><p>$O(nm^2)$<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">EK</span> {</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span>
    <span class="keyword">int</span> v, nex;
    T w;
  } e[M&lt;&lt;<span class="number">1</span>];
  <span class="keyword">int</span> tot = <span class="number">0</span>, n;
  <span class="keyword">int</span> fir[N], vis[N], pre[N];
  T incf[N];
  <span class="function">T <span class="title">work</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span> </span>{
    T res = <span class="number">0</span>;
    <span class="keyword">while</span> (bfs(s, t)) {
      <span class="keyword">int</span> u = t, id;
      <span class="keyword">while</span> (u != s) {
        id = pre[u];
        e[id].w -= incf[t];
        e[id^<span class="number">1</span>].w += incf[t];
        u = e[id^<span class="number">1</span>].v;
      }
      res += incf[t];
    }
    <span class="keyword">return</span> res;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;sz)</span> </span>{
    n = sz;
    tot = <span class="number">0</span>;
    <span class="built_in">memset</span>(fir, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> T &amp;w)</span> </span>{
    e[tot] = {v, fir[u], w}; fir[u] = tot++;
    e[tot] = {u, fir[v], <span class="number">0</span>}; fir[v] = tot++;
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span> </span>{
    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    q.push(s);
    vis[s] = <span class="number">1</span>;
    incf[s] = INF;
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> u = q.front();
      q.pop();
      <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u], v; i != <span class="number">-1</span>; i = e[i].nex) {
        v = e[i].v;
        <span class="keyword">if</span> (vis[v] || !e[i].w) <span class="keyword">continue</span>;
        incf[v] = min(incf[u], e[i].w);
        pre[v] = i;
        <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;
        q.push(v);
        vis[v] = <span class="number">1</span>;
      }
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
  }
};
</code></pre>

    </div>
</div></p>
<h4 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h4><p>普通情况下 $O(n^2m)$<br>二分图中 $O(\sqrt{n}m)$</p>
<p><strong>该板子存在可能效率极其低下的问题</strong></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> {</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> {</span>
    <span class="keyword">int</span> v, nex;
    T w;
    EDGE(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;_nex, <span class="keyword">const</span> T &amp;_w) : v(_v), nex(_nex), w(_w) {}
  };
  <span class="built_in">vector</span>&lt;EDGE&gt; e;
  <span class="keyword">int</span> n, s, t;
  <span class="keyword">int</span> fir[N], dep[N], cur[N];
  Dinic() { e.reserve(N&lt;&lt;<span class="number">2</span>); }
  <span class="function">T <span class="title">work</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="keyword">_t</span>)</span> </span>{
    s = _s; t = <span class="keyword">_t</span>;
    T maxflow = <span class="number">0</span>, flow;
    <span class="keyword">while</span> (bfs())
      <span class="keyword">while</span> ((flow = dfs(s, INF)))
        maxflow += flow;
    <span class="keyword">return</span> maxflow;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n)</span> </span>{
    n = _n;
    e.clear();
    <span class="built_in">memset</span>(fir, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> T &amp;w)</span> </span>{
    e.emplace_back(v, fir[u], w); fir[u] = e.size()<span class="number">-1</span>;
    e.emplace_back(u, fir[v], <span class="number">0</span>); fir[v] = e.size()<span class="number">-1</span>;
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>{
    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    q.push(s);
    dep[s] = <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) cur[i] = fir[i];
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> u = q.front();
      q.pop();
      <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u], v; i != <span class="number">-1</span>; i = e[i].nex) {
        v = e[i].v;
        <span class="keyword">if</span> (dep[v] || !e[i].w) <span class="keyword">continue</span>;
        dep[v] = dep[u]+<span class="number">1</span>;
        <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;
        q.push(v);
      }
    }
    <span class="keyword">return</span> <span class="literal">false</span>;
  }
  <span class="function">T <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> T &amp;flow)</span> </span>{
    <span class="keyword">if</span> (!flow || u == t) <span class="keyword">return</span> flow;
    T rest = flow, now;
    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], v; i != <span class="number">-1</span>; i = e[i].nex) {
      v = e[i].v;
      <span class="keyword">if</span> (dep[v] != dep[u]+<span class="number">1</span> || !e[i].w) <span class="keyword">continue</span>;
      now = dfs(v, min(rest, e[i].w));
      <span class="keyword">if</span> (!now) {
        dep[v] = <span class="number">0</span>;
      } <span class="keyword">else</span> {
        e[i].w -= now;
        e[i^<span class="number">1</span>].w += now;
        rest -= now;
        <span class="keyword">if</span> (rest == flow) <span class="keyword">break</span>;
      }
    }
    <span class="keyword">return</span> flow-rest;
  }
};
</code></pre>

    </div>
</div>
<h4 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h4><p>渐进时间复杂度和dinic相同，但是非二分图的情况下isap更具优势<br>在某些情况(题目)中远慢于dinic</p>
<p>OI Wiki版本</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">ISAP</span> {</span> <span class="comment">// copy from oi-wiki</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span>
    <span class="keyword">int</span> from, to;
    T cap, flow;
    Edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, T c, T f) : from(u), to(v), cap(c), flow(f) {}
    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge&amp; a, <span class="keyword">const</span> Edge&amp; b) {
      <span class="keyword">return</span> a.from &lt; b.from || (a.from == b.from &amp;&amp; a.to &lt; b.to);
    }
  };
  <span class="keyword">int</span> n, m, s, t;
  <span class="built_in">vector</span>&lt;Edge&gt; edges;
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];
  <span class="keyword">bool</span> vis[N];
  <span class="keyword">int</span> d[N], cur[N], p[N], num[N];

  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>{
    edges.push_back(Edge(from, to, cap, <span class="number">0</span>));
    edges.push_back(Edge(to, from, <span class="number">0</span>, <span class="number">0</span>));
    m = edges.size();
    G[from].push_back(m - <span class="number">2</span>);
    G[to].push_back(m - <span class="number">1</span>);
  }

  <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>{
    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">3</span>));
    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;
    Q.push(t);
    vis[t] = <span class="number">1</span>;
    d[t] = <span class="number">0</span>;
    <span class="keyword">while</span> (!Q.empty()) {
      <span class="keyword">int</span> x = Q.front();
      Q.pop();
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[x].size(); i++) {
        Edge&amp; e = edges[G[x][i] ^ <span class="number">1</span>];
        <span class="keyword">if</span> (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) {
          vis[e.from] = <span class="number">1</span>;
          d[e.from] = d[x] + <span class="number">1</span>;
          Q.push(e.from);
        }
      }
    }
    <span class="keyword">return</span> vis[s];
  }

  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
    <span class="keyword">this</span>-&gt;n = n;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G[i].clear();
    edges.clear();
  }

  <span class="function">T <span class="title">Augment</span><span class="params">()</span> </span>{
    <span class="keyword">int</span> x = t;
    T flow = INF;
    <span class="keyword">while</span> (x != s) {
      Edge&amp; e = edges[p[x]];
      flow = min(flow, e.cap - e.flow);
      x = edges[p[x]].from;
    }
    x = t;
    <span class="keyword">while</span> (x != s) {
      edges[p[x]].flow += flow;
      edges[p[x]^<span class="number">1</span>].flow -= flow;
      x = edges[p[x]].from;
    }
    <span class="keyword">return</span> flow;
  }

  <span class="function">T <span class="title">work</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>{
    <span class="keyword">this</span>-&gt;s = s;
    <span class="keyword">this</span>-&gt;t = t;
    T flow = <span class="number">0</span>;
    BFS();
    <span class="built_in">memset</span>(num+<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) num[d[i]]++;
    <span class="keyword">int</span> x = s;
    <span class="built_in">memset</span>(cur+<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);
    <span class="keyword">while</span> (d[s] &lt; n) {
      <span class="keyword">if</span> (x == t) {
        flow += Augment();
        x = s;
      }
      <span class="keyword">int</span> ok = <span class="number">0</span>;
      <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i &lt; (<span class="keyword">int</span>)G[x].size(); i++) {
        Edge&amp; e = edges[G[x][i]];
        <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to]+<span class="number">1</span>) {
          ok = <span class="number">1</span>;
          p[e.to] = G[x][i];
          cur[x] = i;
          x = e.to;
          <span class="keyword">break</span>;
        }
      }
      <span class="keyword">if</span> (!ok) {
        <span class="keyword">int</span> m = n<span class="number">-1</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[x].size(); i++) {
          Edge&amp; e = edges[G[x][i]];
          <span class="keyword">if</span> (e.cap &gt; e.flow) m = min(m, d[e.to]);
        }
        <span class="keyword">if</span> (--num[d[x]] == <span class="number">0</span>) <span class="keyword">break</span>;
        num[d[x] = m+<span class="number">1</span>]++;
        cur[x] = <span class="number">0</span>;
        <span class="keyword">if</span> (x != s) x = edges[p[x]].from;
      }
    }
    <span class="keyword">return</span> flow;
  }
};
</code></pre>

    </div>
</div>
<p><a href="https://www.luogu.com.cn/blog/ONE-PIECE/jiu-ji-di-zui-tai-liu-suan-fa-isap-yu-hlpp" target="_blank" rel="noopener">Luogu版本</a></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">ISAP</span> {</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> {</span>
    <span class="keyword">int</span> v, nex;
    T w;
    EDGE(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;_nex, <span class="keyword">const</span> T &amp;_w) : v(_v), nex(_nex), w(_w) {}
  };
  <span class="built_in">vector</span>&lt;EDGE&gt; e;
  <span class="keyword">int</span> n, s, t;
  T maxflow;
  <span class="keyword">int</span> fir[N], gap[N], dep[N];
  <span class="function">T <span class="title">work</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="keyword">_t</span>)</span> </span>{
    s = _s; t = <span class="keyword">_t</span>;
    maxflow = <span class="number">0</span>;
    bfs();
    <span class="keyword">while</span> (dep[s] &lt; n) dfs(s, INF);
    <span class="keyword">return</span> maxflow;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n)</span> </span>{
    n = _n;
    e.clear();
    e.reserve(N&lt;&lt;<span class="number">2</span>);
    <span class="built_in">memset</span>(fir, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
  }
  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)e.size(); i += <span class="number">2</span>) {
      e[i].w += e[i^<span class="number">1</span>].w;
      e[i^<span class="number">1</span>].w = <span class="number">0</span>;
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">modify_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> T &amp;w)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u]; ~i; i = e[i].nex) <span class="keyword">if</span> (e[i].v == v) {
      e[i].w = w;
      e[i^<span class="number">1</span>].w = <span class="number">0</span>;
      <span class="keyword">break</span>;
    }
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> T &amp;w)</span> </span>{
    e.emplace_back(v, fir[u], w); fir[u] = e.size()<span class="number">-1</span>;
    e.emplace_back(u, fir[v], <span class="number">0</span>); fir[v] = e.size()<span class="number">-1</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>{
    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    <span class="built_in">memset</span>(gap, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    dep[t] = <span class="number">0</span>;
    gap[<span class="number">0</span>] = <span class="number">1</span>;
    q.push(t);
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> u = q.front();
      q.pop();
      <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u], v; i != <span class="number">-1</span>; i = e[i].nex) {
        v = e[i].v;
        <span class="keyword">if</span> (dep[v] != <span class="number">-1</span>) <span class="keyword">continue</span>;
        q.push(v);
        dep[v] = dep[u]+<span class="number">1</span>;
        ++gap[dep[v]];
      }
    }
  }
  <span class="function">T <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> T &amp;flow)</span> </span>{
    <span class="keyword">if</span> (u == t) <span class="keyword">return</span> maxflow += flow, flow;
    T used = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u], v; i != <span class="number">-1</span>; i = e[i].nex) {
      v = e[i].v;
      <span class="keyword">if</span> (!e[i].w || dep[v]+<span class="number">1</span> != dep[u]) <span class="keyword">continue</span>;
      T minf = dfs(v, min(e[i].w, flow-used));
      <span class="keyword">if</span> (minf) {
        e[i].w -= minf;
        e[i^<span class="number">1</span>].w += minf;
        used += minf;
      }
      <span class="keyword">if</span> (used == flow) <span class="keyword">return</span> used;
    }
    <span class="keyword">if</span> (--gap[dep[u]] == <span class="number">0</span>) dep[s] = n+<span class="number">1</span>;
    ++gap[++dep[u]];
    <span class="keyword">return</span> used;
  }
};
</code></pre>

    </div>
</div>
<h4 id="HLPP"><a href="#HLPP" class="headerlink" title="HLPP"></a>HLPP</h4><h3 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h3><p>最小割等价最大流</p>
<h3 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h3><h4 id="MCMF"><a href="#MCMF" class="headerlink" title="MCMF"></a>MCMF</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">MCMF</span> {</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span>
    <span class="keyword">int</span> v, nex;
    T w, c; <span class="comment">// edge wight and cost</span>
    Edge(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;_nex, <span class="keyword">const</span> T &amp;_w, <span class="keyword">const</span> T &amp;_c) \
    : v(_v), nex(_nex), w(_w), c(_c) {}
  };
  <span class="built_in">vector</span>&lt;Edge&gt; e;
  <span class="keyword">int</span> n, s, t;
  <span class="keyword">int</span> fir[N], vis[N], pre[N];
  T incf[N], dis[N];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n)</span> </span>{
    n = _n;
    e.clear();
    e.reserve(N&lt;&lt;<span class="number">4</span>);
    <span class="built_in">memset</span>(fir, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> T &amp;w, <span class="keyword">const</span> T &amp;c)</span> </span>{
    e.emplace_back(v, fir[u], w, c); fir[u] = e.size()<span class="number">-1</span>;
    e.emplace_back(u, fir[v], <span class="number">0</span>, -c); fir[v] = e.size()<span class="number">-1</span>;
  }
  pair&lt;T, T&gt; work(const int &amp;_s, const int &amp;_t) {
    s = _s; t = <span class="keyword">_t</span>;
    T maxflow = <span class="number">0</span>, mincost = <span class="number">0</span>;
    <span class="keyword">while</span> (spfa()) {
      <span class="keyword">for</span> (<span class="keyword">int</span> u = t, id; u != s; u = e[id^<span class="number">1</span>].v) {
        id = pre[u];
        e[id].w -= incf[t];
        e[id^<span class="number">1</span>].w += incf[t];
        mincost += incf[t]*e[id].c;
      }
      maxflow += incf[t];
    }
    <span class="keyword">return</span> {maxflow, mincost};
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>{
    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(T)*(n+<span class="number">3</span>));
    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    q.push(s);
    dis[s] = <span class="number">0</span>;
    incf[s] = INF;
    incf[t] = <span class="number">0</span>;
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> u = q.front();
      q.pop();
      vis[u] = <span class="number">0</span>;
      <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u], v; i != <span class="number">-1</span>; i = e[i].nex) {
        v = e[i].v;
        <span class="keyword">if</span> (!e[i].w || dis[v] &lt;= dis[u]+e[i].c) <span class="keyword">continue</span>;
        dis[v] = dis[u]+e[i].c;
        incf[v] = min(incf[u], e[i].w);
        pre[v] = i;
        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;
        q.push(v);
        vis[v] = <span class="number">1</span>;
      }
    }
    <span class="keyword">return</span> incf[t];
  }
};
</code></pre>

    </div>
</div>
<h4 id="类Dinic"><a href="#类Dinic" class="headerlink" title="类Dinic"></a>类Dinic</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span> {</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span>
    <span class="keyword">int</span> v, nex;
    T w, c; <span class="comment">// edge wight and cost</span>
    Edge(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;_nex, <span class="keyword">const</span> T &amp;_w, <span class="keyword">const</span> T &amp;_c) \
    : v(_v), nex(_nex), w(_w), c(_c) {}
  };
  <span class="built_in">vector</span>&lt;Edge&gt; e;
  <span class="keyword">int</span> n, s, t;
  <span class="keyword">int</span> fir[N], vis[N];
  T maxflow, mincost;
  T dis[N];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n)</span> </span>{
    n = _n;
    e.clear();
    e.reserve(N&lt;&lt;<span class="number">4</span>);
    maxflow = mincost = <span class="number">0</span>;
    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    <span class="built_in">memset</span>(fir, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> T &amp;w, <span class="keyword">const</span> T &amp;c)</span> </span>{
    e.emplace_back(v, fir[u], w, c); fir[u] = e.size()<span class="number">-1</span>;
    e.emplace_back(u, fir[v], <span class="number">0</span>, -c); fir[v] = e.size()<span class="number">-1</span>;
  }
  pair&lt;T, T&gt; work(const int &amp;_s, const int &amp;_t) {
    s = _s; t = <span class="keyword">_t</span>;
    T flow;
    <span class="keyword">while</span> (spfa())
      <span class="keyword">while</span> ((flow = dfs(s, INF)))
        maxflow += flow;
    <span class="keyword">return</span> {maxflow, mincost};
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>{
    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    q.push(s);
    dis[s] = <span class="number">0</span>;
    vis[s] = <span class="number">1</span>;
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> u = q.front();
      q.pop();
      vis[u] = <span class="number">0</span>;
      <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u], v; i != <span class="number">-1</span>; i = e[i].nex) {
        v = e[i].v;
        <span class="keyword">if</span> (!e[i].w || dis[v] &lt;= dis[u]+e[i].c) <span class="keyword">continue</span>;
        dis[v] = dis[u]+e[i].c;
        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;
        q.push(v);
        vis[v] = <span class="number">1</span>;
      }
    }
    <span class="keyword">return</span> dis[t] != INF;
  }
  <span class="function">T <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> T &amp;flow)</span> </span>{
    <span class="keyword">if</span> (!flow || u == t) <span class="keyword">return</span> flow;
    T res = <span class="number">0</span> , now;
    vis[u] = <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u], v; i != <span class="number">-1</span> &amp;&amp; res &lt; flow; i = e[i].nex) {
      v = e[i].v;
      <span class="keyword">if</span> (vis[v] || !e[i].w || dis[v] != dis[u]+e[i].c) <span class="keyword">continue</span>;
      now = dfs(v, min(flow-res, e[i].w));
      <span class="keyword">if</span> (!now) <span class="keyword">continue</span>;
      mincost += now*e[i].c;
      e[i].w -= now;
      e[i^<span class="number">1</span>].w += now;
      res += now;
    }
    vis[u] = <span class="number">0</span>;
    <span class="keyword">return</span> res;
  }
};
</code></pre>

    </div>
</div>
<h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>Primal-Dual 原始对偶算法</p>
<h4 id="ZKW-SPFA"><a href="#ZKW-SPFA" class="headerlink" title="ZKW_SPFA"></a>ZKW_SPFA</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">ZKW_SPFA</span> {</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span>
    <span class="keyword">int</span> v, nex;
    T w, c; <span class="comment">// edge wight and cost</span>
    Edge(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;_nex, <span class="keyword">const</span> T &amp;_w, <span class="keyword">const</span> T &amp;_c) \
    : v(_v), nex(_nex), w(_w), c(_c) {}
  };
  <span class="built_in">vector</span>&lt;Edge&gt; e;
  <span class="keyword">int</span> n, s, t;
  <span class="keyword">int</span> fir[N], vis[N];
  T maxflow, mincost;
  T dis[N];
  ZKW_SPFA() { e.reserve(N&lt;&lt;<span class="number">4</span>); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n)</span> </span>{
    n = _n;
    maxflow = mincost = <span class="number">0</span>;
    e.clear();
    <span class="built_in">memset</span>(fir, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> T &amp;w = <span class="number">1</span>, <span class="keyword">const</span> T &amp;c = <span class="number">0</span>)</span> </span>{
    e.emplace_back(v, fir[u], w, c); fir[u] = e.size()<span class="number">-1</span>;
    e.emplace_back(u, fir[v], <span class="number">0</span>, -c); fir[v] = e.size()<span class="number">-1</span>;
  }
  pair&lt;T, T&gt; work(const int &amp;_s, const int &amp;_t) {
    s = _s; t = <span class="keyword">_t</span>;
    <span class="keyword">while</span> (spfa()) {
      vis[t] = <span class="number">1</span>;
      <span class="keyword">while</span> (vis[t]) {
        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
        maxflow += dfs(s, INF);
      }
    }
    <span class="keyword">return</span> {maxflow, mincost};
  }
  <span class="keyword">private</span>:
  <span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>{
    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(T)*(n+<span class="number">3</span>));
    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">3</span>));
    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;
    q.push_back(t);
    dis[t] = <span class="number">0</span>;
    vis[t] = <span class="number">1</span>;
    <span class="keyword">while</span> (q.size()) {
      <span class="keyword">int</span> u = q.front(); q.pop_front();
      <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u], v; ~i; i = e[i].nex) {
        v = e[i].v;
        <span class="keyword">if</span> (!e[i^<span class="number">1</span>].w || dis[v] &lt;= dis[u]+e[i^<span class="number">1</span>].c) <span class="keyword">continue</span>;
        dis[v] = dis[u]+e[i^<span class="number">1</span>].c;
        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;
        vis[v] = <span class="number">1</span>;
        <span class="keyword">if</span> (q.size() &amp;&amp; dis[v] &lt; dis[q.front()]) q.push_front(v);
        <span class="keyword">else</span> q.push_back(v);
      }
      vis[u] = <span class="number">0</span>;
    }
    <span class="keyword">return</span> dis[s] &lt; INF;
  }
  <span class="function">T <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> T &amp;flow)</span> </span>{
    vis[u] = <span class="number">1</span>;
    <span class="keyword">if</span> (u == t || flow &lt;= <span class="number">0</span>) <span class="keyword">return</span> flow;
    T res, used = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = fir[u], v; ~i; i = e[i].nex) {
      v = e[i].v;
      <span class="keyword">if</span> (vis[v] || !e[i].w || dis[u] != dis[v]+e[i].c) <span class="keyword">continue</span>;
      res = dfs(v, min(e[i].w, flow-used));
      <span class="keyword">if</span> (!res) <span class="keyword">continue</span>;
      mincost += res*e[i].c;
      e[i].w -= res;
      e[i^<span class="number">1</span>].w += res;
      used += res;
      <span class="keyword">if</span> (used == flow) <span class="keyword">break</span>;
    }
    <span class="keyword">return</span> used;
  }
};
</code></pre>

    </div>
</div>
<h3 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h3><h3 id="全局最小割StoerWagner"><a href="#全局最小割StoerWagner" class="headerlink" title="全局最小割StoerWagner"></a>全局最小割StoerWagner</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function">T <span class="title">sw</span><span class="params">(<span class="keyword">int</span> n, T dis[N][N])</span> </span>{
  <span class="keyword">int</span> s, t;
  T res = INF;
  vector&lt;int&gt; dap(n+1, 0), ord(n+1, 0), vis;
  <span class="built_in">vector</span>&lt;T&gt; w;
  function&lt;T(<span class="keyword">int</span>)&gt; proc = [&amp;](<span class="keyword">int</span> x) {
    vis = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>);
    w = <span class="built_in">vector</span>&lt;T&gt;(n+<span class="number">1</span>, <span class="number">0</span>);
    w[<span class="number">0</span>] = <span class="number">-1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n-x+<span class="number">1</span>; ++i) {
      <span class="keyword">int</span> mx = <span class="number">0</span>;
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) {
        <span class="keyword">if</span> (!dap[j] &amp;&amp; !vis[j] &amp;&amp; w[j] &gt; w[mx]) mx = j;
      }
      vis[mx] = <span class="number">1</span>;
      ord[i] = mx;
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) {
        <span class="keyword">if</span> (!dap[j] &amp;&amp; ! vis[j]) w[j] += dis[mx][j];
      }
    }
    s = ord[n-x];
    t = ord[n-x+<span class="number">1</span>];
    <span class="keyword">return</span> w[t];
  };
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {
    res = min(res, proc(i));
    dap[t] = <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) {
      dis[s][j] += dis[t][j];
      dis[j][s] += dis[j][t];
    }
  }
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p><a href="https://www.luogu.org/problemnew/show/P3371" target="_blank" rel="noopener">弱化</a><br><a href="https://www.luogu.org/problemnew/show/P4779" target="_blank" rel="noopener">标准</a></p>
<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>略</p>
<h3 id="Dijkstra-1"><a href="#Dijkstra-1" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>邻接表+堆优化<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>{
  priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &gt;q;
  <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dis);
  dis[S] = <span class="number">0</span>;
  q.push(make_pair(<span class="number">0</span>, S));
  pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur;
  <span class="keyword">while</span>(q.size()) {
    cur = q.top(); q.pop();
    <span class="keyword">if</span>(dis[cur.second] &lt; cur.first) <span class="keyword">continue</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = fir[cur.second], to, now; i; i = nex[i]) {
      to = ver[i];
      now = cur.first+w[i];
      <span class="keyword">if</span>(now &gt;= dis[to]) <span class="keyword">continue</span>;
      dis[to] = now;
      q.push(make_pair(now, to));
    }
  }
}
</code></pre>

    </div>
</div></p>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>{
  fill(dis+<span class="number">1</span>, dis+n+<span class="number">1</span>, INT_MAX);
  dis[S] = <span class="number">0</span>;
  head = tail = <span class="number">0</span>;
  q[++tail] = S;
  <span class="keyword">while</span>(head &lt; tail) {
    <span class="keyword">int</span> cur = q[++head];
    <span class="keyword">for</span>(<span class="keyword">int</span> i = fir[cur], to, tmp; i; i = nex[i]) {
      to = ver[i];
      tmp = dis[cur]+w[i];
      <span class="keyword">if</span>(tmp &gt;= dis[to]) <span class="keyword">continue</span>;
      dis[to] = tmp;
      q[++tail] = to;
    }
  }
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="负环"><a href="#负环" class="headerlink" title="负环"></a><a href="https://www.luogu.org/problemnew/show/P3385" target="_blank" rel="noopener">负环</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="comment">// 返回true有负环,返回false没负环</span>
<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>{
  q[++tail] = <span class="number">1</span>;
  vis[<span class="number">1</span>] = <span class="number">1</span>;
  cnt[<span class="number">1</span>] = <span class="number">1</span>;
  dis[<span class="number">1</span>] = <span class="number">0</span>;
  <span class="keyword">while</span>(head &lt; tail) {
    <span class="keyword">int</span> cur = q[(++head)%Maxn];
    vis[cur] = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = fir[cur], to; i; i = nex[i]) {
      to = ver[i];
      <span class="keyword">if</span>(dis[cur]+w[i] &lt; dis[to]) {
        dis[to] = dis[cur]+w[i];
        <span class="keyword">if</span>(!vis[to]) {
          q[(++tail)%Maxn] = to;
          vis[to] = <span class="number">1</span>;
          <span class="keyword">if</span>(++cnt[to] &gt; n) <span class="keyword">return</span> <span class="literal">true</span>;
        }
      }
    }
  }
  <span class="keyword">return</span> <span class="literal">false</span>;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a><a href="https://www.luogu.org/problemnew/show/P3388" target="_blank" rel="noopener">割点</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa)</span> </span>{
  dfn[cur] = low[cur] = ++_dfn;
  <span class="keyword">int</span> child = <span class="number">0</span>;
  <span class="keyword">for</span>(<span class="keyword">auto</span> i : e[cur]) {
    <span class="keyword">if</span>(!dfn[i]) {
      child++;
      tarjan(i, fa);
      low[cur] = min(low[cur], low[i]);
      <span class="keyword">if</span>(cur != fa &amp;&amp; low[i] &gt;= dfn[cur]) flag[cur] = <span class="number">1</span>;
    }
    low[cur] = min(low[cur], dfn[i]);
  }
  <span class="keyword">if</span>(cur == fa &amp;&amp; child &gt;= <span class="number">2</span>) flag[cur] = <span class="number">1</span>;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="SCC强连通分量-Tarjan"><a href="#SCC强连通分量-Tarjan" class="headerlink" title="SCC强连通分量|Tarjan"></a><a href="https://www.luogu.com.cn/problem/P2863" target="_blank" rel="noopener">SCC强连通分量|Tarjan</a></h2><h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">int</span> _dfn, _col, _top;
<span class="keyword">int</span> dfn[N], low[N], vis[N], col[N], sta[N];

<span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u)</span> </span>{
  dfn[u] = low[u] = ++_dfn;
  vis[u] = <span class="number">1</span>;
  sta[++_top] = u;
  <span class="keyword">for</span> (<span class="keyword">int</span> v : e[u]) {
    <span class="keyword">if</span> (!dfn[v]) {
      tarjan(v);
      low[u] = min(low[u], low[v]);
    } <span class="keyword">else</span> <span class="keyword">if</span> (vis[v]) {
      low[u] = min(low[u], low[v]);
    }
  }
  <span class="keyword">if</span> (dfn[u] == low[u]) {
    ++_col;
    <span class="keyword">do</span> {
      col[sta[_top]] = _col;
      vis[sta[_top]] = <span class="number">0</span>;
    } <span class="keyword">while</span> (sta[_top--] != u);
  }
}
</code></pre>

    </div>
</div>
<h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">int</span> _dfn, _col, _top;
<span class="keyword">int</span> dfn[N], low[N], ins[N], col[N], sta[N];

<span class="class"><span class="keyword">struct</span> <span class="title">Stack_Node</span> {</span>
  <span class="keyword">int</span> u;
  <span class="keyword">int</span> edge_info;
  <span class="keyword">int</span> state;
} tarjan_stack[N];

<span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u)</span> </span>{
  <span class="keyword">static</span> <span class="keyword">int</span> stack_top;
  stack_top = <span class="number">0</span>;
  tarjan_stack[++stack_top] = {u, <span class="number">0</span>, <span class="number">0</span>};
  <span class="keyword">while</span> (stack_top) {
    <span class="keyword">bool</span> flag = <span class="literal">false</span>;
    <span class="keyword">int</span> &amp;u = tarjan_stack[stack_top].u;
    <span class="keyword">auto</span> &amp;i = tarjan_stack[stack_top].edge_info;
    <span class="keyword">switch</span> (tarjan_stack[stack_top].state) {
    <span class="keyword">case</span> <span class="number">0</span> :
    tarjan_stack[stack_top].state = <span class="number">1</span>;
    flag = <span class="literal">false</span>;
      dfn[u] = low[u] = ++_dfn;
      ins[u] = <span class="number">1</span>;
      sta[++_top] = u;
      <span class="keyword">for</span> (; i &lt; (<span class="keyword">int</span>)e[u].size(); ++i) {
<span class="meta">#<span class="meta-keyword">define</span> v e[u][i]</span>
        <span class="keyword">if</span> (!dfn[v]) {
          tarjan_stack[++stack_top] = {v, <span class="number">0</span>, <span class="number">0</span>};
    flag = <span class="literal">true</span>;
          <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">1</span> :
    flag = <span class="literal">false</span>;
          low[u] = min(low[u], low[v]);
        } <span class="keyword">else</span> <span class="keyword">if</span> (ins[v]) {
          low[u] = min(low[u], low[v]);
        }
<span class="meta">#<span class="meta-keyword">undef</span> v</span>
      }
    <span class="keyword">if</span> (flag) <span class="keyword">break</span>;
      <span class="keyword">if</span> (dfn[u] == low[u]) {
        ++_col;
        <span class="keyword">do</span> {
          col[sta[_top]] = _col;
          ins[sta[_top]] = <span class="number">0</span>;
        } <span class="keyword">while</span> (sta[_top--] != u);
      }
    --stack_top;
    }
  }
}
</code></pre>

    </div>
</div>
<h2 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a><a href="https://www.luogu.org/problemnew/show/P3387" target="_blank" rel="noopener">缩点</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>{
  dfn[u] = low[u] = ++_dfn;
  vis[u] = <span class="number">1</span>;
  sta[++top] = u;
  <span class="keyword">for</span> (<span class="keyword">int</span> v : e[u]) {
    <span class="keyword">if</span> (!dfn[v]) {
      tarjan(v);
      low[u] = min(low[u], low[v]);
    } <span class="keyword">else</span> <span class="keyword">if</span> (vis[v]) {
      low[u] = min(low[u], low[v]);
    }
  }
  <span class="keyword">if</span> (dfn[u] == low[u]) {
    w_col[++_col] = <span class="number">0</span>;
    <span class="keyword">do</span> {
      col[sta[top]] = _col;
      vis[sta[top]] = <span class="number">0</span>;
      w_col[_col] += w[sta[top]];
    } <span class="keyword">while</span> (sta[top--] != u);
  }
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">suodian</span><span class="params">()</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    <span class="keyword">if</span> (!dfn[i]) tarjan(i);
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    <span class="keyword">for</span> (<span class="keyword">int</span> j : e[i]) {
      <span class="keyword">if</span> (col[i] == col[j]) <span class="keyword">continue</span>;
      e_col[col[i]].push_back(col[j]);
    }
  }
}
</code></pre>

    </div>
</div>
<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a><a href="https://www.luogu.com.cn/problem/P4782" target="_blank" rel="noopener">2-SAT</a></h2><h3 id="SCC-Tarjan"><a href="#SCC-Tarjan" class="headerlink" title="SCC Tarjan"></a>SCC Tarjan</h3><p>$O(n+m)$<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">TWO_SAT</span> {</span> <span class="comment">// node start from 0</span>
  <span class="keyword">int</span> top, _dfn, _scc;
  <span class="keyword">int</span> dfn[N&lt;&lt;<span class="number">1</span>], low[N&lt;&lt;<span class="number">1</span>], stk[N&lt;&lt;<span class="number">1</span>], scc[N&lt;&lt;<span class="number">1</span>], res[N];
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N&lt;&lt;<span class="number">1</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    top = <span class="number">0</span>;
    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n*<span class="number">2</span>);
    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n*<span class="number">2</span>);
    <span class="built_in">memset</span>(scc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n*<span class="number">2</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n&lt;&lt;<span class="number">1</span>; ++i) <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(e[i]);
  }
  <span class="comment">// if u then v</span>
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span> </span>{
    e[u].emplace_back(v);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;uv, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;vv)</span> </span>{
    e[u&lt;&lt;<span class="number">1</span>^uv].emplace_back(v&lt;&lt;<span class="number">1</span>^vv);
  }
  <span class="comment">// pt i ==&gt; i&lt;&lt;1 &amp;&amp; i&lt;&lt;1|1 ==&gt; 0 &amp;&amp; 1</span>
  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">work</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n&lt;&lt;<span class="number">1</span>; ++i)
      <span class="keyword">if</span> (!dfn[i]) tarjan(i);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {
      <span class="keyword">if</span> (scc[i&lt;&lt;<span class="number">1</span>] == scc[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;
      res[i] = scc[i&lt;&lt;<span class="number">1</span>] &gt; scc[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
  <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u)</span> </span>{
    dfn[u] = low[u] = ++_dfn;
    stk[++top] = u;
    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;v : e[u]) {
      <span class="keyword">if</span> (!dfn[v]) {
        tarjan(v);
        low[u] = min(low[u], low[v]);
      } <span class="keyword">else</span> <span class="keyword">if</span> (!scc[v]) {
        low[u] = min(low[u], dfn[v]);
      }
    }
    <span class="keyword">if</span> (dfn[u] == low[u]) {
      ++_scc;
      <span class="keyword">do</span> {
        scc[stk[top]] = _scc;
      } <span class="keyword">while</span> (stk[top--] != u);
    }
  }
};
</code></pre>

    </div>
</div></p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>$O(nm)$<br>所求结果字典序最小<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">TWO_SAT</span> {</span>
  <span class="keyword">int</span> n, cnt;
  <span class="keyword">int</span> res[N], mem[N&lt;&lt;<span class="number">1</span>], mark[N&lt;&lt;<span class="number">1</span>];
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N&lt;&lt;<span class="number">1</span>];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n)</span> </span>{
    n = _n;
    <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n*<span class="number">2</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n&lt;&lt;<span class="number">1</span>; ++i) <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(e[i]);
  }
  <span class="comment">// if u then v</span>
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span> </span>{
    e[u].emplace_back(v);
  }
  <span class="comment">// pt i ==&gt; i&lt;&lt;1 &amp;&amp; i&lt;&lt;1|1 ==&gt; 0 &amp;&amp; 1</span>
  <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;uv, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;vv)</span> </span>{
    e[u&lt;&lt;<span class="number">1</span>|uv].emplace_back(v&lt;&lt;<span class="number">1</span>|vv);
  }
  <span class="comment">// tag 0 any 1 smallest</span>
  <span class="function"><span class="keyword">bool</span> <span class="title">work</span><span class="params">()</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {
      <span class="keyword">if</span> (mark[i&lt;&lt;<span class="number">1</span>] || mark[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]) <span class="keyword">continue</span>;
      cnt = <span class="number">0</span>;
      <span class="keyword">if</span> (!dfs(i&lt;&lt;<span class="number">1</span>)) {
        <span class="keyword">while</span> (cnt) mark[mem[cnt--]] = <span class="number">0</span>;
        <span class="keyword">if</span> (!dfs(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;
      }
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n&lt;&lt;<span class="number">1</span>; ++i) <span class="keyword">if</span> (mark[i]) res[i&gt;&gt;<span class="number">1</span>] = i&amp;<span class="number">1</span>;
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u)</span> </span>{
    <span class="keyword">if</span> (mark[u^<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span> (mark[u]) <span class="keyword">return</span> <span class="literal">true</span>;
    mark[mem[++cnt] = u] = <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> v : e[u]) <span class="keyword">if</span> (!dfs(v)) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
};
</code></pre>

    </div>
</div></p>
<h2 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a><a href="https://www.luogu.com.cn/problem/CF613D" target="_blank" rel="noopener">虚树</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ve[N];
<span class="function"><span class="keyword">void</span> <span class="title">virtual_tree_clear</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u = <span class="number">1</span>)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;v : ve[u]) virtual_tree_clear(v);
  ve[u].clear();
}

<span class="comment">// return the root of virtual tree</span>
<span class="function"><span class="keyword">int</span> <span class="title">virtual_tree_build</span><span class="params">(<span class="keyword">int</span> vset[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span> </span>{
  <span class="keyword">static</span> <span class="keyword">int</span> stk[N], top;
  <span class="comment">// id ==&gt; dfn rank, d ==&gt; depth</span>
  <span class="keyword">int</span> *id = hld.id, *d = hld.d;
  sort(vset+<span class="number">1</span>, vset+k+<span class="number">1</span>, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y) {
    <span class="keyword">return</span> id[x] &lt; id[y];
  });
  top = <span class="number">0</span>;
  <span class="keyword">int</span> x, z;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) {
    <span class="keyword">if</span> (top &amp;&amp; (z = hld.lca(vset[i], stk[top])) != stk[top]) {
      x = stk[top--];
      <span class="keyword">while</span> (top &amp;&amp; d[stk[top]] &gt; d[z]) {
        ve[stk[top]].emplace_back(x);
        x = stk[top--];
      }
      ve[z].emplace_back(x);
      <span class="keyword">if</span> (!top || stk[top] != z) stk[++top] = z;
    }
    stk[++top] = vset[i];
  }
  x = stk[top--];
  <span class="keyword">while</span> (top) {
    ve[stk[top]].emplace_back(x);
    x = stk[top--];
  }
  <span class="comment">// if (x != 1) ve[1].emplace_back(x); // force root at 1</span>
  <span class="keyword">return</span> x;
}
</code></pre>

    </div>
</div>
<h2 id="线段树优化建图"><a href="#线段树优化建图" class="headerlink" title="线段树优化建图"></a>线段树优化建图</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">SegmentTreeGarph</span> {</span>
  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> {</span>
    <span class="keyword">int</span> l, r;
    <span class="keyword">int</span> ls, rs;
  } tr[N*<span class="number">3</span>];
  <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, T&gt;&gt; *e;
  <span class="keyword">int</span> tot, root[<span class="number">2</span>];
  <span class="comment">// op [down, 0] [up, 1]</span>
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n, E *_e)</span> </span>{
    tot = n;
    e = _e;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) tr[i].l = tr[i].r = i;
    build(<span class="number">1</span>, n, root[<span class="number">0</span>], <span class="number">0</span>);
    build(<span class="number">1</span>, n, root[<span class="number">1</span>], <span class="number">1</span>);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">int</span> &amp;i, <span class="keyword">const</span> <span class="keyword">int</span> &amp;op)</span> </span>{
    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> i = l, <span class="keyword">void</span>();
    i = ++tot;
    tr[i].l = l; tr[i].r = r;
    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
    build(l, mid, tr[i].ls, op);
    build(mid+<span class="number">1</span>, r, tr[i].rs, op);
    e[op ? tr[i].ls : i].emplace_back(op ? i : tr[i].ls, <span class="number">0</span>);
    e[op ? tr[i].rs : i].emplace_back(op ? i : tr[i].rs, <span class="number">0</span>);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;o, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;w,</span></span>
<span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">int</span> &amp;op)</span> </span>{
    <span class="keyword">if</span> (l == r) e[op ? l : o].emplace_back(op ? o : l, w);
    <span class="keyword">else</span> insert(o, l, r, w, op, root[op]);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;o, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> T &amp;w,</span></span>
<span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">int</span> &amp;op, <span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span> </span>{
    <span class="keyword">if</span> (tr[i].l &gt;= l &amp;&amp; tr[i].r &lt;= r) {
      e[op ? i : o].emplace_back(op ? o : i, w);
      <span class="keyword">return</span>;
    }
    <span class="keyword">int</span> mid = (tr[i].l+tr[i].r)&gt;&gt;<span class="number">1</span>;
    <span class="keyword">if</span> (l &lt;= mid) insert(o, l, r, w, op, tr[i].ls);
    <span class="keyword">if</span> (r &gt;  mid) insert(o, l, r, w, op, tr[i].rs);
  }
};
</code></pre>

    </div>
</div>
<h3 id="最短路-1"><a href="#最短路-1" class="headerlink" title="+最短路"></a><a href="https://www.luogu.com.cn/problem/CF786B" target="_blank" rel="noopener">+最短路</a></h3><h3 id="网络流-1"><a href="#网络流-1" class="headerlink" title="+网络流"></a><a href="https://ac.nowcoder.com/acm/contest/5670/G" target="_blank" rel="noopener">+网络流</a></h3><h3 id="2-SAT-1"><a href="#2-SAT-1" class="headerlink" title="+2-SAT"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6824" target="_blank" rel="noopener">+2-SAT</a></h3><h2 id="矩阵树定理-Kirchhoff"><a href="#矩阵树定理-Kirchhoff" class="headerlink" title="矩阵树定理|Kirchhoff"></a>矩阵树定理|Kirchhoff</h2><p>解决一张图的生成树个数计数问题(详情见oi-wiki)</p>
<h2 id="斯坦纳树"><a href="#斯坦纳树" class="headerlink" title="斯坦纳树"></a>斯坦纳树</h2><p>给定连通图 $G$ 中的 $n$ 个点 $m$ 条边与 $k$ 个关键点，连接 $k$ 个关键点，使得生成树的所有边的权值和最小。</p>
<p>我们使用状态压缩动态规划来求解。用 $f(i,S)$ 表示以 $i$ 为根的一棵树，包含集合 $S$ 中所有点的最小边权值和。</p>
<h3 id="边权最小"><a href="#边权最小" class="headerlink" title="边权最小"></a>边权最小</h3><ul>
<li><p>首先对连通的子集进行转移， $f(i,S)\leftarrow \min(f(i,S),f(i,T)+f(i,S-T))$ 。</p>
</li>
<li><p>在当前的子集连通状态下进行边的松弛操作， $f(i,S)\leftarrow \min(f(i,S),f(j,S)+w(j,i))$ </p>
</li>
</ul>
<p>复杂度 $O(n\times 3^k+m\log m\times 2^k)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">int</span> dp[N][<span class="number">1</span>&lt;&lt;K];
<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; e[N]; <span class="comment">// e[u] = {w, v}</span>
priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;

<span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>{
  <span class="keyword">while</span> (q.size()) {
    <span class="keyword">int</span> ud = -q.top().first;
    <span class="keyword">int</span> u = q.top().second;
    q.pop();
    <span class="keyword">if</span> (ud &gt; dp[u][s]) <span class="keyword">continue</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v, w; i &lt; (<span class="keyword">int</span>)e[u].size(); ++i) {
      w = e[u][i].first;
      v = e[u][i].second;
      <span class="keyword">if</span> (dp[v][s] &lt;= dp[u][s]+w) <span class="keyword">continue</span>;
      dp[v][s] = dp[u][s]+w;
      q.push({-dp[v][s], v});
    }
  }
}

<span class="function"><span class="keyword">int</span> <span class="title">steiner_tree</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>{ <span class="comment">// p[] is key point</span>
  <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) dp[p[i]][<span class="number">1</span>&lt;&lt;i] = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; <span class="number">1</span>&lt;&lt;k; ++s) {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
      <span class="keyword">for</span> (<span class="keyword">int</span> t = s&amp;(s<span class="number">-1</span>); t; t = s&amp;(t<span class="number">-1</span>))
        dp[i][s] = min(dp[i][s], dp[i][s^t]+dp[i][t]);
      <span class="keyword">if</span> (dp[i][s] != INF) q.push({-dp[i][s], i});
    }
    dijkstra(s);
  }
  <span class="keyword">return</span> dp[p[<span class="number">0</span>]][(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>];
}
</code></pre>

    </div>
</div>
<h3 id="点权最小"><a href="#点权最小" class="headerlink" title="点权最小"></a>点权最小</h3><ul>
<li><p>$f(i,S)\leftarrow \min(f(i,S),f(i,T)+f(i,S-T)-a_i)$ 。由于此处合并时同一个点 $a_i$ ，会被加两次，所以减去。</p>
</li>
<li><p>$f(i,S)\leftarrow \min(f(i,S),f(j,S)+w(j,i))$ 。</p>
</li>
</ul>
<h3 id="路径输出"><a href="#路径输出" class="headerlink" title="路径输出"></a>路径输出</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> s)</span></span>{
    <span class="keyword">if</span>(!pre[u][s].second) <span class="keyword">return</span>;
    <span class="comment">// print</span>
    <span class="keyword">if</span>(pre[u][s].first == u) dfs(u, s^pre[u][s].second);
    dfs(pre[u][s].first, pre[u][s].second);
}
</code></pre>

    </div>
</div>
<h2 id="树上背包"><a href="#树上背包" class="headerlink" title="树上背包"></a><a href="https://blog.csdn.net/m0_37809890/article/details/102827056" target="_blank" rel="noopener">树上背包</a></h2><p>时间复杂度 $O(n^2)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>{
  num[u] = <span class="number">1</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> &amp;v : e[u]) {
    dfs(v);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = min(m, num[u]+num[v]); j; --j) {
      <span class="keyword">for</span> (<span class="keyword">int</span> j = max(<span class="number">0</span>, i-num[u]); j &lt;= min(num[v], i); ++j) { <span class="comment">// i-j &gt;= num[u]</span>
        dp[u][i] = max(dp[u][i], dp[u][i-j]+dp[v][j]);
      }
    }
    num[u] += num[v];
  }
}
</code></pre>

    </div>
</div>
<h2 id="仙人掌"><a href="#仙人掌" class="headerlink" title="仙人掌"></a>仙人掌</h2><p>两点之间最短路<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> Cactus {

<span class="meta">#<span class="meta-keyword">define</span> log(x) (31-__builtin_clz(x))</span>
<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;
<span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, ll&gt; pil;
<span class="keyword">const</span> <span class="keyword">int</span> NN = (<span class="keyword">int</span>)log2(N)+<span class="number">3</span>;
<span class="keyword">int</span> n, _dfn, cnt;
<span class="keyword">int</span> f[N&lt;&lt;<span class="number">1</span>][NN], dep[N&lt;&lt;<span class="number">1</span>], dfn[N], from[N];
<span class="comment">// od 为仙人掌上距离, dis 为圆方树上距离, cir 为环上边权和</span>
ll od[N], dis[N&lt;&lt;<span class="number">1</span>], cir[N];
<span class="built_in">vector</span>&lt;pil&gt; *e, ce[N&lt;&lt;<span class="number">1</span>];

<span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>{
  dfn[u] = ++_dfn;
  <span class="keyword">for</span> (<span class="keyword">const</span> pil &amp;edge : e[u]) {
    <span class="keyword">int</span> v = edge.first;
    <span class="keyword">if</span> (v == f[u][<span class="number">0</span>]) <span class="keyword">continue</span>;
    ll w = edge.second;
    <span class="keyword">if</span> (!dfn[v]) {
      f[v][<span class="number">0</span>] = u;
      dep[v] = dep[u]+<span class="number">1</span>;
      od[v] = od[u]+w;
      <span class="keyword">if</span> (!dfs(v)) <span class="keyword">return</span> <span class="literal">false</span>;
      <span class="keyword">if</span> (!from[v]) ce[u].emplace_back(v, w);
    } <span class="keyword">else</span> <span class="keyword">if</span> (dfn[v] &lt; dfn[u]) {
      cir[++cnt] = od[u]-od[v]+w;
      ce[v].emplace_back(n+cnt, <span class="number">0</span>);
      <span class="keyword">for</span> (<span class="keyword">int</span> x = u; x != v; x = f[x][<span class="number">0</span>]) {
        <span class="keyword">if</span> (from[x]) <span class="keyword">return</span> <span class="literal">false</span>;
        from[x] = cnt;
        ll ww = od[x]-od[v];
        ce[n+cnt].emplace_back(x, min(ww, cir[cnt]-ww));
      }
    }
  }
  <span class="keyword">return</span> <span class="literal">true</span>;
}
<span class="comment">// 带权倍增LCA</span>
<span class="function"><span class="keyword">void</span> <span class="title">build_lca</span><span class="params">(<span class="keyword">int</span> u)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;i) &lt;= dep[u]; ++i)
    f[u][i] = f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];
  <span class="keyword">for</span> (<span class="keyword">const</span> pil &amp;edge : ce[u]) {
    <span class="keyword">int</span> v = edge.first;
    dep[v] = dep[u]+<span class="number">1</span>;
    dis[v] = dis[u]+edge.second;
    f[v][<span class="number">0</span>] = u;
    build_lca(v);
  }
}

<span class="function"><span class="keyword">bool</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> _n, <span class="built_in">vector</span>&lt;pil&gt; *_e)</span> </span>{
  n = _n; e = _e;
  _dfn = cnt = <span class="number">0</span>;
  <span class="keyword">if</span> (!dfs(<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;
  dep[<span class="number">1</span>] = <span class="number">1</span>;
  build_lca(<span class="number">1</span>);
  <span class="keyword">return</span> <span class="literal">true</span>;
}

<span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>{
  <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);
  <span class="keyword">int</span> x = u, y = v;
  <span class="keyword">while</span> (dep[x] &gt; dep[y]) x = f[x][<span class="built_in">log</span>(dep[x]-dep[y])];
  <span class="keyword">if</span> (x == y) <span class="keyword">return</span> dis[u]-dis[v];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">log</span>(dep[x]); i &gt;= <span class="number">0</span>; --i)
    <span class="keyword">if</span>(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
  <span class="keyword">if</span> (f[x][<span class="number">0</span>] &lt;= n) <span class="keyword">return</span> dis[u]+dis[v]<span class="number">-2</span>*dis[f[x][<span class="number">0</span>]];
  ll d = <span class="built_in">abs</span>(od[x]-od[y]);
  <span class="keyword">return</span> dis[u]-dis[x]+dis[v]-dis[y]+min(d, cir[f[x][<span class="number">0</span>]-n]-d);
}

} <span class="comment">/* namespace Cactus */</span>
</code></pre>

    </div>
</div></p>
<h3 id="仙人掌DP"><a href="#仙人掌DP" class="headerlink" title="仙人掌DP"></a>仙人掌DP</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="comment">// from[i] 节点i与父亲的边所在环的编号</span>
<span class="comment">// tp[i]环i深度最小的节点编号, bm[i]环i深度最大的节点编号</span>
<span class="keyword">int</span> _dfn, cnt, fa[N], dfn[N], from[N], tp[N], bm[N];

<span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>{
  dfn[u] = ++_dfn;
  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;v : e[u]) {
    <span class="keyword">if</span> (v == fa[u]) <span class="keyword">continue</span>;
    <span class="keyword">if</span> (!dfn[v]) {
      fa[v] = u;
      dfs(v);
      <span class="comment">// dp</span>
    } <span class="keyword">else</span> <span class="keyword">if</span> (dfn[v] &lt; dfn[u]) {
      ++cnt;
      tp[cnt] = v; bm[cnt] = u;
      <span class="keyword">for</span> (<span class="keyword">int</span> x = u; x != v; x = fa[x]) {
        <span class="keyword">if</span> (from[x]) <span class="keyword">return</span> <span class="literal">false</span>;
        from[x] = cnt;
      }
    }
  }
}
</code></pre>

    </div>
</div>
<h2 id="补图DFS"><a href="#补图DFS" class="headerlink" title="补图DFS"></a>补图DFS</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> S = <span class="number">1</span>)</span> </span>{
  <span class="keyword">static</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st[<span class="number">2</span>]; <span class="comment">// 存储未访问的点</span>
  <span class="keyword">static</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;
  <span class="built_in">memset</span>(dis+<span class="number">1</span>, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);
  dis[S] = <span class="number">0</span>;
  q.push(S);
  st[<span class="number">0</span>].clear(); st[<span class="number">1</span>].clear();
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (i != S) st[<span class="number">0</span>].insert(i);
  <span class="keyword">while</span> (q.size()) {
    <span class="keyword">int</span> u = q.front();
    q.pop();
    <span class="keyword">for</span> (<span class="keyword">int</span> v : e[u]) <span class="keyword">if</span> (st[<span class="number">0</span>].count(v)) {
      st[<span class="number">0</span>].erase(v);
      st[<span class="number">1</span>].insert(v);
    }
    <span class="keyword">for</span> (<span class="keyword">auto</span> v : st[<span class="number">0</span>]) <span class="keyword">if</span> (dis[v] == <span class="number">-1</span>) {
      dis[v] = dis[u]+<span class="number">1</span>;
      q.push(v);
    }
    swap(st[<span class="number">0</span>], st[<span class="number">1</span>]);
    st[<span class="number">1</span>].clear();
  }
}
</code></pre>

    </div>
</div>
<h2 id="浅谈图模型上的随机游走问题"><a href="#浅谈图模型上的随机游走问题" class="headerlink" title="浅谈图模型上的随机游走问题"></a><a href="https://github.com/lzyrapx/Competitive-Programming-Docs/blob/master/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E5%8E%86%E5%B9%B4%E8%AE%BA%E6%96%87%E9%9B%86/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2019%E8%AE%BA%E6%96%87%E9%9B%86.pdf" target="_blank" rel="noopener">浅谈图模型上的随机游走问题</a></h2><h3 id="网格图"><a href="#网格图" class="headerlink" title="网格图"></a>网格图</h3><p>$$f(i)=<br>\begin{cases}<br>p_1f(i-1,j)+p_2f(i,j-1)+p_3f(i+1,j)+p_4f(i,j+1)+1,i^2+j^2\leq R \\<br>0,i^2+j^2&lt;R<br>\end{cases}$$</p>
<h4 id="高斯消元-O-R-6"><a href="#高斯消元-O-R-6" class="headerlink" title="高斯消元 $O(R^6)$"></a>高斯消元 $O(R^6)$</h4><h4 id="直接消元法-O-R-4"><a href="#直接消元法-O-R-4" class="headerlink" title="直接消元法 $O(R^4)$"></a>直接消元法 $O(R^4)$</h4><h4 id="主元法-O-R-3"><a href="#主元法-O-R-3" class="headerlink" title="主元法 $O(R^3)$"></a>主元法 $O(R^3)$</h4><h2 id="树分治"><a href="#树分治" class="headerlink" title="树分治"></a>树分治</h2><h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><p>按树的重心分治<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> DFZ {
<span class="keyword">int</span> vis[N], siz[N], mxs[N], cnt[K];
<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pset;

<span class="function"><span class="keyword">void</span> <span class="title">calc_size</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>{ <span class="comment">// 找重心</span>
  siz[u] = <span class="number">1</span>; mxs[u] = <span class="number">0</span>;
  pset.emplace_back(u);
  <span class="keyword">for</span> (<span class="keyword">auto</span> p : e[u]) {
    <span class="keyword">int</span> v = p.first;
    <span class="keyword">if</span> (v == fa || vis[v]) <span class="keyword">continue</span>;
    calc_size(v, u);
    siz[u] += siz[v];
    mxs[u] = max(mxs[u], siz[v]);
  }
}

<span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="keyword">if</span> (q[i] &gt;= dis) ans[i] |= cnt[q[i]-dis];
  <span class="keyword">for</span> (<span class="keyword">auto</span> p : e[u]) {
    <span class="keyword">int</span> v = p.first;
    <span class="keyword">if</span> (v == fa || vis[v]) <span class="keyword">continue</span>;
    query(v, u, dis+p.second);
  }
}

<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis, <span class="keyword">int</span> k)</span> </span>{
  <span class="keyword">if</span> (dis &lt; K) cnt[dis] += k;
  <span class="keyword">for</span> (<span class="keyword">auto</span> p : e[u]) {
    <span class="keyword">int</span> v = p.first;
    <span class="keyword">if</span> (v == fa || vis[v]) <span class="keyword">continue</span>;
    update(v, u, dis+p.second, k);
  }
}

<span class="function"><span class="keyword">void</span> <span class="title">dfz</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>)</span> </span>{
  pset.clear();
  calc_size(u);
  <span class="keyword">for</span> (<span class="keyword">int</span> v : pset) { <span class="comment">// get centre</span>
    mxs[v] = max(mxs[v], (<span class="keyword">int</span>)pset.size()-siz[v]);
    <span class="keyword">if</span> (mxs[v] &lt; mxs[u]) u = v;
  }
  cnt[<span class="number">0</span>] = <span class="number">1</span>;
  <span class="keyword">for</span> (<span class="keyword">auto</span> p : e[u]) {
    <span class="keyword">int</span> v = p.first;
    <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;
    query(v, u, p.second);
    update(v, u, p.second, <span class="number">1</span>);
  }
  update(u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>); <span class="comment">// clear</span>
  vis[u] = <span class="number">1</span>;
  <span class="keyword">for</span> (<span class="keyword">auto</span> p : e[u]) {
    <span class="keyword">int</span> v = p.first;
    <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;
    dfz(v);
  }
}
} <span class="comment">// namespace 点分治</span>
</code></pre>

    </div>
</div></p>
<h3 id="边分治"><a href="#边分治" class="headerlink" title="边分治"></a>边分治</h3><h2 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h2><h3 id="Hierholzer-算法"><a href="#Hierholzer-算法" class="headerlink" title="Hierholzer 算法"></a>Hierholzer 算法</h3><p>复杂度 $O(n+m)$</p>
<p>保存答案可以使用 stack ，因为如果找的不是回路的话必须将那一部分放在最后。</p>
<p>如 E{(1,2),(2,3),(3,4),(4,5),(5,3)}</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="built_in">vector</span>&lt;EDGE&gt; e[N];
<span class="built_in">vector</span>&lt;EDGE&gt;::iterator beg[N];
<span class="function"><span class="keyword">void</span> <span class="title">Hierholzer</span><span class="params">(<span class="keyword">int</span> u)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it = beg[u]; it != e[u].end(); ) {
    <span class="keyword">if</span> (vis[这条边]) {
      ++it;
    } <span class="keyword">else</span> {
      <span class="keyword">int</span> v = e[*it].x ^ e[*it].y ^ u;
      vis[这条边] = <span class="number">1</span>;
      ++it;
      Hierholzer(v);
    }
  }
  stk.push(u);
}
</code></pre>

    </div>
</div>
<hr>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{
  <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;
  swap(a[l], a[l+rand()%(r-l)]);
  <span class="keyword">int</span> i = l, j = r, mid = a[l];
  <span class="keyword">while</span>(i &lt; j) {
    <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= mid) --j;
    swap(a[i], a[j]);
    <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt; mid) ++i;
    swap(a[i], a[j]);
  }
  quick_sort(l, i<span class="number">-1</span>);
  quick_sort(i+<span class="number">1</span>, r);
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="求第K大数"><a href="#求第K大数" class="headerlink" title="求第K大数"></a>求第K大数</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2665" target="_blank" rel="noopener">HDOJ 2665</a><br><a href="http://poj.org/problem?id=2104" target="_blank" rel="noopener">POJ 2104</a><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">int</span> <span class="title">kth_element</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>{
  <span class="keyword">if</span>(l == r) <span class="keyword">return</span> a[l];
  swap(a[l], a[l+rand()%(r-l)]);
  <span class="keyword">int</span> mid = a[l], i = l, j = r;
  <span class="keyword">while</span>(i &lt; j) {
    <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= mid) --j;
    swap(a[i], a[j]);
    <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt; mid) ++i;
    swap(a[i], a[j]);
  }
  a[i] = mid;
  <span class="keyword">if</span>(i == k) <span class="keyword">return</span> mid;
  <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; k) <span class="keyword">return</span> kth_element(l, i<span class="number">-1</span>, k);
  <span class="keyword">else</span> <span class="keyword">return</span> kth_element(i+<span class="number">1</span>, r, k);
}
</code></pre>

    </div>
</div><br>STL (排序,无返回值)<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp">nth_element(a+<span class="number">1</span>, a+k+<span class="number">1</span>, a+n+<span class="number">1</span>);
</code></pre>

    </div>
</div></p>
<h3 id="bfprt-算法"><a href="#bfprt-算法" class="headerlink" title="bfprt 算法"></a>bfprt 算法</h3><p>目前解决TOP-K问题最有效的算法即是BFPRT算法，又称为中位数的中位数算法，最坏时间复杂度为O(n)。</p>
<hr>
<h2 id="求逆序对-归并排序"><a href="#求逆序对-归并排序" class="headerlink" title="求逆序对(归并排序)"></a><a href="https://www.luogu.org/problemnew/show/P1908" target="_blank" rel="noopener">求逆序对(归并排序)</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{
  <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;
  <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
  merge_sort(l, mid);
  merge_sort(mid+<span class="number">1</span>, r);
  <span class="keyword">int</span> i = l, j = mid+<span class="number">1</span>, k = l;
  <span class="keyword">while</span>(k &lt;= r) {
    <span class="keyword">if</span>(j &lt;= r &amp;&amp; (i &gt; mid || a[j] &lt; a[i])) {
      ans += mid-i+<span class="number">1</span>;
      b[k++] = a[j++];
    }
    <span class="keyword">else</span> b[k++] = a[i++];
  }
  <span class="built_in">memcpy</span>(a+l, b+l, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(r-l+<span class="number">1</span>));
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><p>求最大值<a href="https://www.luogu.com.cn/problem/P3812" target="_blank" rel="noopener">Luogu3812</a></p>
<p>求第k大数<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3949" target="_blank" rel="noopener">HDOJ3949</a><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">LinearBase</span> {</span>
  <span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(T)*<span class="number">8</span>, zero;
  T tot;
  <span class="built_in">vector</span>&lt;T&gt; b, rb, p;
  LinearBase(){ init(); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
    tot = zero = <span class="number">0</span>;
    b = <span class="built_in">vector</span>&lt;T&gt;(sz, <span class="number">0</span>);
    rb = p = <span class="built_in">vector</span>&lt;T&gt;();
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(TT a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    init();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) insert(a[i]);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> LinearBase xj)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i : xj.b) <span class="keyword">if</span> (i) insert(i);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T x)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> ((x&gt;&gt;i)&amp;<span class="number">1</span>) {
      <span class="keyword">if</span> (!b[i]) { b[i] = x; <span class="keyword">return</span>; }
      x ^= b[i];
    }
    zero = <span class="number">1</span>;
  }
  <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(T x)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> ((x&gt;&gt;i)&amp;<span class="number">1</span>) {
      <span class="keyword">if</span> (!b[i]) { <span class="keyword">return</span> <span class="literal">false</span>; }
      x ^= b[i];
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
  <span class="function">T <span class="title">max_xor</span><span class="params">()</span> </span>{
    T res = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)
      <span class="keyword">if</span> (~(res&gt;&gt;i)&amp;<span class="number">1</span>) res ^= b[i];
      <span class="comment">// res = max(res, res^b[i]);</span>
    <span class="keyword">return</span> res;
  }
  <span class="function">T <span class="title">min_xor</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (zero) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)
      <span class="keyword">if</span> (b[i]) <span class="keyword">return</span> b[i];
  }
  <span class="function"><span class="keyword">void</span> <span class="title">rebuild</span><span class="params">()</span> </span>{
    rb = b;
    <span class="built_in">vector</span>&lt;T&gt;().swap(p);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)
        <span class="keyword">if</span> ((rb[i]&gt;&gt;j)&amp;<span class="number">1</span>) rb[i] ^= rb[j];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)
      <span class="keyword">if</span> (rb[i]) p.emplace_back(rb[i]);
    tot = ((T)<span class="number">1</span>&lt;&lt;p.size())+zero;
  }
  <span class="function">T <span class="title">kth_min</span><span class="params">(T k)</span> </span>{
    <span class="keyword">if</span> (k &gt;= tot || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;
    <span class="keyword">if</span> (zero &amp;&amp; k == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span> (zero) --k;
    T res = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)p.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)
      <span class="keyword">if</span> ((k&gt;&gt;i)&amp;<span class="number">1</span>) res ^= p[i];
    <span class="keyword">return</span> res;
  }
  <span class="function">T <span class="title">kth_max</span><span class="params">(<span class="keyword">const</span> T &amp;k)</span> </span>{
    <span class="keyword">return</span> kth_min(tot-k);
  }
};
</code></pre>

    </div>
</div><br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6579" target="_blank" rel="noopener">前缀和线性基</a><br>vector跑贼鸡儿慢<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>
<span class="class"><span class="title">struct</span> <span class="title">PreSumLB</span> {</span>
  <span class="keyword">int</span> tot, sz = <span class="keyword">sizeof</span>(T)*<span class="number">8</span>;
  <span class="built_in">vector</span>&lt;T&gt; b[N];
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N];
  PreSumLB() { init(); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
    tot = <span class="number">0</span>;
    <span class="built_in">vector</span>&lt;T&gt;(sz, <span class="number">0</span>).swap(b[<span class="number">0</span>]);
    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(sz, <span class="number">0</span>).swap(p[<span class="number">0</span>]);
  }
  <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(T val)</span> </span>{
    <span class="keyword">int</span> pos = ++tot;
    <span class="built_in">vector</span>&lt;T&gt; &amp;bb = b[tot];
    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pp = p[tot];
    pp = p[tot<span class="number">-1</span>];
    bb = b[tot<span class="number">-1</span>];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> ((val&gt;&gt;i)&amp;<span class="number">1</span>) {
      <span class="keyword">if</span> (bb[i]) {
        <span class="keyword">if</span> (pos &gt; pp[i]) swap(pos, pp[i]), swap(val, bb[i]);
        val ^= bb[i];
      } <span class="keyword">else</span> {
        bb[i] = val;
        pp[i] = pos;
        <span class="keyword">return</span>;
      }
    }
  }
  <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span> </span>{
    T res = <span class="number">0</span>;
    <span class="built_in">vector</span>&lt;T&gt; &amp;bb = b[r];
    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pp = p[r];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)
      <span class="keyword">if</span> (pp[i] &gt;= l) res = max(res, res^bb[i]);
    <span class="keyword">return</span> res;
  }
};
</code></pre>

    </div>
</div></p>
<hr>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a><a href="https://www.luogu.org/problemnew/show/P3390" target="_blank" rel="noopener">矩阵快速幂</a></h3><h3 id="矩阵求逆"><a href="#矩阵求逆" class="headerlink" title="矩阵求逆"></a><a href="https://www.luogu.com.cn/problem/P4783" target="_blank" rel="noopener">矩阵求逆</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">struct</span> <span class="title">Martix</span> {</span>
  <span class="keyword">int</span> n, m;
  T a[N][N];
  Martix(){}
  Martix(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n) : n(_n), m(_n) { init(); }
  Martix(<span class="keyword">const</span> <span class="keyword">int</span> &amp;_n, <span class="keyword">const</span> <span class="keyword">int</span> &amp;_m) : n(_n), m(_m) { init(); }
  T* <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> &amp;i) { <span class="keyword">return</span> a[i]; }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;tag = <span class="number">0</span>)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">memset</span>(a[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(T)*(m+<span class="number">1</span>));
    <span class="keyword">if</span> (tag) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i][i] = tag;
  }
  <span class="keyword">friend</span> Martix <span class="keyword">operator</span> * (<span class="keyword">const</span> Martix &amp;m1, <span class="keyword">const</span> Martix &amp;m2) {
    <span class="function">Martix <span class="title">res</span><span class="params">(m1.n, m2.m)</span></span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= res.n; ++i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= res.m; ++j)
        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m1.m; ++k)
          res.a[i][j] = (res.a[i][j]+m1.a[i][k]*m2.a[k][j])%MOD;
    <span class="keyword">return</span> res;
  }
  Martix&amp; <span class="keyword">operator</span> *= (<span class="keyword">const</span> Martix &amp;mx) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*mx; }
  Martix&amp; <span class="keyword">operator</span> + (<span class="keyword">const</span> Martix &amp;mx) <span class="keyword">const</span> { <span class="function">Martix <span class="title">res</span><span class="params">(n, m)</span></span>; <span class="keyword">return</span> res += mx; }
  Martix&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> Martix &amp;mx) {
    assert(n == mx.n &amp;&amp; m == mx.m);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)
        a[i][j] += mx.a[i][j];
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }
  Martix&amp; <span class="keyword">operator</span> - (<span class="keyword">const</span> Martix &amp;mx) <span class="keyword">const</span> { <span class="function">Martix <span class="title">res</span><span class="params">(n, m)</span></span>; <span class="keyword">return</span> res -= mx; }
  Martix&amp; <span class="keyword">operator</span> -= (<span class="keyword">const</span> Martix &amp;mx) {
    assert(n == mx.n &amp;&amp; m == mx.m);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)
        a[i][j] -= mx.a[i][j];
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt;
  <span class="function">Martix <span class="title">pow</span><span class="params">(<span class="keyword">const</span> TT &amp;p)</span> <span class="keyword">const</span> </span>{
    Martix res(n, m), a = *this;
    res.init(<span class="number">1</span>);
    <span class="keyword">for</span> (TT i = p; i; i &gt;&gt;= <span class="number">1</span>, a *= a) <span class="keyword">if</span> (i&amp;<span class="number">1</span>) res *= a;
    <span class="keyword">return</span> res;
  }
  <span class="function">Martix <span class="title">inv</span><span class="params">()</span> <span class="keyword">const</span> </span>{
    Martix res = *<span class="keyword">this</span>;
    vector&lt;int&gt; is(n+1), js(n+1);
    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) {
      <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; ++i)
        <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;= n; ++j) <span class="keyword">if</span> (res.a[i][j]) {
          is[k] = i; js[k] = j; <span class="keyword">break</span>;
        }
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) swap(res.a[k][i], res.a[is[k]][i]);
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) swap(res.a[i][k], res.a[i][js[k]]);
      <span class="keyword">if</span> (!res.a[k][k]) <span class="keyword">return</span> Martix(<span class="number">0</span>);
      res.a[k][k] = mul_inverse(res.a[k][k]); <span class="comment">// get inv of number</span>
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (j != k)
        res.a[k][j] = res.a[k][j]*res.a[k][k]%MOD;
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (i != k)
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (j != k)
          res.a[i][j] = (res.a[i][j]+MOD-res.a[i][k]*res.a[k][j]%MOD)%MOD;
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (i != k)
        res.a[i][k] = (MOD-res.a[i][k]*res.a[k][k]%MOD)%MOD;
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k; --k) {
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) swap(res.a[js[k]][i], res.a[k][i]);
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) swap(res.a[i][is[k]], res.a[i][k]);
    }
    <span class="keyword">return</span> res;
  }
  <span class="function">T <span class="title">det</span><span class="params">()</span> </span>{
    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;
    Martix cpy = *<span class="keyword">this</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
      <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">while</span> (cpy.a[j][i]) {
        <span class="keyword">long</span> <span class="keyword">long</span> t = cpy.a[i][i]/cpy.a[j][i];
        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= n; ++k)
          cpy.a[i][k] = (cpy.a[i][k]+MOD-t*cpy.a[j][k]%MOD)%MOD;
        swap(cpy.a[i], cpy.a[j]);
        res = -res;
      }
      res = res*cpy.a[i][i]%MOD;
    }
    <span class="keyword">return</span> (res+MOD)%MOD;
  }
  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, <span class="keyword">const</span> Martix&lt;T&gt; &amp;mx) {
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx.n; ++i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mx.m; ++j)
        os &lt;&lt; mx.a[i][j] &lt;&lt; <span class="string">" \n"</span>[j==mx.m];
    <span class="keyword">return</span> os;
  }
};
</code></pre>
<h3 id="伍德伯里矩阵恒等式-Woodbury-matrix-identity"><a href="#伍德伯里矩阵恒等式-Woodbury-matrix-identity" class="headerlink" title="伍德伯里矩阵恒等式|Woodbury matrix identity"></a>伍德伯里矩阵恒等式|Woodbury matrix identity</h3><p>解决矩阵修改求逆问题 <a href="https://acm.hdu.edu.cn/showproblem.php?pid=6994" target="_blank" rel="noopener">hdoj6994</a></p>
<p>$(A+UCV)^{-1}=A^{-1}-A^{-1}U(C^{-1}+VA^{-1}U)^{-1}VA^{-1}$</p>
<p>$A\in \R^{n\times n},U\in \R^{n\times k},C\in \R^{k\times k},V\in \R^{k\times n}$</p>
<p>矩阵求逆 $O(n^3)$, 单次修改 $O(n^2)$</p>
<p>例如给矩阵 $A$ 的第 $i$ 行第 $j$ 列增加 $\Delta$ , 若 $A_{3*3}, (i,j)=(2,3)$</p>
<p>$$UCV=<br>\begin{bmatrix}<br>{0}&amp;{0}&amp;{0}\\<br>{0}&amp;{0}&amp;{\Delta}\\<br>{0}&amp;{0}&amp;{0}<br>\end{bmatrix}$$</p>
<p>则有</p>
<p>$U_{n\times 1}=\begin{bmatrix}{0}&amp;{1}&amp;{0}\end{bmatrix}^T,U_i=1$</p>
<p>$C_{1\times 1}=\begin{bmatrix}{\Delta}\end{bmatrix}$</p>
<p>$V_{1\times n}=\begin{bmatrix}{0}&amp;{0}&amp;{1}\end{bmatrix},V_j=1$</p>
<p>注意运算顺序$(A^{-1}U)(C^{-1}+VA^{-1}U)^{-1}(VA^{-1})$</p>

    </div>
</div>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a><a href="https://www.luogu.com.cn/problem/P3389" target="_blank" rel="noopener">高斯消元</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">GaussElimination</span> {</span>
  <span class="keyword">double</span> a[N][N];
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{ <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n+<span class="number">1</span>; ++j)
        a[i][j] = <span class="number">0</span>;
  }
  <span class="comment">// ans is a[i][n+1]</span>
  <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, k; i &lt;= n; ++i) {
      <span class="keyword">for</span> (j = i+<span class="number">1</span>, k = i; j &lt;= n; ++j)
        <span class="keyword">if</span> (<span class="built_in">abs</span>(a[j][i]) &gt; <span class="built_in">abs</span>(a[k][i])) k = j;
      <span class="keyword">if</span> (<span class="built_in">abs</span>(a[k][i]) &lt; eps) <span class="keyword">return</span> <span class="literal">false</span>;
      swap(a[k], a[i]);
      <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (i != j) {
        <span class="keyword">double</span> d = a[j][i]/a[i][i];
        <span class="keyword">for</span> (k = i+<span class="number">1</span>; k &lt;= n+<span class="number">1</span>; ++k)
          a[j][k] -= d*a[i][k];
      }
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i][n+<span class="number">1</span>] /= a[i][i];
    <span class="keyword">return</span> <span class="literal">true</span>;
  }
};
</code></pre>

    </div>
</div>
<h3 id="异或方程组"><a href="#异或方程组" class="headerlink" title="异或方程组"></a><a href="http://www.cppblog.com/MatoNo1/archive/2012/05/20/175404.html" target="_blank" rel="noopener">异或方程组</a></h3><p><a href="https://www.luogu.com.cn/problem/P2962" target="_blank" rel="noopener">luogu 2962</a></p>
<p>a[i][j] 第i个是否对j有影响</p>
<p>a[i][n+1] 第i个最后被翻转与否<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="comment">// -1 : no solution, 0 : multi , 1 : one</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">int</span> <span class="title">XorGauss</span><span class="params">(T a[N], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, k; i &lt;= n; ++i) {
    <span class="keyword">for</span> (k = i; !a[k][i] &amp;&amp; k &lt;= n; ++k) {}
    <span class="keyword">if</span> (k &lt;= n) swap(a[k], a[i]);
    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (i != j &amp;&amp; a[j][i])
      <span class="keyword">for</span> (k = i; k &lt;= n+<span class="number">1</span>; ++k) a[j][k] ^= a[i][k];
      <span class="comment">// a[j] ^= a[i]; // bitset&lt;N&gt; a[N]</span>
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!a[i][i] &amp;&amp; a[i][n+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">-1</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!a[i][i]) <span class="keyword">return</span> <span class="number">0</span>;
  <span class="keyword">return</span> <span class="number">1</span>;
}
<span class="comment">// dfs(n, 0)</span>
<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;num)</span> </span>{
  <span class="keyword">if</span> (num &gt;= res) <span class="keyword">return</span>;
  <span class="keyword">if</span> (u &lt;= <span class="number">0</span>) { res = num; <span class="keyword">return</span>; }
  <span class="keyword">if</span> (a[u][u]) {
    <span class="keyword">int</span> t = a[u][n+<span class="number">1</span>];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = u+<span class="number">1</span>; i &lt;= n; ++i) {
      <span class="keyword">if</span> (a[u][i]) t ^= used[i];
    }
    dfs(u<span class="number">-1</span>, num+t);
  } <span class="keyword">else</span> { <span class="comment">// 自由元</span>
    dfs(u<span class="number">-1</span>, num);
    used[u] = <span class="number">1</span>;
    dfs(u<span class="number">-1</span>, num+<span class="number">1</span>);
    used[u] = <span class="number">0</span>;
  }
}
</code></pre>

    </div>
</div></p>
<hr>
<h2 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a><a href="https://www.luogu.com.cn/problem/P4781" target="_blank" rel="noopener">拉格朗日插值</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> H, <span class="keyword">typename</span> P&gt;
<span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Largrange</span><span class="params">(<span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> H x[], <span class="keyword">const</span> P y[])</span> </span>{
  k %= MOD;
  <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>, s1 = <span class="number">1</span>, s2 = <span class="number">1</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i, s1 = s2 = <span class="number">1</span>) {
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (i != j) {
      s1 = s1*(x[i]-x[j]+MOD)%MOD;
      s2 = s2*(k-x[j]+MOD)%MOD;
    }
    res = (res+y[i]*s2%MOD*mul_inverse(s1)%MOD)%MOD;
  }
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt; <span class="comment">// x[i] = i -&gt; y[i] = f(i)</span>
<span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Largrange</span><span class="params">(<span class="keyword">const</span> T &amp;k, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n, <span class="keyword">const</span> P y[])</span> </span>{
  <span class="keyword">if</span> (k &lt;= n) <span class="keyword">return</span> y[k];
  <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> pre[N], suf[N];
  <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;
  k %= MOD;
  pre[<span class="number">0</span>] = suf[n+<span class="number">1</span>] = <span class="number">1</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = pre[i<span class="number">-1</span>]*(k-i)%MOD;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) suf[i] = suf[i+<span class="number">1</span>]*(k-i)%MOD;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    res = (res+y[i]*(pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>]%MOD)%MOD
      *mul_inverse(((n-i)&amp;<span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>)*fac[i<span class="number">-1</span>]*fac[n-i]%MOD)%MOD)%MOD;
  }
  <span class="keyword">return</span> (res+MOD)%MOD;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a><a href="https://www.luogu.org/problemnew/show/P1226" target="_blank" rel="noopener">快速幂</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> H&gt;
<span class="function"><span class="keyword">inline</span> T <span class="title">qpow</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> H &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;mo = MOD)</span> </span>{
  <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>, x = a;
  <span class="keyword">for</span> (H i = p; i; i &gt;&gt;= <span class="number">1</span>, x = x*x%mo)
    <span class="keyword">if</span> (i&amp;<span class="number">1</span>) res = res*x%mo;
  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&gt;(res);
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qmul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y, <span class="keyword">long</span> <span class="keyword">long</span> mo)</span> </span>{
  <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;
  <span class="keyword">while</span> (y) {
    <span class="keyword">if</span> (y&amp;<span class="number">1</span>) res = (res+x)%mo;
    x = (x&lt;&lt;<span class="number">1</span>)%mo;
    y &gt;&gt;= <span class="number">1</span>;
  }
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qmul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y, <span class="keyword">long</span> <span class="keyword">long</span> mo)</span> </span>{
  <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)((__int128)x*y%mo);
}
</code></pre>

    </div>
</div>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qmul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y, <span class="keyword">long</span> <span class="keyword">long</span> mo)</span> </span>{
  <span class="comment">// x*y - floor(x*y/mo)*mo</span>
  <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;
  <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;
  <span class="keyword">return</span> ((ull)x*y-(ull)((ld)x/mo*y)*mo+mo)%mo;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span> {</span>
  <span class="keyword">typedef</span> <span class="keyword">double</span> T; <span class="comment">// maybe long double ?</span>
  T real, imag;
  comp (<span class="keyword">const</span> <span class="keyword">double</span> &amp;_real = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">double</span> &amp;_imag = <span class="number">0</span>) : real(_real), imag(_imag) {}
  <span class="keyword">friend</span> comp <span class="keyword">operator</span> + (<span class="keyword">const</span> comp &amp;c1, <span class="keyword">const</span> comp &amp;c2) { <span class="keyword">return</span> comp(c1.real+c2.real, c1.imag+c2.imag); }
  <span class="keyword">friend</span> comp <span class="keyword">operator</span> - (<span class="keyword">const</span> comp &amp;c1, <span class="keyword">const</span> comp &amp;c2) { <span class="keyword">return</span> comp(c1.real-c2.real, c1.imag-c2.imag); }
  <span class="keyword">friend</span> comp <span class="keyword">operator</span> * (<span class="keyword">const</span> comp &amp;c1, <span class="keyword">const</span> comp &amp;c2) { <span class="keyword">return</span> comp(c1.real*c2.real-c1.imag*c2.imag, c1.real*c2.imag+c1.imag*c2.real); }
  comp&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> comp &amp;c) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+c; }
  comp&amp; <span class="keyword">operator</span> -= (<span class="keyword">const</span> comp &amp;c) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>-c; }
  comp&amp; <span class="keyword">operator</span> *= (<span class="keyword">const</span> comp &amp;c) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*c; }
  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;is, comp &amp;c) { <span class="keyword">return</span> is &gt;&gt; c.real &gt;&gt; c.imag; }
  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, comp &amp;c) { <span class="keyword">return</span> os &lt;&lt; c.real &lt;&lt; setiosflags(ios::showpos) &lt;&lt; c.imag &lt;&lt; <span class="string">"i"</span>;}
  <span class="function">comp <span class="title">conjugate</span><span class="params">()</span> </span>{ <span class="keyword">return</span> comp(real, -imag); }
  <span class="function"><span class="keyword">friend</span> comp <span class="title">conjugate</span><span class="params">(<span class="keyword">const</span> comp &amp;c)</span> </span>{ <span class="keyword">return</span> comp(c.real, -c.imag); }
};
</code></pre>

    </div>
</div>
<hr>
<h2 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换|FFT"></a><a href="https://www.luogu.com.cn/problem/P3803" target="_blank" rel="noopener">快速傅里叶变换|FFT</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> FFT { <span class="comment">// array [0, n)</span>
<span class="keyword">const</span> <span class="keyword">int</span> SIZE = (<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">3</span>;
<span class="keyword">int</span> len, bit;
<span class="keyword">int</span> rev[SIZE];
<span class="comment">// #define comp complex&lt;long double&gt;</span>
<span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(comp a[], <span class="keyword">int</span> flag = <span class="number">1</span>)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)
    <span class="keyword">if</span> (i &lt; rev[i]) swap(a[i], a[rev[i]]);
  <span class="keyword">for</span> (<span class="keyword">int</span> base = <span class="number">1</span>; base &lt; len; base &lt;&lt;= <span class="number">1</span>) {
    comp w, wn = {<span class="built_in">cos</span>(PI/base), flag*<span class="built_in">sin</span>(PI/base)};
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += base*<span class="number">2</span>) {
      w = { <span class="number">1.0</span>, <span class="number">0.0</span> };
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; ++j) {
        comp x = a[i+j], y = w*a[i+j+base];
        a[i+j] = x+y;
        a[i+j+base] = x-y;
        w *= wn;
      }
    }
  }
}
<span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(comp f[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n, comp g[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;m)</span> </span>{
  len = <span class="number">1</span>; bit = <span class="number">0</span>;
  <span class="keyword">while</span> (len &lt; n+m) len &lt;&lt;= <span class="number">1</span>, ++bit;
  <span class="comment">// multi-testcase</span>
  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) f[i] = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; len; ++i) g[i] = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)
    rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(bit<span class="number">-1</span>));
  fft(f, <span class="number">1</span>); fft(g, <span class="number">1</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i] *= g[i];
  fft(f, <span class="number">-1</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+m; ++i) f[i].real /= len;
}
} <span class="comment">// namespace FFT</span>
<span class="comment">/*</span>
<span class="comment">  template &lt;class T&gt;</span>
<span class="comment">  void work(T a[], const int &amp;n) {</span>
<span class="comment">    static comp f[SIZE];</span>
<span class="comment">    len = 1; bit = 0;</span>
<span class="comment">    while (len &lt; n+n) len &lt;&lt;= 1, ++bit;</span>
<span class="comment">    // multi-testcase</span>
<span class="comment">    for (int i = 0; i &lt; n; ++i) f[i] = a[i];</span>
<span class="comment">    for (int i = n; i &lt; len; ++i) f[i] = 0;</span>
<span class="comment">    for (int i = 0; i &lt; len; ++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1));</span>
<span class="comment">    fft(f, 1);</span>
<span class="comment">    for (int i = 0; i &lt;= len; ++i) f[i] *= f[i];</span>
<span class="comment">    fft(f, -1);</span>
<span class="comment">    for (int i = 0; i &lt; n+n; ++i) a[i] = static_cast&lt;T&gt;(f[i].real/len+.5);</span>
<span class="comment">  }</span>
<span class="comment">  */</span>
</code></pre>

    </div>
</div>
<hr>
<h2 id="快速数论变换-NTT"><a href="#快速数论变换-NTT" class="headerlink" title="快速数论变换|NTT"></a>快速数论变换|NTT</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> NTT { <span class="comment">// array [0, n)</span>
<span class="keyword">const</span> <span class="keyword">int</span> SIZE = (<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">3</span>;
<span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;
<span class="keyword">int</span> len, bit;
<span class="keyword">int</span> rev[SIZE];
<span class="keyword">long</span> <span class="keyword">long</span> f[SIZE], g[SIZE];
<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>
<span class="class"><span class="title">void</span> <span class="title">ntt</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">flag</span> = 1) {</span>
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)
    <span class="keyword">if</span> (i &lt; rev[i]) swap(a[i], a[rev[i]]);
  <span class="keyword">for</span> (<span class="keyword">int</span> base = <span class="number">1</span>; base &lt; len; base &lt;&lt;= <span class="number">1</span>) {
    <span class="keyword">long</span> <span class="keyword">long</span> wn = qpow(G, (MOD<span class="number">-1</span>)/(base*<span class="number">2</span>)), w;
    <span class="keyword">if</span> (flag == <span class="number">-1</span>) wn = qpow(wn, MOD<span class="number">-2</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += base*<span class="number">2</span>) {
      w = <span class="number">1</span>;
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; ++j) {
        <span class="keyword">long</span> <span class="keyword">long</span> x = a[i+j], y = w*a[i+j+base]%MOD;
        a[i+j] = (x+y)%MOD;
        a[i+j+base] = (x-y+MOD)%MOD;
        w = w*wn%MOD;
      }
    }
  }
}
<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>
<span class="class"><span class="title">void</span> <span class="title">work</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">n</span>, <span class="title">T</span> <span class="title">b</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">m</span>) {</span>
  len = <span class="number">1</span>; bit = <span class="number">0</span>;
  <span class="keyword">while</span> (len &lt; n+m) len &lt;&lt;= <span class="number">1</span>, ++bit;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = a[i];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) f[i] = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) g[i] = b[i];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; len; ++i) g[i] = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)
    rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(bit<span class="number">-1</span>));
  ntt(f, <span class="number">1</span>); ntt(g, <span class="number">1</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i] = f[i]*g[i]%MOD;
  ntt(f, <span class="number">-1</span>);
  <span class="keyword">long</span> <span class="keyword">long</span> inv = qpow(len, MOD<span class="number">-2</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+m<span class="number">-1</span>; ++i) f[i] = f[i]*inv%MOD;
}
} <span class="comment">// namespace NTT</span>
</code></pre>

    </div>
</div>
<h2 id="任意模数NTT-MTT"><a href="#任意模数NTT-MTT" class="headerlink" title="任意模数NTT|MTT"></a><a href="https://www.luogu.com.cn/problem/P4245" target="_blank" rel="noopener">任意模数NTT|MTT</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> MTT {
<span class="keyword">const</span> <span class="keyword">int</span> SIZE = (<span class="number">1</span>&lt;&lt;<span class="number">18</span>)+<span class="number">7</span>;
<span class="keyword">const</span> <span class="keyword">int</span> Mod = MOD;
comp w[SIZE];
<span class="keyword">int</span> bitrev[SIZE];
<span class="keyword">long</span> <span class="keyword">long</span> f[SIZE];
<span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(comp *a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (i &lt; bitrev[i]) swap(a[i], a[bitrev[i]]);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, lyc = n &gt;&gt; <span class="number">1</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>, lyc &gt;&gt;= <span class="number">1</span>)
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += i) {
      comp *l = a + j, *r = a + j + (i &gt;&gt; <span class="number">1</span>), *p = w;
      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i&gt;&gt;<span class="number">1</span>; ++k) {
        comp tmp = *r * *p;
        *r = *l - tmp, *l = *l + tmp;
        ++l, ++r, p += lyc;
      }
    }
}
<span class="comment">// 定义在函数内static Compilation Error: "Compiled file is too large" </span>
comp a[SIZE], b[SIZE];
comp dfta[SIZE], dftb[SIZE];
<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>
<span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">work</span>(<span class="title">T</span> *<span class="title">x</span>, <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">n</span>, <span class="title">T</span> *<span class="title">y</span>, <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">m</span>) {</span>
  <span class="keyword">static</span> <span class="keyword">int</span> bit, L;

  <span class="keyword">for</span> (L = <span class="number">1</span>, bit = <span class="number">0</span>; L &lt; n+m<span class="number">-1</span>; ++bit, L &lt;&lt;= <span class="number">1</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; ++i) bitrev[i] = bitrev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span> | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; ++i) w[i] = comp(<span class="built_in">cos</span>(<span class="number">2</span> * PI * i / L), <span class="built_in">sin</span>(<span class="number">2</span> * PI * i / L));

  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) (x[i] += Mod) %= Mod, a[i] = comp(x[i] &amp; <span class="number">32767</span>, x[i] &gt;&gt; <span class="number">15</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; L; ++i) a[i] = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) (y[i] += Mod) %= Mod, b[i] = comp(y[i] &amp; <span class="number">32767</span>, y[i] &gt;&gt; <span class="number">15</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; L; ++i) b[i] = <span class="number">0</span>;
  fft(a, L), fft(b, L);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; ++i) {
    <span class="keyword">int</span> j = (L - i) &amp; (L - <span class="number">1</span>);
    <span class="keyword">static</span> comp da, db, dc, dd;
    da = (a[i] + conjugate(a[j])) * comp(<span class="number">.5</span>, <span class="number">0</span>);
    db = (a[i] - conjugate(a[j])) * comp(<span class="number">0</span>, <span class="number">-.5</span>);
    dc = (b[i] + conjugate(b[j])) * comp(<span class="number">.5</span>, <span class="number">0</span>);
    dd = (b[i] - conjugate(b[j])) * comp(<span class="number">0</span>, <span class="number">-.5</span>);
    dfta[j] = da*dc + da*dd*comp(<span class="number">0</span>, <span class="number">1</span>);
    dftb[j] = db*dc + db*dd*comp(<span class="number">0</span>, <span class="number">1</span>);
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; ++i) a[i] = dfta[i];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; ++i) b[i] = dftb[i];
  fft(a, L), fft(b, L);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; ++i) {
    <span class="keyword">int</span> da = (<span class="keyword">long</span> <span class="keyword">long</span>)(a[i].real / L + <span class="number">0.5</span>) % Mod;
    <span class="keyword">int</span> db = (<span class="keyword">long</span> <span class="keyword">long</span>)(a[i].imag / L + <span class="number">0.5</span>) % Mod;
    <span class="keyword">int</span> dc = (<span class="keyword">long</span> <span class="keyword">long</span>)(b[i].real / L + <span class="number">0.5</span>) % Mod;
    <span class="keyword">int</span> dd = (<span class="keyword">long</span> <span class="keyword">long</span>)(b[i].imag / L + <span class="number">0.5</span>) % Mod;
    f[i] = (da + ((<span class="keyword">long</span> <span class="keyword">long</span>)(db + dc) &lt;&lt; <span class="number">15</span>) + ((<span class="keyword">long</span> <span class="keyword">long</span>)dd &lt;&lt; <span class="number">30</span>)) % Mod;
  }
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+m<span class="number">-1</span>; ++i) (f[i] += Mod) %= Mod;
}
} <span class="comment">// namespace MTT</span>

</code></pre>

    </div>
</div>
<h2 id="分治FFT"><a href="#分治FFT" class="headerlink" title="分治FFT"></a><a href="https://www.luogu.com.cn/problem/P4721" target="_blank" rel="noopener">分治FFT</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="comment">// give g[1, n) ask f[0, n)</span>
<span class="comment">// f[i] = sigma f[i-j]*g[j] (1 &lt;= j &lt;= i)</span>
<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; // [<span class="title">l</span>, <span class="title">r</span>]</span>
<span class="class"><span class="title">void</span> <span class="title">cdq_fft</span>(<span class="title">T</span> <span class="title">f</span>[], <span class="title">T</span> <span class="title">g</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">l</span>, <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">r</span>) {</span>
  <span class="keyword">if</span> (r-l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;
  <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;
  cdq_fft(f, g, l, mid);
  NTT::work(f+l, mid-l, g, r-l);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt; r; ++i)
    (f[i] += NTT::f[i-l]) %= MOD;
  cdq_fft(f, g, mid, r);
}
<span class="comment">// f[0] = 1; cdq_fft(f, g, 0, n);</span>
</code></pre>

    </div>
</div>
<h2 id="快速沃尔什变换-FWT"><a href="#快速沃尔什变换-FWT" class="headerlink" title="快速沃尔什变换|FWT"></a>快速沃尔什变换|FWT</h2><p><a href="https://www.luogu.com.cn/blog/command-block/wei-yun-suan-juan-ji-yu-ji-kuo-zhan" target="_blank" rel="noopener">推导详解</a></p>
<p><a href="https://www.cnblogs.com/GavinZheng/p/11721127.html" target="_blank" rel="noopener">公式参考</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4717" target="_blank" rel="noopener">洛谷例题</a></p>
<p>复杂度 $O(n\log n) | O(n2^n)$</p>
<p>$FWT(A\pm B)=FWT(A)\pm FWT(B)$</p>
<p>$FWT(cA)=cFWT(A)$</p>
<p>定义 $\bigoplus$ 为任意集合运算</p>
<p>$FWT(A\bigoplus B)=FWT(A)\times FWT(B)$</p>
<p>求 $C_i = \sum\limits_{i=j\bigoplus k}{a_j b_k}$</p>
<h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><p>$FWT(A)[i] = \sum\limits_{j|i=i}{A[j]}$</p>
<p>$FWT(A) = [FWT(A_0),FWT(A_0+A_1)]$</p>
<p>$IFWT(A) = [IFWT(A_0),IFWT(A_1)-IFWT(A_0)]$</p>
<h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><p>$FWT(A)[i] = \sum\limits_{i\&amp;j=j}{A[j]}$</p>
<p>$FWT(A) = [FWT(A_0+A_1),FWT(A_1)]$</p>
<p>$IFWT(A) = [IFWT(A_0)-IFWT(A_1),IFWT(A_1)]$</p>
<h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><p>令 $d(x)$ 为 $x$ 在二进制下拥有的1的数量</p>
<p>$FWT(A)[i] = \sum\limits_{j}(-1)^{d(i\&amp;j)}A[j]$</p>
<p>$FWT(A) = [FWT(A_0+A_1),FWT(A_0-A_1)]$</p>
<p>$IFWT(A) = [\frac{IFWT(A_1-A_0)}{2},\frac{IFWT(A_1+A_0)}{2}]$</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> FWT {
<span class="meta">#<span class="meta-keyword">define</span> forforfor for (int l = 2; l &lt;= len; l &lt;&lt;= 1)\</span>
                  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = l&gt;&gt;<span class="number">1</span>; i &lt; len; i += l)\
                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)

  <span class="keyword">const</span> <span class="keyword">int</span> SIZE = (<span class="number">1</span>&lt;&lt;<span class="number">17</span>)+<span class="number">3</span>;
  <span class="keyword">int</span> len;
  <span class="keyword">int</span> f[SIZE], g[SIZE];
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">init</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">n</span>, <span class="title">T</span> <span class="title">b</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">m</span>) {</span>
    len = <span class="number">1</span>;
    <span class="keyword">while</span> (len &lt; max(n, m)) len &lt;&lt;= <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = a[i];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; ++i) f[i] = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) g[i] = b[i];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; len; ++i) g[i] = <span class="number">0</span>;
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">fwt_or</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> <span class="title">x</span> = 1) {</span>
    forforfor a[i+j+k] = (a[i+j+k]+<span class="number">1l</span>l*a[i+j]*x)%MOD;
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">fwt_and</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> <span class="title">x</span> = 1) {</span>
    forforfor a[i+j] = (a[i+j]+<span class="number">1l</span>l*a[i+j+k]*x)%MOD;
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">fwt_xor</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> <span class="title">x</span> = 1) {</span>
    forforfor {
      (a[i+j] += a[i+j+k]) %= MOD;
      a[i+j+k] = (a[i+j]<span class="number">-2</span>*a[i+j+k]%MOD+MOD)%MOD;
      a[i+j] = <span class="number">1l</span>l*a[i+j]*x%MOD; a[i+j+k] = <span class="number">1l</span>l*a[i+j+k]*x%MOD;
    }
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">work_or</span>(<span class="title">const</span> <span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">n</span>, <span class="title">const</span> <span class="title">T</span> <span class="title">b</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">m</span>) {</span>
    init(a, n, b, m); fwt_or(f); fwt_or(g);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i] = <span class="number">1l</span>l*f[i]*g[i]%MOD;
    fwt_or(f, MOD<span class="number">-1</span>); <span class="comment">// fwt_or(x, -1)</span>
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">work_and</span>(<span class="title">const</span> <span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">n</span>, <span class="title">const</span> <span class="title">T</span> <span class="title">b</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">m</span>) {</span>
    init(a, n, b, m); fwt_and(f); fwt_and(g);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i] = <span class="number">1l</span>l*f[i]*g[i]%MOD;
    fwt_and(f, MOD<span class="number">-1</span>); <span class="comment">// fwt_and(x, -1)</span>
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">work_xor</span>(<span class="title">const</span> <span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">n</span>, <span class="title">const</span> <span class="title">T</span> <span class="title">b</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">m</span>) {</span>
    init(a, n, b, m); fwt_xor(f); fwt_xor(g);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i] = <span class="number">1l</span>l*f[i]*g[i]%MOD;
    fwt_xor(f, mul_inverse(<span class="number">2</span>)); <span class="comment">// fwt_xor(x, 1/2)</span>
  }
<span class="meta">#<span class="meta-keyword">undef</span> forforfor</span>
} <span class="comment">// namespace FWT</span>
</code></pre>

    </div>
</div>
<h2 id="快速莫比乌斯变换-FMT"><a href="#快速莫比乌斯变换-FMT" class="headerlink" title="快速莫比乌斯变换|FMT"></a>快速莫比乌斯变换|FMT</h2><p>据说 FWT 做的事情完全包含 FMT 且常数是一半(咕之</p>
<h2 id="快速子集变换-子集卷积-FST"><a href="#快速子集变换-子集卷积-FST" class="headerlink" title="快速子集变换(子集卷积)|FST"></a>快速子集变换(子集卷积)|FST</h2><p>$C_k = \sum\limits_{i\&amp;j=0,i|j=k}{A_i B_j}$</p>
<p>复杂度 $O(n\log^2 n) | O(n^22^n)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> FST {
  <span class="keyword">const</span> <span class="keyword">int</span> W = <span class="number">20</span>;
  <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span>&lt;&lt;W;
  <span class="keyword">int</span> len, bit;
  <span class="keyword">int</span> f[W+<span class="number">1</span>][N], g[W+<span class="number">1</span>][N], h[W+<span class="number">1</span>][N], res[N];
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">fwt</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> <span class="title">x</span> = 1) {</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= len; l &lt;&lt;= <span class="number">1</span>)
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = l&gt;&gt;<span class="number">1</span>; i &lt; len; i += l)
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)
      a[i+j+k] = (a[i+j+k]+<span class="number">1l</span>l*a[i+j]*x)%MOD;
  }
  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">work</span>(<span class="title">const</span> <span class="title">T</span> <span class="title">a</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">n</span>, <span class="title">const</span> <span class="title">T</span> <span class="title">b</span>[], <span class="title">const</span> <span class="title">int</span> &amp;<span class="title">m</span>) {</span>
    len = <span class="number">1</span>; bit = <span class="number">0</span>;
    <span class="keyword">while</span> (len &lt; max(n, m)) len &lt;&lt;= <span class="number">1</span>, ++bit;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i)
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j)
        f[i][j] = g[i][j] = h[i][j] = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[__builtin_popcount(i)][i] = a[i];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) g[__builtin_popcount(i)][i] = b[i];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= bit; ++i) {
      fwt(f[i]); fwt(g[i]);
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)
        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k)
          h[i][k] = (h[i][k]+<span class="number">1l</span>l*f[j][k]*g[i-j][k])%MOD;
      fwt(h[i], MOD<span class="number">-1</span>); <span class="comment">// fwt(h[i], -1)</span>
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) res[i] = h[__builtin_popcount(i)][i];
  }
} <span class="comment">// namespace FST</span>
</code></pre>

    </div>
</div>
<h3 id="分治FWT"><a href="#分治FWT" class="headerlink" title="分治FWT"></a>分治FWT</h3><p>形同分治FFT</p>
<h3 id="倍增子集卷积"><a href="#倍增子集卷积" class="headerlink" title="倍增子集卷积"></a>倍增子集卷积</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6851" target="_blank" rel="noopener">hdu6851</a></p>
<p>设多项式 $A = \sum\limits_{i=0}^{2^n-1}{a_i x^i},B=\sum\limits_{i=0}^{2^n-1}{b_i x^i}$</p>
<p>求 $C = A*B = \sum\limits_{i=0}^{2^n-1}{x^i \sum\limits_{d\subseteq i}{a_d b_{i-d} }}$</p>
<p>按照每个状态的最高位进行分组，然后卷 $n$ 次</p>
<p>复杂度 $O(\sum\limits_{i=1}^{n}{i^2 2^i}) = O(n^2 2^n)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">vip_fst</span><span class="params">(T a[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{ <span class="comment">// return a</span>
  <span class="keyword">static</span> <span class="keyword">int</span> b[<span class="number">1</span>&lt;&lt;B]; <span class="comment">// warning: the type of b</span>
  <span class="keyword">int</span> len = <span class="number">1</span>; <span class="keyword">while</span> (len &lt; n) len &lt;&lt;= <span class="number">1</span>;
  <span class="built_in">memcpy</span>(b, a, <span class="keyword">sizeof</span>(T)*len);
  <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(T)*len); a[<span class="number">0</span>] = <span class="number">1</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i &lt;&lt;= <span class="number">1</span>) {
    FST::work(a, i, b+i, i);
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)
      a[i+j] = FST::h[__builtin_popcount(j)][j];
  }
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a><a href="https://www.luogu.com.cn/problem/P5395" target="_blank" rel="noopener">第二类斯特林数</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">stirling</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
  S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;
  <span class="comment">// 注意取模</span>
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)
      S[i][j] = S[i<span class="number">-1</span>][j<span class="number">-1</span>]+S[i<span class="number">-1</span>][j]*j;
}
</code></pre>

    </div>
</div>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">stirling</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
  inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;
  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)
    inv[i] = MOD-MOD/i*inv[MOD%i]%MOD;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
    inv[i] = inv[i<span class="number">-1</span>]*inv[i]%MOD;
  <span class="keyword">while</span> (len &lt;= (n&lt;&lt;<span class="number">1</span>)) len &lt;&lt;= <span class="number">1</span>, ++bit;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)
    rev[i] = (rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(bit<span class="number">-1</span>));
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, one = <span class="number">1</span>; i &lt;= n; ++i, one = MOD-one) {
    f[i] = one*inv[i]%MOD;
    g[i] = qpow(i, n)*inv[i]%MOD;
  }
  NTT(f, <span class="number">1</span>); NTT(g, <span class="number">1</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) f[i] = f[i]*g[i]%MOD;
  NTT(f, <span class="number">-1</span>);
  <span class="keyword">long</span> <span class="keyword">long</span> invv = qpow(len, MOD<span class="number">-2</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)
    <span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, f[i]*invv%MOD, <span class="string">" \n"</span>[i==n]);
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><h3 id="O-n-1"><a href="#O-n-1" class="headerlink" title="O(n)"></a><a href="https://blog.csdn.net/weixin_42659809/article/details/82596676" target="_blank" rel="noopener">O(n)</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> v)</span> </span>{ <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">0</span> : (solve(n<span class="number">-1</span>, v)+v)%n; }
<span class="comment">// res = solve(num, step)+1</span>
</code></pre>

    </div>
</div>
<hr>
<h2 id="最大公因数-gcd"><a href="#最大公因数-gcd" class="headerlink" title="最大公因数 gcd"></a>最大公因数 gcd</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp">__gcd(a, b); <span class="comment">// &lt;algorithm&gt;</span>
<span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ <span class="keyword">return</span> b ? gcd(b, a%b) : a; }
<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ <span class="keyword">while</span> (b) a %= b, swap(a, b); <span class="keyword">return</span> a; }
</code></pre>

    </div>
</div>
<h2 id="最小公倍数-lcm"><a href="#最小公倍数-lcm" class="headerlink" title="最小公倍数 lcm"></a>最小公倍数 lcm</h2><p>$LCM(\frac{a}{b},\frac{c}{d})=\frac{LCM(a, c)}{GCD(b,d)}$</p>
<p>$LCM(\frac{a_1}{b_1},\frac{a_2}{b_2},…)=\frac{LCM(a1, a2,…)}{GCD(b1, b2,…)}$<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{ <span class="keyword">return</span> a/gcd(a, b)*b; }
</code></pre>

    </div>
</div></p>
<h2 id="扩展欧几里得-同余方程"><a href="#扩展欧几里得-同余方程" class="headerlink" title="扩展欧几里得(同余方程)"></a>扩展欧几里得(<a href="https://www.luogu.org/problemnew/show/P1082" target="_blank" rel="noopener">同余方程</a>)</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function">T <span class="title">exgcd</span><span class="params">(<span class="keyword">const</span> T a, <span class="keyword">const</span> T b, T &amp;x, T &amp;y)</span> </span>{
  <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;
  T d = exgcd(b, a%b, y, x);
  y -= a/b*x;
  <span class="keyword">return</span> d;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a><a href="https://www.luogu.org/problemnew/show/P3811" target="_blank" rel="noopener">乘法逆元</a></h2><h3 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">inline</span> T <span class="title">mul_inverse</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;mo = MOD)</span> </span>{
  T x, y;
  exgcd(a, mo, x, y);
  <span class="keyword">return</span> (x%mo+mo)%mo;
}
</code></pre>

    </div>
</div>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">inline</span> T <span class="title">mul_inverse</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;mo = MOD)</span> </span>{
  <span class="keyword">return</span> qpow(a, mo<span class="number">-2</span>);
}
</code></pre>

    </div>
</div>
<h3 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul_inverse</span><span class="params">(T *inv, <span class="keyword">int</span> mod = MOD)</span> </span>{
  inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;
  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)
    inv[i] = <span class="number">1l</span>l*(mod-mod/i)*inv[mod%i]%mod;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a><a href="https://blog.csdn.net/niiick/article/details/80229217" target="_blank" rel="noopener">中国剩余定理</a></h2><h3 id="中国剩余定理CRT-m互质"><a href="#中国剩余定理CRT-m互质" class="headerlink" title="中国剩余定理CRT(m互质)"></a><a href="https://www.luogu.org/problem/P3868" target="_blank" rel="noopener">中国剩余定理CRT(m互质)</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m[])</span> </span>{
  <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>, M = <span class="number">1</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
    M *= m[i];
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
    res = (res + a[i]*(M/m[i])*mul_inverse(M/m[i], m[i]))%M;
  <span class="keyword">return</span> (res+M)%M;
}
</code></pre>

    </div>
</div>
<h3 id="扩展中国剩余定理EXCRT-m不互质"><a href="#扩展中国剩余定理EXCRT-m不互质" class="headerlink" title="扩展中国剩余定理EXCRT(m不互质)"></a><a href="https://www.luogu.org/problem/P4777" target="_blank" rel="noopener">扩展中国剩余定理EXCRT(m不互质)</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">EXCRT</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a[], <span class="keyword">long</span> <span class="keyword">long</span> m[])</span> </span>{
  <span class="comment">// M*x + m[i]*y = a[i]-res (mod m[i])</span>
  <span class="comment">// res = res+x*M;</span>
  <span class="keyword">long</span> <span class="keyword">long</span> M = m[<span class="number">1</span>], res = a[<span class="number">1</span>], x, y, c, d;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) {
    d = exgcd(M, m[i], x, y);
    c = (a[i]-res%m[i]+m[i])%m[i];
    <span class="keyword">if</span> (c%d != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;
    x = (c/d)*x%(m[i]/d);
    res += x*M;
    M *= m[i]/d;
    res = (res%M+M)%M;
  }
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Combination</span> {</span>
  <span class="keyword">int</span> fac[N], inv[N];
  Combination() {init(N<span class="number">-1</span>); }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = fac[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) {
      fac[i] = <span class="number">1l</span>l*fac[i<span class="number">-1</span>]*i%MOD;
      inv[i] = <span class="number">1l</span>l*(MOD-MOD/i)*inv[MOD%i]%MOD;
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) {
      inv[i] = <span class="number">1l</span>l*inv[i]*inv[i<span class="number">-1</span>]%MOD;
    }
  }
  <span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;q)</span> </span>{
    <span class="keyword">return</span> p &gt;= q ? <span class="number">1l</span>l*fac[p]*inv[p-q]%MOD : <span class="number">0</span>;
  }
  <span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;q)</span> </span>{
    <span class="keyword">return</span> p &gt;= q ? <span class="number">1l</span>l*fac[p]*inv[q]%MOD*inv[p-q]%MOD : <span class="number">0</span>;
  }
};
</code></pre>

    </div>
</div>
<h3 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a><a href="https://blog.csdn.net/baodream/article/details/77822072" target="_blank" rel="noopener">奇偶性</a></h3><p>C(n,k) 当 <code>n&amp;k == k</code> 为奇数反之偶数</p>
<hr>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">phi</span><span class="params">(T x)</span> </span>{
  T res = x;
  <span class="keyword">for</span> (T i = <span class="number">2</span>; i*i &lt;= x; ++i) {
    <span class="keyword">if</span> (x%i) <span class="keyword">continue</span>;
    res = res/i*(i<span class="number">-1</span>);
    <span class="keyword">while</span> (x%i == <span class="number">0</span>) x /= i;
  }
  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res/x*(x<span class="number">-1</span>);
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div>
<h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Euler</span> {</span>
  <span class="keyword">int</span> phi[N], check[N];
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; ++i) check[i] = <span class="number">1</span>;
    phi[<span class="number">1</span>] = <span class="number">1</span>; check[<span class="number">1</span>] = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sz; ++i) {
      <span class="keyword">if</span> (check[i]) {
        prime.emplace_back(i);
        phi[i] = i<span class="number">-1</span>;
      }
      <span class="keyword">for</span> (<span class="keyword">int</span> j : prime) {
        <span class="keyword">if</span> (i*j &gt; sz) <span class="keyword">break</span>;
        check[i*j] = <span class="number">0</span>;
        <span class="keyword">if</span> (i%j) {
          phi[i*j] = (j<span class="number">-1</span>)*phi[i];
        } <span class="keyword">else</span> {
          phi[i*j] = j*phi[i];
          <span class="keyword">break</span>;
        }
      }
    }
  }
} E;
</code></pre>

    </div>
</div>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>a 与 m 互质时，$a^{\phi(m)}  \equiv 1 \mod m$ </p>
<h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>无需 a,m 互质 $b &gt; \phi(m),a^b \equiv a^{(b \mod \phi(m))+\phi(m)} \mod m$</p>
<h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">miu</span><span class="params">(T x)</span> </span>{
  <span class="keyword">int</span> t = <span class="number">0</span>;
  <span class="keyword">for</span> (T i = <span class="number">2</span>, k; i*i &lt;= x; ++i) {
    <span class="keyword">if</span> (x%i) <span class="keyword">continue</span>;
    <span class="keyword">for</span> (k = <span class="number">0</span>, ++t; x %i == <span class="number">0</span>; x /= i, ++k) {}
    <span class="keyword">if</span> (k &gt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;
  }
  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) ++t;
  <span class="keyword">return</span> t&amp;<span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="线性筛素数"><a href="#线性筛素数" class="headerlink" title="线性筛素数"></a>线性筛素数</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Euler</span> {</span>
  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime, check;
  <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;i) { <span class="keyword">return</span> check[i]; }
  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{
    prime.clear();
    check = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) {
      <span class="keyword">if</span> (!check[i]) prime.emplace_back(i), check[i] = i;
      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;j : prime) {
        <span class="keyword">if</span> (i*j &gt; n) <span class="keyword">break</span>;
        check[i*j] = j;
        <span class="keyword">if</span> (i%j == <span class="number">0</span>) <span class="keyword">break</span>;
      }
    }
  }
} E;
</code></pre>

    </div>
</div>
<h2 id="求所有因子"><a href="#求所有因子" class="headerlink" title="求所有因子"></a>求所有因子</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">get_fac</span><span class="params">(T x)</span> </span>{
  <span class="built_in">vector</span>&lt;T&gt; fac = {<span class="number">1</span>};
  <span class="keyword">while</span> (E[x]) {
    <span class="keyword">for</span> (T y = E[x], z = y, sz = fac.size(); x % y == <span class="number">0</span>; x /= y, z *= y) {
      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) {
        fac.emplace_back(fac[i] * z);
      }
    }
  }
  <span class="keyword">return</span> fac;
}
</code></pre>

    </div>
</div>
<h2 id="判断素数-质数"><a href="#判断素数-质数" class="headerlink" title="判断素数(质数)"></a>判断素数(质数)</h2><p> 某较优方法<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>{
  <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;
  <span class="keyword">if</span>(x == <span class="number">2</span> || x == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;
  <span class="keyword">if</span>(x%<span class="number">6</span> != <span class="number">1</span> &amp;&amp; x%<span class="number">6</span> != <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;
  <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">5</span>; i*i &lt;= x; i += <span class="number">6</span>)
    <span class="keyword">if</span>(x%i == <span class="number">0</span> || x%(i+<span class="number">2</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;
  <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre>

    </div>
</div></p>
<h3 id="Miller-Rabin-素性测试"><a href="#Miller-Rabin-素性测试" class="headerlink" title="Miller-Rabin 素性测试"></a>Miller-Rabin 素性测试</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">MillerRabin</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> test_time = <span class="number">10</span>;
  <span class="keyword">if</span> (x &lt; <span class="number">3</span>) <span class="keyword">return</span> x == <span class="number">2</span>;
  <span class="keyword">int</span> a = x<span class="number">-1</span>, b = <span class="number">0</span>;
  <span class="keyword">while</span> (!(a&amp;<span class="number">1</span>)) a &gt;&gt;= <span class="number">1</span>, ++b;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, v; i &lt;= test_time; ++i) {
    v = (qpow(rnd()%(x<span class="number">-2</span>)+<span class="number">2</span>, a, x));
    <span class="keyword">if</span> (v == <span class="number">1</span> || v == x<span class="number">-1</span>) <span class="keyword">continue</span>;
    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b &amp;&amp; v != x<span class="number">-1</span>; ++j)
      v = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1l</span>l*v*v%x);
    <span class="keyword">if</span> (j &gt;= b) <span class="keyword">return</span> <span class="literal">false</span>;
  }
  <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre>

    </div>
</div>
<h2 id="线性筛GCD"><a href="#线性筛GCD" class="headerlink" title="线性筛GCD"></a><a href="https://www.luogu.com.cn/problem/P2568" target="_blank" rel="noopener">线性筛GCD</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gcd_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)
  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="keyword">if</span> (!g[i][j])
  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n/i; ++k)
    g[k*i][k*j] = k;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a><a href="https://www.luogu.org/problemnew/show/P1075" target="_blank" rel="noopener">分解质因数</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
vector&lt;pair&lt;T, int&gt;&gt; get_fac(T x) {
  <span class="built_in">vector</span>&lt;pair&lt;T, <span class="keyword">int</span>&gt;&gt; ans;
  <span class="keyword">for</span> (T i = <span class="number">2</span>; i * i &lt;= x; ++i) {
    <span class="keyword">if</span> (x % i) <span class="keyword">continue</span>;
    <span class="keyword">int</span> k = <span class="number">0</span>;
    <span class="keyword">for</span> ( ; x % i == <span class="number">0</span>; x /= i) ++k;
    ans.emplace_back(i, k);
  }
  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) ans.emplace_back(x, <span class="number">1</span>);
  <span class="keyword">return</span> ans;
}
</code></pre>

    </div>
</div>
<hr>
<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a><a href="https://www.luogu.com.cn/problem/P3846" target="_blank" rel="noopener">BSGS</a></h2><p>求解关于 $t$ 的方程 $a^t \equiv x(mod m),\gcd(a, m) = 1$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> m)</span> </span>{ <span class="comment">// a^n = x</span>
  <span class="keyword">static</span> <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; mmp; mmp.clear();
  <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="built_in">sqrt</span>(m)+<span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>, res;
  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i, b = b*a%m) mmp[x*b%m] = i;
  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; ++i, c = c*b%m) { <span class="comment">// b = a^t</span>
    <span class="keyword">if</span>(mmp.count(c)) {
      res = t*i-mmp[c];
      <span class="keyword">if</span>(res &gt; <span class="number">0</span>) <span class="keyword">return</span> res;
    }
  }
  <span class="keyword">return</span> <span class="number">-1</span>;
}
</code></pre>

    </div>
</div>
<h2 id="拓展BSGS"><a href="#拓展BSGS" class="headerlink" title="拓展BSGS"></a>拓展BSGS</h2><p>$\gcd(a, m) \neq 1$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> EXBSGS {

<span class="function"><span class="keyword">inline</span> ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll mod, ll qaq)</span></span>{
  <span class="built_in">unordered_map</span>&lt;ll, <span class="keyword">int</span>&gt; H; H.clear();
  ll Q, p = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(mod)), x, y; 
  exgcd(qaq, mod, x, y), b = (b * x % mod + mod) % mod, 
  Q = qpow(a, p, mod), exgcd(Q, mod, x, y), Q = (x % mod + mod) % mod ;
  <span class="keyword">for</span> (ll i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * a % mod)  <span class="keyword">if</span> (!H.count(i)) H[i] = j ;
  <span class="keyword">for</span> (ll i = b, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * Q % mod)  <span class="keyword">if</span> (H[i]) <span class="keyword">return</span> j * p + H[i];
  <span class="keyword">return</span> <span class="number">-1</span> ;
}

<span class="function"><span class="keyword">inline</span> ll <span class="title">exBSGS</span><span class="params">(ll N, ll P, ll M)</span></span>{
  ll qaq = <span class="number">1</span>, k = <span class="number">0</span>, qwq = <span class="number">1</span>; 
  <span class="keyword">if</span> (M == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ; 
  <span class="keyword">while</span> ((qwq = __gcd(N, P)) &gt; <span class="number">1</span>) {
    <span class="keyword">if</span> (M%qwq) <span class="keyword">return</span> <span class="number">-1</span> ;
    ++k, M /= qwq, P /= qwq, qaq = qaq*(N/qwq)%P ;
    <span class="keyword">if</span> (qaq == M) <span class="keyword">return</span> k ;
  }
  <span class="keyword">return</span> (qwq = BSGS(N, M, P, qaq)) == <span class="number">-1</span> ? <span class="number">-1</span> : qwq+k ;
}

} <span class="keyword">using</span> EXBSGS::exBSGS;
</code></pre>

    </div>
</div>
<h2 id="错排"><a href="#错排" class="headerlink" title="错排"></a>错排</h2><p>$D_1 = 0$</p>
<p>$D_2 = 1$</p>
<p>$D_n = (n-1)(D_{n-1}+D_{n-2})$</p>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p><a href="https://blog.csdn.net/zhouyuheng2003/article/details/80163139#comments" target="_blank" rel="noopener">参考博客</a></p>
<p>复杂度 $O(\sqrt{m}+g\times\log^2m)$</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getG</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;m)</span> </span>{
  <span class="keyword">static</span> <span class="keyword">int</span> q[<span class="number">100000</span>+<span class="number">7</span>];
  <span class="keyword">int</span> _phi = phi(m), x = _phi, tot = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= _phi; ++i) {
    <span class="keyword">if</span> (x%i) <span class="keyword">continue</span>;
    q[++tot] = _phi/i;
    <span class="keyword">while</span> (x%i == <span class="number">0</span>) x /= i;
  }
  <span class="keyword">if</span> (x &gt; <span class="number">1</span>) x = q[++tot] = _phi/x;
  <span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">2</span>, flag; ; ++g) {
    flag = <span class="number">1</span>;
    <span class="keyword">if</span> (qpow(g, _phi, m) != <span class="number">1</span>) <span class="keyword">continue</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) {
      <span class="keyword">if</span> (qpow(g, q[i], m) == <span class="number">1</span>) {
        flag = <span class="number">0</span>;
        <span class="keyword">break</span>;
      }
    }
    <span class="keyword">if</span> (flag) <span class="keyword">return</span> g;
  }
}
</code></pre>

    </div>
</div>
<h3 id="单位根反演"><a href="#单位根反演" class="headerlink" title="单位根反演"></a>单位根反演</h3><p>$[k|n]=\frac{1}{k}\sum\limits_{i=0}^{k-1}w_{k}^{ni}$</p>
<p>$[a\equiv b(\mod n)]=[a-b \equiv 0(\mod n)]=\frac{1}{n}\sum\limits_{i=0}^{n-1}w_n^{(a-b)k}=\frac{1}{n}\sum\limits_{i=0}^{n-1}w_n^{ak}w_n^{-bk}$</p>
<h3 id="单位根卷积"><a href="#单位根卷积" class="headerlink" title="单位根卷积"></a>单位根卷积</h3><p>$\sum\limits_{i=0}^{n}[i\%k=0]f(i)=\sum\limits_{i=0}^{n}\frac{1}{k}\sum\limits_{j=0}^{k-1}(w_k^i)^jf(i)$</p>
<h2 id="大数阶乘"><a href="#大数阶乘" class="headerlink" title="大数阶乘"></a><a href="https://www.luogu.com.cn/problem/P5282" target="_blank" rel="noopener">大数阶乘</a></h2><p>分块打表</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> BigFac {
<span class="meta">#<span class="meta-keyword">define</span> lon long long</span>
lon a[<span class="number">110</span>]={<span class="number">1</span>,<span class="number">682498929</span>,<span class="number">491101308</span>,<span class="number">76479948</span>,<span class="number">723816384</span>,<span class="number">67347853</span>,<span class="number">27368307</span>,
<span class="number">625544428</span>,<span class="number">199888908</span>,<span class="number">888050723</span>,<span class="number">927880474</span>,<span class="number">281863274</span>,<span class="number">661224977</span>,<span class="number">623534362</span>,
<span class="number">970055531</span>,<span class="number">261384175</span>,<span class="number">195888993</span>,<span class="number">66404266</span>,<span class="number">547665832</span>,<span class="number">109838563</span>,<span class="number">933245637</span>,
<span class="number">724691727</span>,<span class="number">368925948</span>,<span class="number">268838846</span>,<span class="number">136026497</span>,<span class="number">112390913</span>,<span class="number">135498044</span>,<span class="number">217544623</span>,
<span class="number">419363534</span>,<span class="number">500780548</span>,<span class="number">668123525</span>,<span class="number">128487469</span>,<span class="number">30977140</span>,<span class="number">522049725</span>,<span class="number">309058615</span>,
<span class="number">386027524</span>,<span class="number">189239124</span>,<span class="number">148528617</span>,<span class="number">940567523</span>,<span class="number">917084264</span>,<span class="number">429277690</span>,<span class="number">996164327</span>,
<span class="number">358655417</span>,<span class="number">568392357</span>,<span class="number">780072518</span>,<span class="number">462639908</span>,<span class="number">275105629</span>,<span class="number">909210595</span>,<span class="number">99199382</span>,
<span class="number">703397904</span>,<span class="number">733333339</span>,<span class="number">97830135</span>,<span class="number">608823837</span>,<span class="number">256141983</span>,<span class="number">141827977</span>,<span class="number">696628828</span>,
<span class="number">637939935</span>,<span class="number">811575797</span>,<span class="number">848924691</span>,<span class="number">131772368</span>,<span class="number">724464507</span>,<span class="number">272814771</span>,<span class="number">326159309</span>,
<span class="number">456152084</span>,<span class="number">903466878</span>,<span class="number">92255682</span>,<span class="number">769795511</span>,<span class="number">373745190</span>,<span class="number">606241871</span>,<span class="number">825871994</span>,
<span class="number">957939114</span>,<span class="number">435887178</span>,<span class="number">852304035</span>,<span class="number">663307737</span>,<span class="number">375297772</span>,<span class="number">217598709</span>,<span class="number">624148346</span>,
<span class="number">671734977</span>,<span class="number">624500515</span>,<span class="number">748510389</span>,<span class="number">203191898</span>,<span class="number">423951674</span>,<span class="number">629786193</span>,<span class="number">672850561</span>,
<span class="number">814362881</span>,<span class="number">823845496</span>,<span class="number">116667533</span>,<span class="number">256473217</span>,<span class="number">627655552</span>,<span class="number">245795606</span>,<span class="number">586445753</span>,
<span class="number">172114298</span>,<span class="number">193781724</span>,<span class="number">778983779</span>,<span class="number">83868974</span>,<span class="number">315103615</span>,<span class="number">965785236</span>,<span class="number">492741665</span>,
<span class="number">377329025</span>,<span class="number">847549272</span>,<span class="number">698611116</span>};
<span class="function">lon <span class="title">fac</span><span class="params">(lon n, lon p = MOD)</span> </span>{
  <span class="keyword">if</span> (n &gt;= p) {
    <span class="keyword">return</span> <span class="number">0</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (p==<span class="number">1000000007</span>) {
    lon now=n/<span class="number">10000000</span>;
    lon ans=a[now];
    <span class="keyword">for</span>(lon i=now*<span class="number">10000000</span>+<span class="number">1</span>;i&lt;=n;i++)
      ans=ans*i%p;
    <span class="keyword">return</span> ans%p;
  } <span class="keyword">else</span> {
    lon ans=<span class="number">1</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)
      ans=ans*i%p;
    <span class="keyword">return</span> ans%p;
  }
}
}
</code></pre>

    </div>
</div>
<h2 id="全排列和逆序对"><a href="#全排列和逆序对" class="headerlink" title="全排列和逆序对"></a><a href="https://www.cnblogs.com/saltless/archive/2011/06/01/2065619.html" target="_blank" rel="noopener">全排列和逆序对</a></h2><h3 id="根据逆序数推排列数"><a href="#根据逆序数推排列数" class="headerlink" title="根据逆序数推排列数"></a>根据逆序数推排列数</h3><p>已知一个n元排列的逆序数为m,这样的n元排列有多少种？</p>
<ol>
<li>对任意n&gt;=2且0&lt;=m&lt;=C(n,2)时f(n,m)&gt;=1；当m&gt;C(n,2)时,f(n,m)=0</li>
<li>f(n,m)=f(n,C(n,2)-m)</li>
<li>f(n+1,m)=f(n,m)+f(n,m-1)+…+f(n,m-n)</li>
<li>f(n,0)=f(n,C(n,2))=1</li>
<li>f(n,1)=f(n,C(n,2)-1)=n-1(n&gt;1)</li>
<li>f(n,2)=f(n,C(n,2)-2)=C(n,2)-1(n&gt;2)</li>
</ol>
<h3 id="根据每个数的逆序数求出原排列"><a href="#根据每个数的逆序数求出原排列" class="headerlink" title="根据每个数的逆序数求出原排列"></a>根据每个数的逆序数求出原排列</h3><h3 id="根据逆序数求最小排列"><a href="#根据逆序数求最小排列" class="headerlink" title="根据逆序数求最小排列"></a>根据逆序数求最小排列</h3><ol>
<li>对于n的全排列，在它完全倒序的时候（也就是n,n-1,…,2,1的时候）逆序数最多。</li>
<li>对于一个形如1,2,3,…,i-1,i,n,…i+1的排列q（如n=5时的1,2,5,4,3），即在数n前保证首项为1且严格以公差为1递增而数n之后排列任意的数列<ul>
<li>当数n之后是递减的时候q的逆序数最多，为t=C(n-i,2)。 </li>
<li>排列q是出现逆序数为t的最小排列。 </li>
</ul>
</li>
<li>在上一条所设定的排列q的基础上，我们将数n后面的第k小数与数n的前一个数（即i）交换，然后使数n后面保持逆序。这样得到的新排列所含的逆序数为t=C(n-i,2)+k，且这个排列是逆序数为t的最小排列。 <h3 id="第k个字典序每个数的逆序对"><a href="#第k个字典序每个数的逆序对" class="headerlink" title="第k个字典序每个数的逆序对"></a>第k个字典序每个数的逆序对</h3></li>
</ol>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="comment">// n个数排列的第k个(字典序)的逆序对</span>
<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{
  <span class="keyword">int</span> res = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j; --j) {
    res += k/fac[j];
    k %= fac[j];
  }
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div>
<h2 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a><a href="https://kewth.blog.luogu.org/solution-p5491" target="_blank" rel="noopener">二次剩余</a></h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">namespace</span> Cipolla {

<span class="keyword">int</span> mod, _x0, _x1;
<span class="keyword">long</span> <span class="keyword">long</span> I_mul_I; <span class="comment">// 虚数单位的平方</span>

<span class="class"><span class="keyword">struct</span> <span class="title">complex</span> {</span>
  <span class="keyword">long</span> <span class="keyword">long</span> real, imag;
  <span class="built_in">complex</span>(<span class="keyword">long</span> <span class="keyword">long</span> real = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">long</span> imag = <span class="number">0</span>): real(real), imag(imag) { }
};
<span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="built_in">complex</span> x, <span class="built_in">complex</span> y) {
  <span class="keyword">return</span> x.real == y.real <span class="keyword">and</span> x.imag == y.imag;
}
<span class="keyword">inline</span> <span class="built_in">complex</span> <span class="keyword">operator</span> * (<span class="built_in">complex</span> x, <span class="built_in">complex</span> y) {
  <span class="keyword">return</span> <span class="built_in">complex</span>((x.real * y.real + I_mul_I * x.imag % mod * y.imag) % mod,
      (x.imag * y.real + x.real * y.imag) % mod);
}

<span class="function"><span class="built_in">complex</span> <span class="title">power</span><span class="params">(<span class="built_in">complex</span> x, <span class="keyword">int</span> k)</span> </span>{
  <span class="built_in">complex</span> res = <span class="number">1</span>;
  <span class="keyword">while</span>(k) {
    <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = res * x;
    x = x * x;
    k &gt;&gt;= <span class="number">1</span>;
  }
  <span class="keyword">return</span> res;
}

<span class="function"><span class="keyword">bool</span> <span class="title">check_if_residue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
  <span class="keyword">return</span> power(x, (mod - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;x0 = _x0, <span class="keyword">int</span> &amp;x1 = _x1)</span> </span>{
  mod = p;
  <span class="keyword">if</span> (power(n, p&gt;&gt;<span class="number">1</span>) == p<span class="number">-1</span>) <span class="keyword">return</span> x0 = <span class="number">-1</span>; <span class="comment">// 无解</span>
  <span class="keyword">if</span> (power(n, p&gt;&gt;<span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> x0 = x1 = <span class="number">0</span>;

  <span class="keyword">long</span> <span class="keyword">long</span> a = rand() % mod;
  <span class="keyword">while</span>(!a <span class="keyword">or</span> check_if_residue((a * a + mod - n) % mod))
    a = rand() % mod;
  I_mul_I = (a * a + mod - n) % mod;

  x0 = <span class="keyword">int</span>(power(<span class="built_in">complex</span>(a, <span class="number">1</span>), (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>).real);
  x1 = mod - x0;
  <span class="keyword">return</span> x0;
}
} <span class="comment">// namespace Cipolla</span>
</code></pre>

    </div>
</div>
<hr>
<h1 id="动态规划-DP"><a href="#动态规划-DP" class="headerlink" title="动态规划 DP"></a>动态规划 DP</h1><p>(我全都不会)</p>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h3 id="最长上升子序列LIS"><a href="#最长上升子序列LIS" class="headerlink" title="最长上升子序列LIS"></a><a href="http://codevs.cn/problem/1576/" target="_blank" rel="noopener">最长上升子序列LIS</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
  f[i] = <span class="number">1</span>;
  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)
    <span class="keyword">if</span>(a[i] &gt; a[j]) f[i] = max(f[i],f[j]+<span class="number">1</span>);
}
</code></pre>

    </div>
</div>
<h3 id="最长公共子序列LCS"><a href="#最长公共子序列LCS" class="headerlink" title="最长公共子序列LCS"></a>最长公共子序列LCS</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp">f[i][j] = max{  f[i<span class="number">-1</span>][j],
                f[i][j<span class="number">-1</span>],
                f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span> (<span class="keyword">if</span> A[i] == B[j])}
</code></pre>

    </div>
</div>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a><a href="https://www.luogu.org/problemnew/show/P1352" target="_blank" rel="noopener">树形DP</a></h2><h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><h3 id="枚举子集"><a href="#枚举子集" class="headerlink" title="枚举子集"></a><a href="https://cp-algorithms.com/algebra/all-submasks.html" target="_blank" rel="noopener">枚举子集</a></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">for</span> (<span class="keyword">int</span> i = s; i; i = (i<span class="number">-1</span>)&amp;s) {}
</code></pre>

    </div>
</div>
<h3 id="枚举n个元素-大小为k的二进制子集"><a href="#枚举n个元素-大小为k的二进制子集" class="headerlink" title="枚举n个元素,大小为k的二进制子集"></a>枚举n个元素,大小为k的二进制子集</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">int</span> s=(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>;
<span class="keyword">while</span>(s&lt;(<span class="number">1</span>&lt;&lt;n)){
  work(s);
  <span class="keyword">int</span> x=s&amp;-s,y=s+x;
  s=((s&amp;~y)/x&gt;&gt;<span class="number">1</span>)|y; <span class="comment">//这里有一个位反~</span>
}
</code></pre>

    </div>
</div>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a><a href="https://www.luogu.org/problemnew/show/P1757" target="_blank" rel="noopener">分组背包</a></h3><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><a href="https://www.luogu.org/problemnew/show/P1776" target="_blank" rel="noopener">多重背包</a></h3><p>二进制拆分<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, cnt, vi, wi, m; i &lt;= n; ++i) {
  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;vi, &amp;wi, &amp;m);
  cnt = <span class="number">1</span>;
  <span class="keyword">while</span>(m-cnt &gt; <span class="number">0</span>) {
    m -= cnt;
    v.push_back(vi*cnt);
    w.push_back(wi*cnt);
    cnt &lt;&lt;= <span class="number">1</span>;
  }
  v.push_back(vi*m);
  w.push_back(wi*m);
}
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.size(); ++i)
  <span class="keyword">for</span>(<span class="keyword">int</span> j = W; j &gt;= w[i]; --j)
    b[j] = max(b[j], b[j-w[i]]+v[i]);
</code></pre>

    </div>
</div><br>单调队列<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;v, &amp;w, &amp;m);
  <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; w; ++u) {
    <span class="keyword">int</span> maxp = (W-u)/w;
    head = <span class="number">1</span>; tail = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> k = maxp<span class="number">-1</span>; k &gt;= max(<span class="number">0</span>, maxp-m); --k) {
      <span class="keyword">while</span>(head &lt;= tail &amp;&amp; calc(u, q[tail]) &lt;= calc(u, k)) tail--;
      q[++tail] = k;
    }
    <span class="keyword">for</span>(<span class="keyword">int</span> p = maxp; p &gt;= <span class="number">0</span>; --p) {
      <span class="keyword">while</span>(head &lt;= tail &amp;&amp; q[head] &gt;= p) head++;
      <span class="keyword">if</span>(head &lt;= tail) f[u+p*w] = max(f[u+p*w], p*v+calc(u, q[head]));
      <span class="keyword">if</span>(p-m<span class="number">-1</span> &lt; <span class="number">0</span>) <span class="keyword">continue</span>;
      <span class="keyword">while</span>(head &lt;= tail &amp;&amp; calc(u, q[tail]) &lt;= calc(u, p-m<span class="number">-1</span>)) tail--;
      q[++tail] = p-m<span class="number">-1</span>;
    }
  }
}
<span class="keyword">int</span> ans = <span class="number">0</span>;
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= W; ++i)
  ans = max(ans, f[i]);
</code></pre>

    </div>
</div></p>
<hr>
<h2 id="SOS-DP"><a href="#SOS-DP" class="headerlink" title="SOS DP"></a><a href="https://codeforces.com/blog/entry/45223" target="_blank" rel="noopener">SOS DP</a></h2><h2 id="WQS二分-DP凸优化"><a href="#WQS二分-DP凸优化" class="headerlink" title="WQS二分|DP凸优化"></a><a href="https://www.cnblogs.com/CreeperLKF/p/9045491.html" target="_blank" rel="noopener">WQS二分|DP凸优化</a></h2><p>题目给了一个选物品的限制条件，要求刚好选m个，让你最大化（最小化）权值, 其特点是函数的斜率单调</p>
<p>例:给你一个N个点M条边无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有K条白色边的生成树。</p>
<p>记 $g(i)$ 是选了 $i$ 条白边的最小生成树值, 发现 $g(i)$ 斜率单调不增 $g(i)-g(i-1) \leq g(i+1)-g(i)$</p>
<p>则二分斜率 k, 求切点(截距最大)</p>
<p>设$f(x)$为我在没有固定选多少个点(但是我已经选了x个点)时的答案(也就是截距), $f(x)=g(x)-k*x$</p>
<p>只要把每个数的$h(x)−=k$然后正常求一下在选任意个数的情况下最大$f(x)$是多少 $O(n\log n)$</p>
<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><p>若dp方程为 $dp[i]=a[i] \cdot b[j]+c[i]+d[j]$ 时,由于存在$a[i] \cdot b[j]$ 这个既有 $i$ 又有 $j$ 的项,就需要使用斜率优化</p>
<h3 id="「HNOI2008」玩具装箱-TOY"><a href="#「HNOI2008」玩具装箱-TOY" class="headerlink" title="「HNOI2008」玩具装箱 TOY"></a><a href="https://www.luogu.com.cn/problem/P3195" target="_blank" rel="noopener">「HNOI2008」玩具装箱 TOY</a></h3><p>$dp[i]=min(dp[j]+(sum[i]+i−sum[j]−j−L−1)^2)(j&lt;i)$</p>
<p>令$a[i]=sum[i]+i,b[i]=sum[i]+i+L+1$</p>
<p>$dp[i]=dp[j]+(a[i]-b[j])^2$</p>
<p>$dp [ i ] = dp [ j ] + a [ i ] ^ 2 - 2 a [ i ] b [ j ] + b [ j ] ^ 2$</p>
<p>$2 a [ i ] b [ j ] + dp [ i ] - a [ i ] ^ 2 = dp [ j ] + b [ j ] ^ 2$</p>
<p>将 $b[j]$ 看作 $x,dp[j]+b[j]^2$ 看作 $y$，这个式子就可以看作一条斜率为 $2 a[i]$ 的直线</p>
<p>而对于每个 $i$ 来说, $a[i]$ 都是确定的, 类似线性规划</p>
<p>$dp[i]$ 的含义转化为：当上述直线过点 $P(b[j],dp[j]+b[j]^2)$ 时，直线在 $y$ 轴的截距加上 $a[i]^2$ (一个定值) 而题目即为找这个截距的最小值</p>
<h2 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h2><h3 id="2D1D"><a href="#2D1D" class="headerlink" title="2D1D"></a>2D1D</h3><p>$f_{l,r}=\min\limits_{k=l}^{r-1} {f_{l,k}+f_{k+1,r}}+w(l,r) \ \ (1\leq l \leq r \leq n)$</p>
<p>当 $w(l,r)$ 满足特定性质</p>
<ul>
<li><p>区间包含单调性 ：如果对于任意 $l\leq l’ \leq r’ \leq r$ ，均有 $w(l’,r’)\leq w(l,r)$ 成立，则称函数 $w$ 对于区间包含关系具有单调性。</p>
</li>
<li><p>四边形不等式 ：如果对于任意 $l_1 \leq l_2 \leq r_1 \leq r_2$ ，均有 $w(l_1,r_1)+w(l_2,r_2) \leq w(l_1,r_2)+w(l_2,r_1)$ 成立，则称函数 $w$ 满足四边形不等式（简记为“交叉小于包含”）。若等号永远成立，则称函数 $w$ 满足 四边形恒等式 。</p>
</li>
</ul>
<blockquote>
<p>引理 1 ：若满足关于区间包含的单调性的函数 $w(l,r)$ 满足四边形不等式，则状态 $f_{l,r}$ 也满足四边形不等式。</p>
</blockquote>
<blockquote>
<p>定理 1 ：若状态 $f$ 满足四边形不等式，记 $m_{l,r}=\min{k:f_{l,r}=g_{k,l,r}}$ 表示最优决策点，则有 $m_{l,r-1} \leq m_{l,r} \leq m_{l+1,r}$</p>
</blockquote>
<h3 id="1D1D"><a href="#1D1D" class="headerlink" title="1D1D"></a>1D1D</h3><p>$f_r = \min\limits_{l=1}^{r-1} {f_l+w(l,r)} \ \ (1\leq r \leq n)$</p>
<blockquote>
<p>定理 2 ：若函数 $w(l,r)$ 满足四边形不等式，记 $h_{l,r}=f_l+w(l,r)$ 表示从 $l$ 转移过来的状态 $r$ , $k_r=\min{l|f_r=h_{l,r}}$ 表示最优决策点，则有 $\forall r_1 \leq r_2 : k_{r1} \leq k_{r2}$</p>
</blockquote>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k_l, <span class="keyword">int</span> k_r)</span> </span>{
  <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>, k = k_l;
  <span class="comment">// 求状态f[mid]的最优决策点</span>
  <span class="keyword">for</span> (<span class="keyword">int</span> i = k_l; i &lt;= min(k_r, mid - <span class="number">1</span>); ++i)
    <span class="keyword">if</span> (w(i, mid) &lt; w(k, mid)) k = i;
  f[mid] = w(k, mid);
  <span class="comment">// 根据决策单调性得出左右两部分的决策区间，递归处理</span>
  <span class="keyword">if</span> (l &lt; mid) DP(l, mid - <span class="number">1</span>, k_l, k);
  <span class="keyword">if</span> (r &gt; mid) DP(mid + <span class="number">1</span>, r, k, k_r);
}
</code></pre>

    </div>
</div>
<h3 id="满足四边形不等式的函数类"><a href="#满足四边形不等式的函数类" class="headerlink" title="满足四边形不等式的函数类"></a>满足四边形不等式的函数类</h3><ul>
<li><p>性质 1 ：若函数 $w_1(l,r),w_2(l,r)$ 均满足四边形不等式（或区间包含单调性），则对于任意 $c_1,c_2\geq 0$ ，函数 $c_1w_1+c_2w_2$ 也满足四边形不等式（或区间包含单调性）。</p>
</li>
<li><p>性质 2 ：若存在函数 $f(x),g(x)$ 使得 $w(l,r) = f(r)-g(l)$ ，则函数 $w$ 满足四边形恒等式。当函数 $f,g$ 单调增加时，函数 $w$ 还满足区间包含单调性。</p>
</li>
<li><p>性质 3 ：设 $h(x)$ 是一个单调增加的凸函数，若函数 $w(l,r)$ 满足四边形不等式并且对区间包含关系具有单调性，则复合函数 $h(w(l,r))$ 也满足四边形不等式和区间包含单调性。</p>
</li>
<li><p>性质 4 ：设 $h(x)$ 是一个凸函数，若函数 $w(l,r)$ 满足四边形恒等式并且对区间包含关系具有单调性，则复合函数 $h(w(l,r))$ 也满足四边形不等式。</p>
</li>
</ul>
<p>首先需要澄清一点，凸函数（Convex Function）的定义在国内教材中有分歧，此处的凸函数指的是（可微的）下凸函数，即一阶导数单调增加的函数。</p>
<h2 id="插头DP-轮廓线DP"><a href="#插头DP-轮廓线DP" class="headerlink" title="插头DP|轮廓线DP"></a><a href="https://www.cnblogs.com/y2823774827y/p/10140757.html" target="_blank" rel="noopener">插头DP|轮廓线DP</a></h2><h3 id="一个闭合回路"><a href="#一个闭合回路" class="headerlink" title="一个闭合回路"></a>一个闭合回路</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">299987</span>;
<span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1</span>&lt;&lt;<span class="number">21</span>;
<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15</span>;

<span class="keyword">int</span> n, m;
<span class="keyword">int</span> a[N][N];
<span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">2</span>][M];
<span class="keyword">int</span> head[<span class="number">2</span>][P], nex[<span class="number">2</span>][M], tot[<span class="number">2</span>], ver[<span class="number">2</span>][M];
<span class="comment">// long long dp[2][P];</span>
<span class="comment">// int head[2][P], nex[2][P], tot[2], ver[2][P];</span>

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot[u]; ++i) {
    dp[u][i] = <span class="number">0</span>; <span class="comment">//</span>
    nex[u][i] = <span class="number">0</span>; <span class="comment">//</span>
    head[u][ver[u][i]%P] = <span class="number">0</span>;
  }
  tot[u] = <span class="number">0</span>;
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> U &amp;v)</span> </span>{
  <span class="keyword">int</span> p = x%P;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u][p]; i; i = nex[u][i]) {
    <span class="keyword">if</span> (ver[u][i] == x) <span class="keyword">return</span> dp[u][i] += v, <span class="keyword">void</span>();
  }
  ++tot[u]; assert(tot[u] &lt; M);
  ver[u][tot[u]] = x;
  nex[u][tot[u]] = head[u][p];
  head[u][p] = tot[u];
  dp[u][tot[u]] = v;
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_val</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> T &amp;x)</span> </span>{
  <span class="keyword">int</span> p = x%P;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u][p]; i; i = nex[u][i]) {
    <span class="keyword">if</span> (ver[u][i] == x) <span class="keyword">return</span> dp[u][i];
  }
  <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">()</span> </span>{
  <span class="keyword">int</span> u = <span class="number">0</span>, base = (<span class="number">1</span>&lt;&lt;m*<span class="number">2</span>+<span class="number">2</span>)<span class="number">-1</span>;
  <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;
  clear(u);
  insert(u, <span class="number">0</span>, <span class="number">1</span>);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) {
      clear(u ^= <span class="number">1</span>);
      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tot[u^<span class="number">1</span>]; ++k) {
        <span class="keyword">int</span> state = ver[u^<span class="number">1</span>][k];
        <span class="keyword">long</span> <span class="keyword">long</span> val = dp[u^<span class="number">1</span>][k];
        <span class="keyword">if</span> (j == <span class="number">1</span>) state = (state&lt;&lt;<span class="number">2</span>)&amp;base;
        <span class="comment">// b1 right b2 down</span>
        <span class="comment">// 0 no 1 left 2 right</span>
        <span class="keyword">int</span> b1 = (state&gt;&gt;j*<span class="number">2</span><span class="number">-2</span>)%<span class="number">4</span>, b2 = (state&gt;&gt;j*<span class="number">2</span>)%<span class="number">4</span>;
        <span class="keyword">if</span> (!a[i][j]) {
          <span class="keyword">if</span> (!b1 &amp;&amp; !b2) insert(u, state, val);
        } <span class="keyword">else</span> <span class="keyword">if</span> (!b1 &amp;&amp; !b2) {
          <span class="keyword">if</span> (a[i+<span class="number">1</span>][j] &amp;&amp; a[i][j+<span class="number">1</span>]) insert(u, state+(<span class="number">1</span>&lt;&lt;j*<span class="number">2</span><span class="number">-2</span>)+(<span class="number">2</span>&lt;&lt;j*<span class="number">2</span>), val);
        } <span class="keyword">else</span> <span class="keyword">if</span> (!b1 &amp;&amp; b2) {
          <span class="keyword">if</span> (a[i][j+<span class="number">1</span>]) insert(u, state, val);
          <span class="keyword">if</span> (a[i+<span class="number">1</span>][j]) insert(u, state+(b2&lt;&lt;j*<span class="number">2</span><span class="number">-2</span>)-(b2&lt;&lt;j*<span class="number">2</span>), val);
        } <span class="keyword">else</span> <span class="keyword">if</span> (b1 &amp;&amp; !b2) {
          <span class="keyword">if</span> (a[i+<span class="number">1</span>][j]) insert(u, state, val);
          <span class="keyword">if</span> (a[i][j+<span class="number">1</span>]) insert(u, state-(b1&lt;&lt;j*<span class="number">2</span><span class="number">-2</span>)+(b1&lt;&lt;j*<span class="number">2</span>), val);
        } <span class="keyword">else</span> <span class="keyword">if</span> (b1 == <span class="number">1</span> &amp;&amp; b2 == <span class="number">1</span>) { <span class="comment">// find 2 turn to 1</span>
          <span class="keyword">for</span> (<span class="keyword">int</span> k = j+<span class="number">1</span>, t = <span class="number">1</span>; k &lt;= m; ++k) {
            <span class="keyword">if</span> ((state&gt;&gt;k*<span class="number">2</span>)%<span class="number">4</span> == <span class="number">1</span>) ++t;
            <span class="keyword">if</span> ((state&gt;&gt;k*<span class="number">2</span>)%<span class="number">4</span> == <span class="number">2</span>) --t;
            <span class="keyword">if</span> (!t) { insert(u, state-(<span class="number">1</span>&lt;&lt;j*<span class="number">2</span><span class="number">-2</span>)-(<span class="number">1</span>&lt;&lt;j*<span class="number">2</span>)-(<span class="number">1</span>&lt;&lt;k*<span class="number">2</span>), val); <span class="keyword">break</span>; }
          }
        } <span class="keyword">else</span> <span class="keyword">if</span> (b1 == <span class="number">2</span> &amp;&amp; b2 == <span class="number">2</span>) { <span class="comment">// find 1 turn to 2</span>
          <span class="keyword">for</span> (<span class="keyword">int</span> k = j<span class="number">-2</span>, t = <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k) {
            <span class="keyword">if</span> ((state&gt;&gt;k*<span class="number">2</span>)%<span class="number">4</span> == <span class="number">1</span>) --t;
            <span class="keyword">if</span> ((state&gt;&gt;k*<span class="number">2</span>)%<span class="number">4</span> == <span class="number">2</span>) ++t;
            <span class="keyword">if</span> (!t) { insert(u, state-(<span class="number">2</span>&lt;&lt;j*<span class="number">2</span><span class="number">-2</span>)-(<span class="number">2</span>&lt;&lt;j*<span class="number">2</span>)+(<span class="number">1</span>&lt;&lt;k*<span class="number">2</span>), val); <span class="keyword">break</span>; }
          }
        } <span class="keyword">else</span> <span class="keyword">if</span> (b1 == <span class="number">2</span> &amp;&amp; b2 == <span class="number">1</span>) {
          insert(u, state-(<span class="number">2</span>&lt;&lt;j*<span class="number">2</span><span class="number">-2</span>)-(<span class="number">1</span>&lt;&lt;j*<span class="number">2</span>), val);
        } <span class="keyword">else</span> <span class="keyword">if</span> (i == ex &amp;&amp; j == ey) { <span class="comment">// b1 == 1, b2 == 2</span>
          res += val;
        }
      }
    }
  }
  <span class="keyword">return</span> res;
}
</code></pre>

    </div>
</div>
<h3 id="多个闭合回路"><a href="#多个闭合回路" class="headerlink" title="多个闭合回路"></a>多个闭合回路</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">else</span> <span class="keyword">if</span> (b1 == <span class="number">1</span> &amp;&amp; b2 == <span class="number">2</span>) {
  <span class="keyword">if</span> (i == ex &amp;&amp; j == ey) res += val;
  <span class="keyword">else</span> dp[u][bit-(<span class="number">1</span>&lt;&lt;j*<span class="number">2</span><span class="number">-2</span>)-(<span class="number">1</span>&lt;&lt;j*<span class="number">2</span>+<span class="number">1</span>)] += val;
}
</code></pre>

    </div>
</div>
<h3 id="联通块"><a href="#联通块" class="headerlink" title="联通块"></a>联通块</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">int</span> n, u, res = -INF;
<span class="keyword">int</span> a[N][N];
<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp[<span class="number">2</span>];

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;state, <span class="keyword">int</span> *<span class="keyword">const</span> s)</span> </span>{
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = (state&gt;&gt;i*<span class="number">3</span><span class="number">-3</span>)%<span class="number">8</span>;
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;val)</span> </span>{
  <span class="keyword">static</span> <span class="keyword">int</span> vis[N];
  <span class="keyword">int</span> state = <span class="number">0</span>, cnt = <span class="number">0</span>;
  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    <span class="keyword">if</span> (s[i] &amp;&amp; !vis[s[i]]) vis[s[i]] = ++cnt;
    state |= (vis[s[i]]&lt;&lt;i*<span class="number">3</span><span class="number">-3</span>);
  }
  <span class="keyword">if</span> (dp[u].count(state)) dp[u][state] = max(dp[u][state], val);
  <span class="keyword">else</span> dp[u].insert({state, val});
  <span class="keyword">if</span> (cnt == <span class="number">1</span>) res = max(res, val);
}

<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>{
  <span class="keyword">static</span> <span class="keyword">int</span> s[N];
  dp[u = <span class="number">0</span>].clear();
  dp[u][<span class="number">0</span>] = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {
    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) {
      dp[u ^= <span class="number">1</span>].clear();
      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : dp[u^<span class="number">1</span>]) {
        decode(p.first, s);
        <span class="keyword">int</span> b1 = s[j<span class="number">-1</span>], b2 = s[j];
        <span class="comment">// not choose</span>
        s[j] = <span class="number">0</span>;
        <span class="keyword">int</span> cnt = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) cnt += s[k] == b2;
        <span class="keyword">if</span> (!b2 || cnt) insert(s, p.second);
        s[j] = b2;
        <span class="comment">// choose</span>
        <span class="keyword">if</span> (!b1 &amp;&amp; !b2) {
          s[j] = <span class="number">7</span>;
        } <span class="keyword">else</span> {
          <span class="keyword">if</span> (b1 &gt; b2) swap(b1, b2); <span class="comment">// in case b2 == 0</span>
          s[j] = b2;
          <span class="keyword">if</span> (b1) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) <span class="keyword">if</span> (s[k] == b1) s[k] = b2;
        }
        insert(s, p.second+a[i][j]);
      }
    }
  }
  <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;
}
</code></pre>

    </div>
</div>
<h3 id="L型"><a href="#L型" class="headerlink" title="L型"></a>L型</h3><p>L 型地板：拐弯且仅拐弯一次。</p>
<p>发现没有，一个存在的插头只有两种状态：拐弯过和没拐弯过，因此我们这样定义插头：</p>
<p>0表没有插头，1表没拐过的插头，2表已经拐过的插头。b1代表当前点的右插头,b2代表当前点的下插头</p>
<h2 id="DP套DP"><a href="#DP套DP" class="headerlink" title="DP套DP"></a>DP套DP</h2><p>有 $dp_1, f[i]$ 为 $dp_1[n] = i$ 的方案数,求 $f$</p>
<p>设 $dp_2[dp_1]$ 为 $dp_1$ 状态下的方案数</p>
<h2 id="动态DP"><a href="#动态DP" class="headerlink" title="动态DP"></a>动态DP</h2><p>将 dp 转换为线段树可以求解的区间问题,动态维护</p>
<h3 id="动态线性DP"><a href="#动态线性DP" class="headerlink" title="动态线性DP"></a>动态线性DP</h3><h3 id="动态树形DP"><a href="#动态树形DP" class="headerlink" title="动态树形DP"></a>动态树形DP</h3><p>树链剖分,轻链暴力</p>
<hr>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="unordered-map-重载"><a href="#unordered-map-重载" class="headerlink" title="unordered_map 重载"></a>unordered_map 重载</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span>
  <span class="keyword">int</span> a, b;
  <span class="comment">// 重载 ==</span>
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Node &amp;x, <span class="keyword">const</span> Node &amp;y) {
    <span class="keyword">return</span> x.a == y.a &amp;&amp; x.b == y.b;
  }
};

<span class="comment">// 方法一</span>
<span class="keyword">namespace</span> <span class="built_in">std</span> {
  <span class="keyword">template</span> &lt;&gt;
  <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;Node&gt; {</span>
    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Node &amp;x)</span> <span class="keyword">const</span> </span>{
      <span class="keyword">return</span> hash&lt;<span class="keyword">int</span>&gt;()(x.a)^hash&lt;<span class="keyword">int</span>&gt;()(x.b);
    }
  };
}
<span class="built_in">unordered_map</span>&lt;Node, <span class="keyword">int</span>&gt; mp;

<span class="comment">// 方法二</span>
<span class="class"><span class="keyword">struct</span> <span class="title">KeyHasher</span> {</span>
  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Node &amp;x)</span> <span class="keyword">const</span> </span>{
    <span class="keyword">return</span> hash&lt;<span class="keyword">int</span>&gt;()(x.a)^hash&lt;<span class="keyword">int</span>&gt;()(x.b);
  }
};
<span class="built_in">unordered_map</span>&lt;Node, <span class="keyword">int</span>, KeyHasher&gt; mmp;
</code></pre>

    </div>
</div>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp">function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>&amp;, <span class="keyword">int</span>)&gt; f = [&amp;](<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y) -&gt; <span class="keyword">void</span> {
  x += y;
};
</code></pre>

    </div>
</div>
<hr>
<h1 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h1><p><code>warning:未完全验证</code><br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>
<span class="class"><span class="title">struct</span> <span class="title">Fraction</span> {</span>
  T a, b;
  <span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">void</span>)(b = <span class="number">1</span>);
    T g = __gcd(a, b);
    a /= g; b /= g;
    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) a = -a, b = -b;
  }
  Fraction(<span class="keyword">const</span> T &amp;_a = <span class="number">0</span>, <span class="keyword">const</span> T &amp;_b = <span class="number">1</span>) : a(_a), b(_b) { normalize(); }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> f1.a*f2.b &lt; f2.a*f1.b; }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> f1.a*f2.b &gt; f2.a*f1.b; }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> f1.a*f2.b == f2.a*f1.b; }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> f1.a*f2.b != f2.a*f1.b; }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> f1 &lt; f2 || f1 == f2; }
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> f1 &gt; f2 || f1 == f2; }
  <span class="keyword">friend</span> Fraction <span class="keyword">operator</span> + (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> Fraction(f1.a*f2.b+f2.a*f1.b, f1.b*f2.b); }
  <span class="keyword">friend</span> Fraction <span class="keyword">operator</span> - (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> Fraction(f1.a*f2.b-f2.a*f1.b, f1.b*f2.b); }
  <span class="keyword">friend</span> Fraction <span class="keyword">operator</span> * (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> Fraction(f1.a*f2.a, f1.b*f2.b); }
  <span class="keyword">friend</span> Fraction <span class="keyword">operator</span> / (<span class="keyword">const</span> Fraction &amp;f1, <span class="keyword">const</span> Fraction &amp;f2) { <span class="keyword">return</span> Fraction(f1.a*f2.b, f1.b*f2.a); }
  Fraction&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> Fraction &amp;f) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+f; }
  Fraction&amp; <span class="keyword">operator</span> -= (<span class="keyword">const</span> Fraction &amp;f) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>-f; }
  Fraction&amp; <span class="keyword">operator</span> *= (<span class="keyword">const</span> Fraction &amp;f) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*f; }
  Fraction&amp; <span class="keyword">operator</span> /= (<span class="keyword">const</span> Fraction &amp;f) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>/f; }
  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;is, Fraction &amp;f) {
    is &gt;&gt; f.a &gt;&gt; f.b;
    f.normalize();
    <span class="keyword">return</span> is;
  }
  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, <span class="keyword">const</span> Fraction &amp;f) {
    <span class="keyword">if</span> (f.b == <span class="number">1</span>) <span class="keyword">return</span> os &lt;&lt; f.a;
    <span class="keyword">return</span> os &lt;&lt; f.a &lt;&lt; <span class="string">"/"</span> &lt;&lt; f.b;
  }
};
<span class="keyword">using</span> fraction = Fraction&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;;
</code></pre>

    </div>
</div></p>
<hr>
<h1 id="模数"><a href="#模数" class="headerlink" title="模数"></a>模数</h1><h2 id="弟弟操作"><a href="#弟弟操作" class="headerlink" title="弟弟操作"></a>弟弟操作</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">int</span> _MOD&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Mint</span> {</span>
  <span class="keyword">int</span> v = <span class="number">0</span>;
  Mint() {}
  Mint(<span class="keyword">int</span> _v) : v((_v%_MOD+_MOD)%_MOD) {}
  Mint(<span class="keyword">long</span> <span class="keyword">long</span> _v) : v(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((_v%_MOD+_MOD)%_MOD)) {}
  Mint <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">int</span> &amp;_v) { <span class="keyword">return</span> *<span class="keyword">this</span> = Mint(_v); }
  Mint <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp;_v) { <span class="keyword">return</span> *<span class="keyword">this</span> = Mint(_v); }
  <span class="keyword">bool</span> <span class="keyword">operator</span> ! () <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;v; }
  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> v &lt; b.v; }
  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> v &gt; b.v; }
  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> v == b.v; }
  <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> v != b.v; }
  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> v &lt; b.v || v == b.v; }
  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> v &gt; b.v || v == b.v; }
  Mint <span class="keyword">operator</span> + (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> Mint(v+b.v); }
  Mint <span class="keyword">operator</span> - (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> Mint(v-b.v); }
  Mint <span class="keyword">operator</span> * (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> Mint(<span class="number">1l</span>l*v*b.v); }
  Mint <span class="keyword">operator</span> / (<span class="keyword">const</span> Mint &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> Mint(b.inv()*v); }
  Mint&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> Mint &amp;b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+b; }
  Mint&amp; <span class="keyword">operator</span> -= (<span class="keyword">const</span> Mint &amp;b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>-b; }
  Mint&amp; <span class="keyword">operator</span> *= (<span class="keyword">const</span> Mint &amp;b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*b; }
  Mint&amp; <span class="keyword">operator</span> /= (<span class="keyword">const</span> Mint &amp;b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>/b; }
  Mint <span class="keyword">operator</span> - () <span class="keyword">const</span> { <span class="keyword">return</span> Mint(-v); }
  Mint&amp; <span class="keyword">operator</span> ++ () { <span class="keyword">return</span> *<span class="keyword">this</span> += <span class="number">1</span>; }
  Mint&amp; <span class="keyword">operator</span> -- () { <span class="keyword">return</span> *<span class="keyword">this</span> -= <span class="number">1</span>; }
  Mint <span class="keyword">operator</span> ++ (<span class="keyword">int</span>) { Mint tmp = *<span class="keyword">this</span>; *<span class="keyword">this</span> += <span class="number">1</span>; <span class="keyword">return</span> tmp; }
  Mint <span class="keyword">operator</span> -- (<span class="keyword">int</span>) { Mint tmp = *<span class="keyword">this</span>; *<span class="keyword">this</span> -= <span class="number">1</span>; <span class="keyword">return</span> tmp; }
  <span class="function">Mint <span class="title">pow</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>{
    Mint res(1), x(*this);
    <span class="keyword">while</span> (p) {
      <span class="keyword">if</span> (p&amp;<span class="number">1</span>) res = res*x;
      x *= x;
      p &gt;&gt;= <span class="number">1</span>;
    }
    <span class="keyword">return</span> res;
  }
  <span class="function">Mint <span class="title">inv</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> <span class="built_in">pow</span>(_MOD<span class="number">-2</span>); }
  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;is, Mint &amp;mt) { <span class="keyword">return</span> is &gt;&gt; mt.v; }
  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, <span class="keyword">const</span> Mint &amp;mt) { <span class="keyword">return</span> os &lt;&lt; mt.v; }
};
<span class="keyword">using</span> mint = Mint&lt;MOD&gt;;
</code></pre>

    </div>
</div>
<h2 id="tourist的模板-用不来"><a href="#tourist的模板-用不来" class="headerlink" title="tourist的模板(用不来)"></a>tourist的模板(用不来)</h2><p><a href="https://codeforces.com/contest/1383/submission/87883167" target="_blank" rel="noopener">某出处</a></p>
<p>注: <code>#ifdef _WIN32</code>部分可能导致 CE</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function">T <span class="title">inverse</span><span class="params">(T a, T m)</span> </span>{
  T u = <span class="number">0</span>, v = <span class="number">1</span>;
  <span class="keyword">while</span> (a != <span class="number">0</span>) {
    T t = m / a;
    m -= t * a; swap(a, m);
    u -= t * v; swap(u, v);
  }
  assert(m == <span class="number">1</span>);
  <span class="keyword">return</span> u;
}
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="class"><span class="keyword">class</span> <span class="title">Modular</span> {</span>
 <span class="keyword">public</span>:
  <span class="keyword">using</span> Type = <span class="keyword">typename</span> decay&lt;<span class="keyword">decltype</span>(T::value)&gt;::type;

  <span class="function"><span class="keyword">constexpr</span> <span class="title">Modular</span><span class="params">()</span> : <span class="title">value</span><span class="params">()</span> </span>{}
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
  Modular(<span class="keyword">const</span> U&amp; x) {
    value = normalize(x);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
  <span class="function"><span class="keyword">static</span> Type <span class="title">normalize</span><span class="params">(<span class="keyword">const</span> U&amp; x)</span> </span>{
    Type v;
    <span class="keyword">if</span> (-mod() &lt;= x &amp;&amp; x &lt; mod()) v = <span class="keyword">static_cast</span>&lt;Type&gt;(x);
    <span class="keyword">else</span> v = <span class="keyword">static_cast</span>&lt;Type&gt;(x % mod());
    <span class="keyword">if</span> (v &lt; <span class="number">0</span>) v += mod();
    <span class="keyword">return</span> v;
  }

  <span class="function"><span class="keyword">const</span> Type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> value; }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">U</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;U&gt;(value); }
  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">static</span> Type <span class="title">mod</span><span class="params">()</span> </span>{ <span class="keyword">return</span> T::value; }

  Modular&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Modular&amp; other) { <span class="keyword">if</span> ((value += other.value) &gt;= mod()) value -= mod(); <span class="keyword">return</span> *<span class="keyword">this</span>; }
  Modular&amp; <span class="keyword">operator</span>-=(<span class="keyword">const</span> Modular&amp; other) { <span class="keyword">if</span> ((value -= other.value) &lt; <span class="number">0</span>) value += mod(); <span class="keyword">return</span> *<span class="keyword">this</span>; }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; Modular&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> U&amp; other) { <span class="keyword">return</span> *<span class="keyword">this</span> += Modular(other); }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; Modular&amp; <span class="keyword">operator</span>-=(<span class="keyword">const</span> U&amp; other) { <span class="keyword">return</span> *<span class="keyword">this</span> -= Modular(other); }
  Modular&amp; <span class="keyword">operator</span>++() { <span class="keyword">return</span> *<span class="keyword">this</span> += <span class="number">1</span>; }
  Modular&amp; <span class="keyword">operator</span>--() { <span class="keyword">return</span> *<span class="keyword">this</span> -= <span class="number">1</span>; }
  Modular <span class="keyword">operator</span>++(<span class="keyword">int</span>) { <span class="function">Modular <span class="title">result</span><span class="params">(*<span class="keyword">this</span>)</span></span>; *<span class="keyword">this</span> += <span class="number">1</span>; <span class="keyword">return</span> result; }
  Modular <span class="keyword">operator</span>--(<span class="keyword">int</span>) { <span class="function">Modular <span class="title">result</span><span class="params">(*<span class="keyword">this</span>)</span></span>; *<span class="keyword">this</span> -= <span class="number">1</span>; <span class="keyword">return</span> result; }
  Modular <span class="keyword">operator</span>-() <span class="keyword">const</span> { <span class="keyword">return</span> Modular(-value); }

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U = T&gt;
  <span class="keyword">typename</span> enable_if&lt;is_same&lt;<span class="keyword">typename</span> Modular&lt;U&gt;::Type, <span class="keyword">int</span>&gt;::value, Modular&gt;::type&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Modular&amp; rhs) {
#ifdef _WIN32
    <span class="keyword">uint64_t</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(value) * <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(rhs.value);
    <span class="keyword">uint32_t</span> xh = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(x &gt;&gt; <span class="number">32</span>), xl = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(x), d, m;
    <span class="keyword">asm</span>(
      <span class="string">"divl %4; \n\t"</span>
      : <span class="string">"=a"</span> (d), <span class="string">"=d"</span> (m)
      : <span class="string">"d"</span> (xh), <span class="string">"a"</span> (xl), <span class="string">"r"</span> (mod())
    );
    value = m;
<span class="meta">#<span class="meta-keyword">else</span></span>
    value = normalize(<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(value) * <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(rhs.value));
<span class="meta">#<span class="meta-keyword">endif</span></span>
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U = T&gt;
  <span class="keyword">typename</span> enable_if&lt;is_same&lt;<span class="keyword">typename</span> Modular&lt;U&gt;::Type, <span class="keyword">int64_t</span>&gt;::value, Modular&gt;::type&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Modular&amp; rhs) {
    <span class="keyword">int64_t</span> q = <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;(value) * rhs.value / mod());
    value = normalize(value * rhs.value - q * mod());
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U = T&gt;
  <span class="keyword">typename</span> enable_if&lt;!is_integral&lt;<span class="keyword">typename</span> Modular&lt;U&gt;::Type&gt;::value, Modular&gt;::type&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Modular&amp; rhs) {
    value = normalize(value * rhs.value);
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }

  Modular&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> Modular&amp; other) { <span class="keyword">return</span> *<span class="keyword">this</span> *= Modular(inverse(other.value, mod())); }

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
  <span class="function"><span class="keyword">friend</span> <span class="keyword">const</span> Modular&lt;U&gt;&amp; <span class="title">abs</span><span class="params">(<span class="keyword">const</span> Modular&lt;U&gt;&amp; v)</span> </span>{ <span class="keyword">return</span> v; }

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Modular&lt;U&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;U&gt;&amp; rhs);

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Modular&lt;U&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;U&gt;&amp; rhs);

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
  <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; stream, Modular&lt;U&gt;&amp; number);

 <span class="keyword">private</span>:
  Type value;
};

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> lhs.value == rhs.value; }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) { <span class="keyword">return</span> lhs == Modular&lt;T&gt;(rhs); }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) == rhs; }

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> !(lhs == rhs); }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) { <span class="keyword">return</span> !(lhs == rhs); }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>!=(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> !(lhs == rhs); }

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> lhs.value &lt; rhs.value; }

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Modular&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) += rhs; }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) += rhs; }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>+(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) += rhs; }

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Modular&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) -= rhs; }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) -= rhs; }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>-(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) -= rhs; }

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Modular&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) *= rhs; }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) *= rhs; }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>*(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) *= rhs; }

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Modular&lt;T&gt; <span class="keyword">operator</span>/(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) /= rhs; }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>/(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) /= rhs; }
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>/(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) { <span class="keyword">return</span> Modular&lt;T&gt;(lhs) /= rhs; }

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
<span class="function">Modular&lt;T&gt; <span class="title">power</span><span class="params">(<span class="keyword">const</span> Modular&lt;T&gt;&amp; a, <span class="keyword">const</span> U&amp; b)</span> </span>{
  assert(b &gt;= <span class="number">0</span>);
  Modular&lt;T&gt; x = a, res = <span class="number">1</span>;
  U p = b;
  <span class="keyword">while</span> (p &gt; <span class="number">0</span>) {
    <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res *= x;
    x *= x;
    p &gt;&gt;= <span class="number">1</span>;
  }
  <span class="keyword">return</span> res;
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">bool</span> <span class="title">IsZero</span><span class="params">(<span class="keyword">const</span> Modular&lt;T&gt;&amp; number)</span> </span>{
  <span class="keyword">return</span> number() == <span class="number">0</span>;
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">const</span> Modular&lt;T&gt;&amp; number)</span> </span>{
  <span class="keyword">return</span> to_string(number());
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; stream, <span class="keyword">const</span> Modular&lt;T&gt;&amp; number) {
  <span class="keyword">return</span> stream &lt;&lt; number();
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; stream, Modular&lt;T&gt;&amp; number) {
  <span class="keyword">typename</span> common_type&lt;<span class="keyword">typename</span> Modular&lt;T&gt;::Type, <span class="keyword">int64_t</span>&gt;::type x;
  stream &gt;&gt; x;
  number.value = Modular&lt;T&gt;::normalize(x);
  <span class="keyword">return</span> stream;
}

<span class="comment">/*</span>
<span class="comment">using ModType = int;</span>
<span class="comment"></span>
<span class="comment">struct VarMod { static ModType value; };</span>
<span class="comment">ModType VarMod::value;</span>
<span class="comment">ModType&amp; md = VarMod::value;</span>
<span class="comment">using Mint = Modular&lt;VarMod&gt;;</span>
<span class="comment">*/</span>

<span class="keyword">constexpr</span> <span class="keyword">int</span> md = <span class="number">998244353</span>;
<span class="keyword">using</span> Mint = Modular&lt;<span class="built_in">std</span>::integral_constant&lt;decay&lt;<span class="keyword">decltype</span>(md)&gt;::type, md&gt;&gt;;
</code></pre>

    </div>
</div>
<hr>
<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="一个小技巧"><a href="#一个小技巧" class="headerlink" title="一个小技巧"></a>一个小技巧</h2><p>a + b == (a ^ b) + ((a &amp; b) &lt;&lt; 1)</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{
    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;
    <span class="keyword">return</span> add(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);
}
</code></pre>

    </div>
</div>
<p>可以使用 bitset 实现高精度加法</p>
<h2 id="vector版本"><a href="#vector版本" class="headerlink" title="vector版本"></a>vector版本</h2><p><a href="https://github.com/KaizynX/Oier/blob/master/BigInteger/BigInteger.cpp" target="_blank" rel="noopener">压位+vector+符号 版本</a></p>
<h2 id="int-版本"><a href="#int-版本" class="headerlink" title="int[]版本"></a>int[]版本</h2><p>食用前请必须注意位数是否足够!</p>
<p><a href="http://ybt.ssoier.cn:8088/" target="_blank" rel="noopener">一本通习题</a><br><a href="https://www.luogu.org/problemnew/lists?name=a%2Bb" target="_blank" rel="noopener">洛谷习题</a></p>
<p>此版本 压位+数组,支持cin,cout,string,long long转换,比较运算符,四则运算(包括高精度乘/除低精度,取模),支持带符号的减法运算,支持幂运算,开根运算</p>
<p>可以通过开根外所有习题<br><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码
    </div>
    <div class="spoiler-content">
        <pre><code class="cpp"><span class="class"><span class="keyword">struct</span> <span class="title">BigInteger</span> {</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1e6</span>; <span class="comment">// 位数SIZE*4</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BASE = <span class="number">1e4</span>; <span class="comment">// 压位</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WIDTH = <span class="number">4</span>;

  <span class="keyword">int</span> v[SIZE], len;
  <span class="keyword">int</span> tag; <span class="comment">// 假装有正负符号</span>

  BigInteger(<span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>) { *<span class="keyword">this</span> = num; }
  BigInteger(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str) { *<span class="keyword">this</span> = str; }
  <span class="comment">// long long 转 BigInteger</span>
  BigInteger <span class="keyword">operator</span> = (<span class="keyword">long</span> <span class="keyword">long</span> num) {
    len = tag = <span class="number">0</span>;
    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);
    <span class="keyword">do</span> {
      v[++len] = (<span class="keyword">int</span>)(num%BASE);
      num /= BASE;
    } <span class="keyword">while</span> (num &gt; <span class="number">0</span>);
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }
  <span class="comment">// string 转 BigInteger</span>
  BigInteger <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="built_in">string</span> &amp;str) {
    <span class="built_in">string</span> buf;
    <span class="keyword">int</span> r = (<span class="keyword">int</span>)str.length()<span class="number">-1</span>, l = max(<span class="number">0</span>, r-WIDTH+<span class="number">1</span>);
    len = tag = <span class="number">0</span>;
    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);
    <span class="keyword">while</span> (r &gt;= <span class="number">0</span>) {
      buf = str.substr(l, r-l+<span class="number">1</span>);
      <span class="built_in">sscanf</span>(buf.c_str(), <span class="string">"%d"</span>, &amp;v[++len]);
      r -= WIDTH; l = max(<span class="number">0</span>, r-WIDTH+<span class="number">1</span>);
    }
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }
  <span class="comment">// 比较运算</span>
  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> {
    <span class="keyword">if</span>(len != b.len) <span class="keyword">return</span> len &lt; b.len;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i; --i)
      <span class="keyword">if</span>(v[i] != b.v[i]) <span class="keyword">return</span> v[i] &lt; b.v[i];
    <span class="keyword">return</span> <span class="literal">false</span>;
  }
  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> b &lt; *<span class="keyword">this</span>; }
  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> !(b &lt; *<span class="keyword">this</span>); }
  <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;= (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; b); }
  <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> *<span class="keyword">this</span> &lt; b || b &lt; *<span class="keyword">this</span>; }
  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; b) &amp;&amp; !(b &lt; *<span class="keyword">this</span>); }
  <span class="comment">// 四则运算</span>
  BigInteger <span class="keyword">operator</span> + (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> {
    BigInteger res = b;
    res.len = max(len, b.len);
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)
      res.v[i] += v[i];
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= res.len; ++i)
      res.v[i+<span class="number">1</span>] += res.v[i]/BASE,
      res.v[i] %= BASE;
    <span class="keyword">while</span>(res.v[res.len+<span class="number">1</span>] &gt; <span class="number">0</span>) res.len++;
    <span class="keyword">return</span> res;
  }
  <span class="comment">// 单目运算</span>
  BigInteger <span class="keyword">operator</span> + () <span class="keyword">const</span> { <span class="keyword">return</span> *<span class="keyword">this</span>; }
  BigInteger <span class="keyword">operator</span> - () <span class="keyword">const</span> {
    BigInteger res = *<span class="keyword">this</span>;
    res.tag ^= <span class="number">1</span>;
    <span class="keyword">return</span> res;
  }
  BigInteger <span class="keyword">operator</span> - (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> {
    <span class="keyword">if</span>(*<span class="keyword">this</span> &lt; b) <span class="keyword">return</span> -(b-*<span class="keyword">this</span>);
    BigInteger res = *<span class="keyword">this</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b.len; ++i)
      res.v[i] -= b.v[i];
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= res.len; ++i)
      <span class="keyword">if</span>(res.v[i] &lt; <span class="number">0</span>)
        res.v[i] += BASE,
        res.v[i+<span class="number">1</span>]--;
    <span class="keyword">while</span>(res.len &gt; <span class="number">1</span> &amp;&amp; res.v[res.len] == <span class="number">0</span>) res.len--;
    <span class="keyword">return</span> res;
  }
  <span class="comment">// 高精度乘低精度</span>
  BigInteger <span class="keyword">operator</span> * (<span class="keyword">int</span> b) <span class="keyword">const</span> {
    BigInteger res;
    <span class="keyword">long</span> <span class="keyword">long</span> tmp;
    res.len = len;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) {
      tmp = <span class="number">1l</span>l*b*v[i];
      res.v[i] += (<span class="keyword">int</span>)(tmp%BASE);
      res.v[i+<span class="number">1</span>] += (<span class="keyword">int</span>)(tmp/BASE+res.v[i]/BASE);
      res.v[i] %= BASE;
    }
    <span class="keyword">while</span>(res.v[res.len+<span class="number">1</span>] &gt; <span class="number">0</span>) res.len++;
    <span class="keyword">return</span> res;
  }
  <span class="comment">// 高精度乘高精度</span>
  BigInteger <span class="keyword">operator</span> * (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> {
    BigInteger res;
    res.len = len+b.len;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)
      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.len; ++j) {
        res.v[i+j<span class="number">-1</span>] += v[i]*b.v[j];
        res.v[i+j] += res.v[i+j<span class="number">-1</span>]/BASE;
        res.v[i+j<span class="number">-1</span>] %= BASE;
      }
    <span class="keyword">while</span>(res.len &gt; <span class="number">1</span> &amp;&amp; res.v[res.len] == <span class="number">0</span>) res.len--;
    <span class="keyword">return</span> res;
  }
  <span class="comment">// 高精度除低精度</span>
  BigInteger <span class="keyword">operator</span> / (<span class="keyword">int</span> b) <span class="keyword">const</span> {
    <span class="keyword">long</span> <span class="keyword">long</span> divisor = <span class="number">0</span>;
    BigInteger res;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i; --i) {
      divisor = divisor*BASE+v[i];
      <span class="keyword">if</span>(divisor &lt; b) <span class="keyword">continue</span>;
      res.v[i] = (<span class="keyword">int</span>)(divisor/b);
      divisor %= b;
      res.len = max(res.len, i);
    }
    <span class="keyword">return</span> res;
  }
  <span class="comment">// 高精度除高精度</span>
  BigInteger <span class="keyword">operator</span> / (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> {
    BigInteger divisor, res;
    <span class="keyword">int</span> l, r, mid;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i; --i) {
      divisor = divisor*BASE+v[i];
      <span class="comment">/*</span>
<span class="comment">      memcpy(divisor.v+1, divisor.v, sizeof(int)*(divisor.len+1));</span>
<span class="comment">      while(divisor.v[divisor.len+1] &gt; 0) divisor.len++;</span>
<span class="comment">      divisor.v[1] = v[i];</span>
<span class="comment">      */</span>
      <span class="keyword">if</span>(divisor &lt; b) <span class="keyword">continue</span>;
      l = <span class="number">0</span>; r = BASE<span class="number">-1</span>;
      <span class="keyword">while</span>(l &lt; r) {
        mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;
        <span class="keyword">if</span>(b*mid &lt;= divisor) l = mid;
        <span class="keyword">else</span> r = mid<span class="number">-1</span>;
      }
      divisor -= b*l;
      res.v[i] = l;
      res.len = max(res.len, i);
    }
    <span class="keyword">return</span> res;
  }
  BigInteger <span class="keyword">operator</span> % (<span class="keyword">const</span> BigInteger &amp;b) <span class="keyword">const</span> { <span class="keyword">return</span> *<span class="keyword">this</span>-*<span class="keyword">this</span>/b*b; }
  BigInteger <span class="keyword">operator</span> ++ () { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+<span class="number">1</span>; }
  BigInteger <span class="keyword">operator</span> -- () { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span><span class="number">-1</span>; }
  BigInteger&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> BigInteger &amp;b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>+b; }
  BigInteger&amp; <span class="keyword">operator</span> -= (<span class="keyword">const</span> BigInteger &amp;b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>-b; }
  BigInteger&amp; <span class="keyword">operator</span> *= (<span class="keyword">const</span> BigInteger &amp;b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*b; }
  BigInteger&amp; <span class="keyword">operator</span> /= (<span class="keyword">const</span> BigInteger &amp;b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>/b; }
  BigInteger&amp; <span class="keyword">operator</span> %= (<span class="keyword">const</span> BigInteger &amp;b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>%b; }
  BigInteger&amp; <span class="keyword">operator</span> *= (<span class="keyword">int</span> b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>*b; }
  BigInteger&amp; <span class="keyword">operator</span> /= (<span class="keyword">int</span> b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>/b; }
  BigInteger&amp; <span class="keyword">operator</span> %= (<span class="keyword">int</span> b) { <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span>%b; }
  <span class="comment">// 重载输入运算符</span>
  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;is, BigInteger &amp;big) {
    <span class="built_in">string</span> buf;
    <span class="keyword">if</span> (is &gt;&gt; buf) big = buf;
    <span class="keyword">return</span> is;
  }
  <span class="comment">// 重载输出运算符</span>
  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, <span class="keyword">const</span> BigInteger &amp;big)
  {
    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">10</span>];
    <span class="keyword">if</span> (big.tag) os &lt;&lt; <span class="string">'-'</span>;
    os &lt;&lt; big.v[big.len];
    <span class="keyword">for</span> (<span class="keyword">int</span> i = big.len<span class="number">-1</span>; i; --i) {
      <span class="built_in">sprintf</span>(buf, <span class="string">"%04d"</span>, big.v[i]);
      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) os &lt;&lt; buf[j];
    }
    <span class="keyword">return</span> os;
  }
  <span class="comment">// 幂</span>
  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
  <span class="function"><span class="keyword">friend</span> BigInteger <span class="title">pow</span> <span class="params">(BigInteger a, T p)</span> </span>{
    <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;
    BigInteger res = <span class="number">1</span>;
    <span class="keyword">while</span>(p) {
      <span class="keyword">if</span>(p%<span class="number">2</span>) res *= a;
      a *= a;
      p /= <span class="number">2</span>;
    }
    <span class="keyword">return</span> res;
  }
  <span class="comment">// 开根</span>
  <span class="function"><span class="keyword">friend</span> BigInteger <span class="title">sqrt</span><span class="params">(<span class="keyword">const</span> BigInteger &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">2</span>)</span> </span>{
    BigInteger l, r = a, mid;
    <span class="keyword">while</span>(l &lt; r) {
      mid = (l+r+<span class="number">1</span>)/<span class="number">2</span>;
      <span class="keyword">if</span>(<span class="built_in">pow</span>(mid, p) &lt;= a) l = mid;
      <span class="keyword">else</span> r = mid<span class="number">-1</span>;
    }
    <span class="keyword">return</span> l;
  }
  <span class="function"><span class="keyword">friend</span> BigInteger <span class="title">gcd</span><span class="params">(BigInteger a, BigInteger b)</span> </span>{
    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) a %= b, swap(a, b);
    <span class="keyword">return</span> a;
  }
  <span class="function"><span class="keyword">friend</span> BigInteger <span class="title">lcm</span><span class="params">(<span class="keyword">const</span> BigInteger &amp;a, <span class="keyword">const</span> BigInteger &amp;b)</span> </span>{
    <span class="keyword">return</span> a/gcd(a, b)*b;
  }
};
</code></pre>

    </div>
</div></p>
<hr>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/custom/donate/AliPayQR.gif"></li>
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/KaizynX/cdnundefined"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2018/11/14/NOIP2018/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/post-loading.gif" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                NOIP2018</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2018/10/25/Luogu-P4948/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/post-loading.gif" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                数列求和</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "thHO16MtUqCFt5ytzki9wwNG-gzGzoHsz",
        appKey: "RztxTMKSVDyuAaC0BVM1wPM1",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="https://kaizynx.github.io/" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/custom/avatar.jpg" itemprop="image" alt="Kaizyn" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="https://kaizynx.github.io/" itemprop="url" rel="author">Kaizyn</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i></p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>


  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>


    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            // PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Kaizyn<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>
        var now = new Date();
        function createtime() {
          var grt= new Date("08/24/2018 00:00:00");//此处修改你的建站时间或者网站上线时间
          now.setTime(now.getTime()+250);
          days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
          hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
          if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
          mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
          seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
          snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
          document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
          document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
        }
        setInterval("createtime()",250);</script>

    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> Powered by Hexo
        </span>
      </p>
    </div>
    <div id="binft"></div>
      <script>
        var binft = function (r) {
          function t() {
            return b[Math.floor(Math.random() * b.length)]
          }
          function e() {
            return String.fromCharCode(94 * Math.random() + 33)
          }
          function n(r) {
            for (var n = document.createDocumentFragment(), i = 0; r > i; i++) {
              var l = document.createElement("span");
              l.textContent = e(), l.style.color = t(), n.appendChild(l)
            }
            return n
          }
          function i() {
            var t = o[c.skillI];
            c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d)
          }
          var l = "",
          o = ["滚动字幕1","滚动字幕233"].map(function (r) {
          return r + ""
          }),
          a = 2,
          g = 1,
          s = 5,
          d = 75,
          b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"],
          c = {
            text: "",
            prefixP: -s,
            skillI: 0,
            skillP: 0,
            direction: "forward",
            delay: a,
            step: g
          };
          i()
          };
          binft(document.getElementById('binft'));
      </script>

  </div><!-- .site-info -->
  

</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!--浏览器搞笑标题-->
<script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/hititle.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<center>
  <img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/footer/skirt.webp">
</center>
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/KaizynX/cdn/video","name":"Lion.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/KaizynX/cdn/video","name":"Lion.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <!-- 实现换肤功能 -->
  <div class="skin-menu no-select" id="mainskin" style="position: fixed">
 <div class="theme-controls row-container">
  <ul class="menu-list">
   <li id="white-bg"> <i class="fa fa-television" aria-hidden="true"></i></li>
   <li id="sakura-bg"> <i class="iconfont icon-sakura"></i></li>
   <li id="gribs-bg"> <i class="fa fa-slack" aria-hidden="true"></i></li>
   <li id="KAdots-bg"> <i class="iconfont icon-dots"></i></li>
   <li id="totem-bg"> <i class="fa fa-optin-monster" aria-hidden="true"></i></li>
   <li id="pixiv-bg"> <i class="iconfont icon-pixiv"></i></li>
   <li id="bing-bg"> <i class="iconfont icon-bing"></i></li>
   <li id="dark-bg"> <i class="fa fa-moon-o" aria-hidden="true"></i></li>
  </ul>
 </div>
</div>
<canvas id="night-mode-cover"></canvas> 
  <div class="changeSkin-gear no-select">
  <div class="keys" id="setbtn"> 
   <span id="open-skinMenu"> 切换主题 | SCHEME TOOL  
     <i class="iconfont icon-gear inline-block rotating"></i> 
   </span>
  </div>
</div>
  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/custom/avatar.gif">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">Kaizyn'sBlog</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="https://github.com/KaizynX" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="https://wpa.qq.com/msgrd?v=3&uin=2291443901&site=qq&menu=yes" class="fa fa-qq" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome fa-headphones" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories">
                  <i class="fa fa-list-ul faa-vertical" aria-hidden="true"></i>
                  分类
                </a>
              </li>
            
              <li>
                <a href="/tags">
                  <i class="fa fa-tags faa-bounce" aria-hidden="true"></i>
                  标签
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            留言板
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            大佬链
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/donate/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-heart faa-pulse" aria-hidden="true"></i>
            投食
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我?
                </a>
              </li>
            
              <li>
                <a href="https://github.com/honjun/hexo-theme-sakura">
                  <i class="fa iconfont icon-sakura" aria-hidden="true"></i>
                  主题
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/atom.xml">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
            RSS
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="2509579883"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>