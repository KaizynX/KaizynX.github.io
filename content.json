{"meta":{"title":"Kaizyn's Blog","subtitle":"日常划水","description":"天天打砖","author":"Kaizyn","url":"http://kaizynx.github.io"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-04-10T07:52:45.156Z","comments":false,"path":"about/index.html","permalink":"http://kaizynx.github.io/about/index.html","excerpt":"","text":"[Kaizyn's Blog] 与&nbsp; Kaizyn&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"categories","date":"2018-09-23T04:18:07.000Z","updated":"2022-04-10T07:52:45.157Z","comments":true,"path":"categories/index.html","permalink":"http://kaizynx.github.io/categories/index.html","excerpt":"","text":""},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2022-04-10T07:52:45.158Z","comments":false,"path":"donate/index.html","permalink":"http://kaizynx.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2022-04-10T07:52:45.157Z","comments":true,"path":"comment/index.html","permalink":"http://kaizynx.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2022-04-10T07:52:45.159Z","comments":true,"path":"rss/index.html","permalink":"http://kaizynx.github.io/rss/index.html","excerpt":"","text":""},{"title":"links","date":"2020-03-18T15:44:00.000Z","updated":"2022-04-10T07:52:45.158Z","comments":true,"path":"links/index.html","permalink":"http://kaizynx.github.io/links/index.html","excerpt":"","text":"","keywords":"友链"},{"title":"tags","date":"2018-09-23T04:17:06.000Z","updated":"2022-04-10T07:52:45.160Z","comments":true,"path":"tags/index.html","permalink":"http://kaizynx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Metabit 实习面试","slug":"Metabit_interview","date":"2022-04-28T15:00:00.000Z","updated":"2022-04-29T08:15:48.698Z","comments":true,"path":"2022/04/28/Metabit_interview/","link":"","permalink":"http://kaizynx.github.io/2022/04/28/Metabit_interview/","excerpt":"","text":"前言关于 「乾象投资 Metabit Trading」，我只知道这是家实习生日薪 1k 的公司 ( 两轮技术面一轮HR面 被 HR 安排在了一起，三连面一条龙送走 一面先自我介绍，着重问了字节的实习经历，但我确实没做什么 然后开始写题 第一题给一颗二叉树，设根的坐标是(0, 0) 一个节点(x, y) 的左儿子坐标 (x - 1, y + 1) 右儿子 (x + 1, y + 1) 返回 vector&lt;vector&lt;int&gt;&gt; 第一维按照 x 坐标分 第二维按照 &lt;y, val&gt; 关键字排序 直接开 map&lt;int, pair&lt;int, int&gt;&gt;&gt; ， mp[x].emplace_back(y, val) 然后嗯排 第二题给定 class BlockReader { // 读取文件 4k 内容放入buffer，返回读取长度 // 如果不足 4k 就剩多少返回多少 size_t read4k(char *buffer) { ; } } 实现任意长度的读取 class Reader { BlockReader reader_; size_t read(size_t size, char *buffer) { ; } } 做法就是开一个开一个buffer_，每次读4k存着 然后用一个循环，读取的小于所求的就一直循环从 buffer_ 载入 知道达到要求或者文件读完了结束 写完后他说有没有优化，思考一阵未果 他说如果有很多 &gt; 4k 的读取操作呢 那就直接读到 buffer, 按照之前缓存到 buffer_多了一次拷贝 但是又不能一下子就直接读，要先把 buffer_ 给填了再 4k 读 class Reader { public: size_t read(size_t size, char *buffer) { size_t offset = 0; if (offset_ &lt; size_) { read_once(buffer, size, offset); } while (size - offset &gt;= 4096) { size_t len = reader_.read4k(buffer + offset); if (len == 0) return; offset += len; } if (offset &lt; size) { read_once(buffer, size, offset); } } private: BlockReader reader_; size_t size_, offset_; char buffer_[4096]; void read_once(char *buffer, size_t size, size_t &amp;offset) { if (offset_ &gt;= size_) { size_ = reader_.read4k(buffer); if (size_ == 0) return; offset = 0; } size_t len = min(size_ - offset_, size - offset); memcpy(buffer + offset, buffer_ + offset_, len); offset += len; offset_ += len; } } 末了问我有什么问题也没什么问题 二面没有自我介绍 又嘴了一遍我的实习经历，因为我只写了两句写得并不清楚 开始搞题 题目是说有一些 task，task 有执行先后顺序条件 形成DAG，每个任务有执行所需时间 有若干个 worker，每次可以执行一个任务（不中断 问怎样安排使得最优(完成所有任务时间最短) 想不出来哇，然后她提示说可以先考虑 worker 无限或者 worker 只有一个的情况 我说无限的话乱执行，时间就是最长的那条链 只有一个的话就是全部任务时间和 想不到最优解，我就说贪心，每次贪心选取能执行的任务中时间最长的先执行 显然不是最优，再度思考 举个反例，就是如果一个任务时间很长但是没有子任务，另一个短但是有很多后续任务，但是因为没有执行这个后面的被阻塞了，那么显然贪心不够优秀 我还真不知道最优解，然后口胡说启发式搜索，假设评估一个任务采用他后续的任务的执行时间 到这就差不多了面试官好像说这个题就不存在最优解的什么算法，让我按照每次优先选取可以选的任务中，他的后续所有任务时间和最大的 开写，先拓扑序倒过来，求那个评估函数 然后搞个优先队列写拓扑 写罢她指出一个问题，就是这个 worker 执行任务是异步的 我把 task 交给 worker 后直接减少入度加队列这样会有问题，应该等任务执行完 于是可以分成两个独立的部分，一部分不断从队列中取出任务给 worker 一部分不断从worker 取出已经执行完成的任务，搞拓扑 以下是本次面试仅保留的代码 map&lt;Task, int&gt; dependents_sum_time; // 前面求的 map&lt;Task, int&gt; deg; struct Queue_task { Task *task; bool operator &lt; (Queue_task &amp;rhs) const { return dependents_sum_time[*task] &lt; dependents_sum_time[*rhs-&gt;task]; } }; priority_queue&lt;Queue_task&gt; q; for (auto &amp;task : graph.tasks) { for (auto &amp;depend_task : task.dependents) { ++deg[depend_task]; } } for (auto &amp;task : graph.tasks) { if (deg[task] == 0) { q.push(Queue_task{&amp;task}); } } int finished = 0; int task_num = graph.tasks.size(); mutex lock; function&lt;void()&gt; f1 = [&amp;]() { while (finished &lt; task_num) { Task *task; { lock_guard&lt;mutex&gt; guard(lock); if (q.empty()) continue; task = q.top(); q.pop(); } // 当有可用 worker 时才能计划任务 while (cluster.GetAvailableWrokers() == 0) { sleep(1); } cluster.Schedule(*task); } }; function&lt;void()&gt; f2 = [&amp;]() { while (finished &lt; task_num) { Task *task = cluster.Poll(); // 返回一个已完成任务 if (task == nullptr) continue; ++finished; for (auto &amp;depend_task : task-&gt;dependents) { --deg[depend_task]; if (deg[depend_task] == 0) { lock_guard&lt;mutex&gt; guard(lock); q.push(Queue_task{&amp;depend_task}); } } } } thead t1(f1), t2(f2); t1.join(); t2.join(); } ​ private: Graph graph_; // 图里有 vector&lt;Task&gt; Cluster cluster_; // 里面是 worker }; 写完15:32超了些，没什么问题结束 HR 面又自我介绍，简单问了实习 其他不多说 hr说前两面反馈也不错 (大概率就是稳了","categories":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}],"tags":[],"keywords":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}]},{"title":"微软暑期实习 leader 面","slug":"MS_interview2","date":"2022-03-11T07:45:00.000Z","updated":"2022-04-29T08:15:34.430Z","comments":true,"path":"2022/03/11/MS_interview2/","link":"","permalink":"http://kaizynx.github.io/2022/03/11/MS_interview2/","excerpt":"","text":"面试面试官迟到了几分钟，还不开摄像头 也没叫我自我介绍，问了一下项目，13:07 直接发个链接开始写题，是个系统设计题 设计一个朋友圈，有四个函数，用户和朋友圈都用 int 表示，其中朋友圈按时间id递增 发一条朋友圈 void(int userId, int momentId) 关注一个人 void(int followerId, int follweeId) 取关一个人 void(int followerId, int follweeId) 获取所有关注者(包括自己)最新的10条朋友圈 list&lt;int&gt;(int userId) 用 map&lt;int, set&lt;int&gt;&gt; 表示 用户 -&gt; 关注者 用 map&lt;int, vector&lt;int&gt;&gt; 表示 用户 -&gt; 朋友圈 1，2，3 非常容易，至于 4 则遍历所有关注者(以及自己)，将这人的最新朋友圈放入优先队列，维护并取出10个即可 priority_queue&lt;array&lt;int, 3&gt;&gt; 其中 array&lt;int, 3&gt; {momentId, userId, idx_of_monment} 大根堆 ，第一关键字是朋友圈id，还有存用户id，以及这条朋友圈是用户的第几条朋友圈 idx 以上，细节不再赘述 一开始他有问为什么想到优先队列。额，如果不是暴力遍历，我就只想到这个了呗(不知道怎么解释，就是想到了嘛) 写完后问我内存上有没有可以优化的地方，我没想出来 他提示我说朋友圈只存最近十条就够了，于是存朋友圈的改为 deque&lt;int&gt; 或 list&lt;int&gt; 这样 然后经过他点播，我想到优先队列里面也是只存十个就够了, 把 priority_queue 换成 set 结束了大概 13:35 左右的样子，问我有什么问题，我就问他们在做那块，他说是 bing ad 扯到 13:40 多点就结束了，迟到早退，太喜欢这种上来写道题完事的！ 结果结果就挂了呜呜呜，收到了感谢信","categories":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}],"tags":[],"keywords":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}]},{"title":"微软暑期实习 IC 面","slug":"MS_interview1","date":"2022-03-11T07:30:00.000Z","updated":"2022-04-10T07:52:45.146Z","comments":true,"path":"2022/03/11/MS_interview1/","link":"","permalink":"http://kaizynx.github.io/2022/03/11/MS_interview1/","excerpt":"","text":"面试面试官准时上线(11:00)，使用了抠图背景(笑 然后他先自我介绍了一通(一点都不记得 然后我自我介绍(中文)，我说我现在在字节实习 他饶有兴趣的样子，但是我说我菜一个月不到啥都没干 然后就开始写题，开了屏幕共享，打开本地 ide 开写 题目是给一个字符串，把括号里面的内容展开 例如输入 string &quot;ab(cd)ef(gh)&quot; ,返回 vector&lt;string&gt;{&quot;abcefg&quot;,&quot;abdefg&quot;,&quot;abcefh&quot;,&quot;abdefh&quot;}, 保证只有一层括号 难度不大，边嘴边写，写完测样例，调试了一会儿。 然后他说如果括号不止一层怎么做，不用写，嘴就好了，我说递归，也没细讲 做题环节结束，我瞄了一眼时间 11:18, 之后就是噩梦了，现在想想可能是题写太快了，他硬是问问题问到面试结束 c++11新特性知道那些 emm… 说一下 unique_ptr, 一个对象只能被一个指针指？他纠正说owner只有一个 了解面向对象吗 我的理解是类，继承，封装，接口什么的(没错我就只能说得这么含糊) 能详细讲讲吗 emmm 遇到过最难的题？ 有啊但记不得细节支支吾吾。 那换个问法有没有印象深刻的问题，有什么收获。 balabala(还真就想不起来具体的题面)， 还有吗， emm 问项目 我看你简历上写了计算机网络，能讲讲http吗？ 竟然问八股，已经全忘记了。。含糊其词将了下三次握手 网络几层模型 我这都背不出来了 http是哪层的 应用层(猜的) http用的啥协议 不会！然后他告诉我tcp tcp啥协议 IP(也是猜的) 讲一下https加密 也是含糊其词公钥密钥 为什么可以保证不被中间坏人乱搞？ 没答上来，他说中间人截取后没办法篡改 你有什么问题要问我吗？ 微软实习生待遇如何？(想问薪资) 他说了一堆什么东西，什么azure云申请了你离职了也不会取消什么的不知道你喜不喜欢(我：啥) 薪资不清楚 那没了，结束 后话面完后忐忑不安，这个人除了会做题其他啥也不会啊 第二天收到 leader 面邮件了","categories":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}],"tags":[],"keywords":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}]},{"title":"字节跳动AML实习二面","slug":"AML_interview2","date":"2022-01-05T13:50:00.000Z","updated":"2022-04-29T08:34:35.722Z","comments":true,"path":"2022/01/05/AML_interview2/","link":"","permalink":"http://kaizynx.github.io/2022/01/05/AML_interview2/","excerpt":"","text":"基本信息岗位：机器学习平台研发实习生-AML 杭州|研发 - 后端|日常实习生 学校：双非 绩点：排不上名 奖项：区域赛金奖 项目：华为软挑 面试扯皮竟然没有让我自我介绍 记得不太清楚，但确实有问了大概是实习时长，何时开始之类的问题 迷惑？说明我稳了吗？不是还没开始面吗 一开始就问我有什么问题想问的吗 我还真没什么问题，就问能学到什么，就也没回答什么吧 果然一上来看见我华为软挑上的多线程，就想问我多线程呜呜呜呜呜呜 开始选题，他说我可以选或不选 题一写线程池实现稀疏矩阵乘稠密矩阵 我说不会线程池，过 题二写一个无锁？的队列 知道 lock-free 吗，不知道，过 题三插入删除求中位数 随便写，用两个 set 然后开始问分布式，如果数据在多个服务器上怎么搞 回答1：二分答案，然后每个服务器询问，得到排名 问数据是整体有序还是局部有序 就是说每个服务器上都有很大数据，假设内存只能放1000个 回答2：每个服务器上数据分成1000份，每份维护指针把数据分成比中位数小和比中位数大两部分，然后插入删除维护指针稍微移动 反正就是接着问，我也不会分布式设计，他发觉了我没这个思维，就停止了 题四问我能上谷歌吗，丢了个 文档 看 P43 到 P51， 实现这个东西 是个把 32 位整数用一种可变长方式压缩存储的算法 没什么难度，开写 写完他看，说我有个地方理解错了，他是要转化成字节流(byte存储)，而我写成了01字符串(char存储)呜呜 问题不大吧 还有什么问题吗我没问题啊，硬着头皮又瞎问了一些 然后他就语重心长说了一些话，建议我看看优秀的工程代码 结束了吧 总结怎么说呢，一面后我狂补C++，结果又空大了 依然问的是出乎意料的问题，不过基础代码都写得出来，怎么说也比一面好太多了呜呜 据学长说只有两面，等消息了 后序就这两面，过了，offer了","categories":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}],"tags":[],"keywords":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}]},{"title":"ACM2021小结","slug":"ACM2021","date":"2022-01-04T03:30:00.000Z","updated":"2022-04-10T07:52:45.118Z","comments":true,"path":"2022/01/04/ACM2021/","link":"","permalink":"http://kaizynx.github.io/2022/01/04/ACM2021/","excerpt":"","text":"因为疫情原因，XCPC2020的赛事推迟 故上半年还在打银川，EC，CCPCfinal等 XCPC全金，EC银，CCPCfinal铜，打了才体会到和一流队伍实力的差距，道阻且长 也体验了全国到处跑，连着好几个周末出去的生活 打完这个赛季白老师退役了，我么继续服役，新组了个队伍，然后暑假都在集训了，才得知消息在南京站进final了 南京站校排rk5，也不是因为疫情原因刚好划到了5，一说法是之前黄金雄名额乱给，现在归清华？还是谁管，所以名额公平得落到了rk5 有点小尴尬哈哈，不管怎么说进final的人生小理想竟不可思议得实现了，感谢队友带飞 下半年么XCPC2021，拿了三个金牌，最后一场南京站拿了银牌，理由么强队太多，发挥失误卡了两题。。。 唉多说无益，多半是实力不够吧，现在已经20级完全碾压，他们今年两场icpc一次rk3，一次rk4，强得一批。我队失去动力了 再说说个人实力上面，按照惯例先放图(去年好像没有放？放在QQ空间了大概) 总体来说因为都在比赛以及大部分时间的组队vp，可以看出个人比赛打得少了很多 翻看去年记录，去年年底的rating是2162，今年是2140（捂脸）实在是没脸见人 总的来说有信心说自己能稳定黄名了，但好像没什么大的提升，虽然突破过2300，不过很快就掉下来了 感觉有点遇到瓶颈了，一个是懈怠了，老实说投入没有大一的时候多了，另一方面确实不知道什么有效的方法，呜呜 之前还跟朋友说要冲击红名，心愿依旧在，先稳一手2300，再冲击红名！ 去年1811 atcoder几乎是没打了，年末的时候心血来潮打了两场，本想上个黄名，但没那么容易 去年全国rk50，rating2632 几乎不大力扣的主要原因是网站逐渐壮大，吸引了一批又一批的大佬入驻，我已经分不到一杯羹了(比赛奖品) 再还有百度之星去年打得稀烂衣服都没拿到今年是有了，不过实力还是不允许去决赛 codejam打到了round2还是打不到衣服，争取今年可以 总结下来对自己的ACM2021不甚满意，取得成就很大部分沾了队友的光 总算学分修完了，不必再为作业烦恼，下学期打算去实习，半退役了 四月还有天梯赛，EC，还是不该停下，善始善终，加油，2022收官之年","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"字节跳动AML实习一面","slug":"AML_interview1","date":"2021-12-29T15:59:59.000Z","updated":"2022-04-29T08:34:29.411Z","comments":true,"path":"2021/12/29/AML_interview1/","link":"","permalink":"http://kaizynx.github.io/2021/12/29/AML_interview1/","excerpt":"","text":"序半(pao)退(lu)役ACM选手的第一次面试，准备欠佳，面得稀烂 基本信息岗位：机器学习平台研发实习生-AML 杭州|研发 - 后端|日常实习生 学校：双非 绩点：排不上名 奖项：区域赛金奖 经历：无 面试自我介绍面试官准时出现，然后让我自我介绍，看一下我的简历，我就说了学校专业，说我大学期间主要在打ACM竞赛拿过一些金牌，然后没了。 然后面试官好像认出是我的学长内推了我 首先他看到我项目经历(华为软挑)有用多线程，问我会不会写 首先我只会基本的，其次我早就忘记函数怎么调用，怕自取其辱，马上说不会 面试官似乎看见我简历上写了 “能熟练使用C++”, 噩梦开始 题一 hash手写 map 过程然后他就给了道题，说看下我的代码风格还是什么代码规范 ACM选手：哦，看啊，我给你封装了，还用了 class ! 特地区分了 private, public欸，平时我就丢若干个函数的嘿 面试官：写的什么玩意？ 问我哈希表，我说把开一个数组，把那个东西通过哈希函数映射成整数，存在对应位置 冲突的话用散列表，问散列表有什么缺点，答如果冲突太多就影响效率，问还有其他什么缺点吗，不知道。 然后他问什么一次探测，二次探测什么的，问有什么优点，存在即合理，有什么优点 我可不会，我只知道 std::map 用的就是散列表，而且个人认为这个探测如果引起二次冲突三次之类的很麻烦，优点不知道。或许我应该告诉他我所想的缺点，但我没有说 我说会快一些，因为空间局部性什么的如果访问附近的会快一点(纯属瞎扯了) 然后开始实现哈希表，相当于手写 map&lt;string, string&gt;, 实现 string get(string); void insert(string key, string value); 然后我吭哧吭哧开始写了，写得不是很顺利，调试了好久才调出来 写的是散列表，用经典的邻接表形式写，就是插入到链表首部 int fir[P], nex[P], tot; string _key[P], _val[P]; void insert(string key, string value) { int val = hash&lt;string&gt;()(key) % P; _key[tot] = key; _val[tot] = value; nex[tot] = fir[val]; fir[val] = tot; tot++; } 然后面试官直呼看不懂，然后嫌弃我的acm代码风格 说我不必写得这么炫酷，说我没看过那些优秀工程代码，叫我不要过早优化 道理我都懂，我寻思这不是经典邻接表吗呜呜，我知道他可能真的没看懂吧 他说算我过了 小结首先我确实是没看过工程代码，呜呜 对 C++ 也没有那么熟悉 手写要写这么久也是没想到，一个小 bug 找了半天，菜了 题二 shared_ptr手写 shared_ptr 过程问我 shared_ptr 详情, 我说允许多个指针指向一个地址，内部有个计数器记录有几个指针指向这里，然后清理的时候如果计数器为0，即没有指针指向这个地址，那么这个地址就被释放 让我写，我。。。不会啊 我先口胡说，如果要知道是不是指向同一块地址，要开个静态空间记录一下指向过的区域。。。 发现其实我 shared_ptr 都不会，我稍加思考，问他是不是就两种，一种指向新申请的空间，一种指向另一个 shared_ptr 然后大致有思路了，就是申请一个 cnt 当作计数器，如果是指向新空间，就 new 一个，如果复制 shared_ptr ，就++cnt 然后写，也写了挺久，主要是发现不会 C++ 内存管理， new, delete 用不来 然后大概 45min+ 了，面试官就来看，大致还可以，说我只写了构造，没写赋值函数 还说我析构哪里没写原子，我没听懂，啥原子，原子性？这不是硬件实现的吗 然后他说多线程，没保证多线程运行的时候安全。我可不会写多线程，也没说要写呜呜 小结事后看了下答案，发现我的想法完全一致 我：我好牛，面试几分钟从无到有想出了 shared_ptr 的正确实现方法 面试官：这币怎么 shared_ptr 都写不来 后经同学证明 c++ 课上有讲(暴露了我没听课的事实) 终究是知识储备不够，不会 shared_ptr, 不会 C++ 内存管理 你还有什么问题吗空大了啊兄弟们，我身边的同学都面的八股+算法，也有字节，大多后端，看网上字节面经也大多如此 我背了半天计网+os八股，结果考我 C++，我是真滴不会啊 自我感觉不好，也说不出什么话，没怎么聊，说没问题了就结束了 后序说等hr通知了，hr说第二天出结果 总结不知道是岗位的不同还是因为有acm奖项的缘故，面试考察的方向与设想的大相径庭 怎么说都应该是自身原因占多，抱着半吊子的决心就去找实习了，投的时候也没多想，投了什么都不清楚 没去了解自己的岗位要求等是导致这次空大的直接原因 另一个面试暴露出来的问题一个是面试技巧的欠缺，另一个就是硬实力不够啊 从长远的目光来看，是自己对学习的态度总是不求甚解，只看重实践，平时对于技术都是会用就好了，很少去了解底层 无论怎么说，痛苦才是人成长的最大动力，能在第一次面试就暴露出问题，也算一种幸运了 简历一定要谨慎写 后续HR不怎么想理我的样子 再三逼问下(不是)，一面过了 2022-02-14 关于线性探测的优点，适合并发，下面是一个例子。 hopscotch hash在普通的线性探测哈希表的基础上，保证了一个值要么hash到当前位置，要么hash到接下来H-1个位置中。H通常是一个机器字节大小，比如32或者64。 对于查找操作，只要找到对应位置的hop info，然后查找最多H个位置即可 插入操作比较复杂，可能需要多次交换位置，首先对key进行hash得到桶的下标i，从i开始线性查找找到第一个空的位置，如果在H-1的范围内则直接插入，如果不在则进行很复杂的逐次向前的调整。如果最终没有找到就需要进行一次rehash。","categories":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}],"tags":[],"keywords":[{"name":"interview","slug":"interview","permalink":"http://kaizynx.github.io/categories/interview/"}]},{"title":"访问博客空无一物","slug":"NonePage","date":"2021-04-06T14:40:00.000Z","updated":"2022-04-10T07:52:45.148Z","comments":true,"path":"2021/04/06/NonePage/","link":"","permalink":"http://kaizynx.github.io/2021/04/06/NonePage/","excerpt":"","text":"问题发生因为某些不义之徒妄想窥视我的加密博客,眼不见心不烦,打算给博客加个隐藏文章的新功能 找到了这么一个插件 增加一个新功能,必然要测试后才能上线 因为我换了新电脑,之前配置的环境都丢了,今天重新配了一下 首先是 Node.js 去官网看看版本已经到 14.16.0 LTS 再看我之前用的版本是 12.16.1 想了三秒钟决定更新 嗯,然后本地测试了一下,成功了,我开开心心地 push 上去了 还有点不放心,特意上 travis-ci 看了一下,绿色通过 然后上博客一看,怎么什么都没有,就是字面意思的什么都没有,页面空白 我按 F12 查看了一下,还是几乎什么都没有,怎么回事 问题锁定然后我去 github 上看看,似乎看出什么不对劲了 就是生成的 index.html 文件都是空的, 0KB 我本地也生成了一下,发现如出一辙,可为什么本地端口可以显示 百度 关于hexo搭建博客——生成index.html页面为空 里面提到的原因 第二种：缺失相应配置文件 因此我注意到 hexo -g 时确实有警告 (程序员才不看警告) (node:16448) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency (Use `node --trace-warnings ...` to show where the warning was created) (node:16448) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;lineno&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;column&#39; of module exports inside circular dependency (node:16448) Warning: Accessing non-existent property &#39;filename&#39; of module exports inside circular dependency 因为本地和 travis-ci 是一样的情况,因此合理怀疑是 Node.js 版本更新而舍弃了一些配置 问题解决懒得折腾,改回 12.16.1 版本 这次崩溃验证了一个编程真理, 代码能运行就不要动它了 补 最终做了个小小更新到 12.22.0 LTS","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"浅谈位运算卷积","slug":"FWT","date":"2021-04-03T14:00:00.000Z","updated":"2022-04-10T07:52:45.134Z","comments":true,"path":"2021/04/03/FWT/","link":"","permalink":"http://kaizynx.github.io/2021/04/03/FWT/","excerpt":"","text":"一般形式类比FFT,构造线性变换 于是设 $c(i,j)$ 为变换系数，即 $A[j]$ 对 $FWT(A)$ 的贡献系数。 $FWT(A)[i]=\\sum\\limits_{j=0}^{n-1}c(i,j)A_j$ 可证 $c(i,j)c(i,k)=c(i,j⊕k)$ 证明略 另外,由于位运算每一位的独立性, $c(i,j)$ 也有一个重要性质: 可以分位考虑。 设二进制数 $a$ 的每一位分别为 : $a_0,a_1,a_2$ 则有 $c(i,j)=c(i_0,j_0)c(i_1,j_1)c(i_2,j_2)…$ 就是把每一位的变换系数乘起来。 利用分治求解 设位矩阵为 $c=\\begin{bmatrix}c(0,0)&amp;c(0,1)\\\\c(1,0)&amp;c(1,1)\\end{bmatrix}$ 对于某位运算构造出满足条件的可逆矩阵即可(理论上如此233) 任意位运算卷积题目链接 题解链接 题目给你每一位的位运算,求卷积 下面对题解进行简单的翻译,(假装我已经懂了 20210405翻译初稿 定义下标从 $0$ 开始.定义一个函数集合 $F_k$,函数接收两个 $[0,k)$ 的整数参数,返回值是 $[0,k)$ 的整数.我们叫 $k \\times k$ 的矩阵三元组 $(A,B,C)$ 是 $f \\in F_k$ 的一个 convolution triple ,前提是: $C$ 是非退化矩阵(非异矩阵|满秩矩阵),并且该函数对于任意两个 $k$ 维向量 $x, y$ 执行以下过程 定义向量 $p=Ax,q=By$ 定义向量 $r$ 是 $p,q$ 的点乘(内积) 返回 $z=C^{-1}r$ 返回 $f$-convolution, i. e. $z_s = \\sum\\limits_{f(i, j)=s}{x_i y_i}$ 现在对于给定的 bitwise-independent function(每位独立位运算) 我们想找到一个 convolution triple 使得卷得够快 对于给定函数 $f \\in F_k$ 怎么检查这三个矩阵是否组成 convolution triple 呢?必要的条件是：对于所有只有一个 1 其他都是 0 的向量,这个卷积应该是正确的如果 $x$ 只有一个非零元素 $x_i=1$,$y$ 只有一个非零元素 $y_j=1$,那么$z$也应该只有一个非零元素$z_{f(i,j)}=1$.满足这个条件就够了因为 linearity of the convolution (卷积的线性?啥特征) 如果 $A={a_{ij}},B={b_{ij}},C={c_{ij}}$, 上述条件可以重写作: $C$ 必须是非退化矩阵,并且对于所有 $i,j,s\\in {0,1,\\dots,k-1}$,应满足 $a_{si}b_{sj}=c_{s,f(i,j)}$ 现在我们可以尝试解决 $n=1$ 的情况,其中一种方法是对于任意二进制运算找到一个 convolution triple, 即枚举所有元素为 ${-1,0,1}$ 的矩阵三元组.事实证明对于所有 16 种运算我们都可以找到对应的矩阵.(注意:我们不能像做某些特殊的卷积那样假设 $A=B=C$, 因为对于函数 $f(x,y)=0$ 并没有满足的三元组) 假设有一个矩阵 $X={x_{ij}}$ of size $a$, $Y={y_{ij}}$ of size $b$. 把 $X ◦ Y$ 的结果表示为 $Z={z_{ij}}$ of size $ab$, $z_{bi+j,bk+l}=x_{ik}y_{jl},(0\\leq i,k \\leq a, 0\\leq j, l \\leq b)$ (换而言之,就是 $a^2$ 矩阵 $Y$ 放到一个矩阵 $X$ 并乘上来自 $X$ 对应的系数) (in other words, it’s just $a^2$ matrices $Y$ put into a matrix $X$ and multiplied by corresponding coefficients from $X$) 我们可以证明(通过检查上述条件)如果$(A_1, B_1, C_1)$ 是 $f\\in F_a$ 的一个 convolution triple, $(A_2, B_2, C_2)$ 是 $g\\in F_b$ 的一个 convolution triple, 那么 $(A_1 ◦ A_2, B_1 ◦ B)2, C_1 ◦ C_2)$ 是 $h\\in F_{ab}$ 的一个 convolution triple, $h(bx_1+x_2,by_1+y2)=bf(x_1, y_1)+g(x_2,y_2)$.我们也可以证明如果 $C_1,C_2$ 都是非退化矩阵, 那么 $C_1◦ C_2$ 是非退化矩阵 因此我们只需要对于所有给定的函数 $f_i$ 求出 convolution triples $(A_i,B_i,C_i)$,那么 $(A,B,C)=(A_{n-1}◦\\dots◦A_0,B_{n-1}◦\\dots◦B_0,C_{n-1}◦\\dots◦C_0)$ 就是一个原函数(运算)的 convolution triple 剩下的事情就是对 $A,B,C^{-1}$ 的快速乘法运算.因为所有这些矩阵都是 $2\\times 2$ 的矩阵, $A(or B)$ 乘上向量 $v$ 的过程可以用雷同 $FFT$ 的做法,只有以下差别:当我们改变下标 $v[i]$ 和 $v[i+2^k]$,我们应该把矩阵 $A_k$ 运用到他们而不是蝴蝶变换 i. e. $$\\begin{pmatrix}v_{new}[i]\\\\v_{new}[i+2^k]\\end{pmatrix}=A_k \\cdot\\begin{pmatrix}v_{old}[i]\\\\v_{old}[i+2^k]\\end{pmatrix}$$ 当把 $C^{-1}$ 乘上一个向量,我们可以类似上面过程反一下 总的时间复杂度是 $O(2^n \\cdot n)$ 另一种解题方法是只使用 $XOR$ and $AND/OR$ 的卷积,因为其他二进制函数既可以单独处理，也可以取反简化为这三个函数,也存在 $O(3^n)$的解法但是不允许其通过此题 参考资料2020-2021 Winter Petrozavodsk Camp, Belarusian SU Contest (XXI Open Cup, Grand Prix of Belarus) 我的板子 位运算卷积(FWT) &amp; 集合幂级数 洛谷P4717 K 进制 FWT / 高维多项式乘法 略记","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://kaizynx.github.io/tags/位运算/"},{"name":"卷积","slug":"卷积","permalink":"http://kaizynx.github.io/tags/卷积/"},{"name":"FWT","slug":"FWT","permalink":"http://kaizynx.github.io/tags/FWT/"}],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"远程桌面","slug":"Remote","date":"2021-03-07T09:00:00.000Z","updated":"2022-04-10T07:52:45.149Z","comments":true,"path":"2021/03/07/Remote/","link":"","permalink":"http://kaizynx.github.io/2021/03/07/Remote/","excerpt":"","text":"序心血来潮买了个win板子(寨板surface)因为预算有限咸鱼寨板收了个m3 8+128 到手才发现以前一直瞧不起的m3处理器也能流畅观看bilibili,日常办公不在话下 (原来不打游戏的话性能真的一直是过剩的啊 因为有了轻薄的板子,我就考虑把之前的轻薄本出了,装了itx,体验++ 这样以来就形成了一个看似美好的局面,性能工作台式机,日常出行小板板 那么如果在外需要高强度工作或者奇妙开发环境呢,就不得不考虑实现远程桌面连接。 准备SAKURA FRP 一元软妹币 设备信息itx win10专业版 1909 分辨率2560*1440 小板 win10企业版LTSC 1809 分辨率2880*1920 再序原本就想平平淡淡使用windows自带的远程桌面连接 但发现这个功能只能在局域网内使用,无法在外网使用哭了 于是想找些花里胡哨的软件 首先想到的是teamviewer,但印象中有丑闻,搜索后发现要收费 再者是口碑不错的向日葵,免费版不太流畅的样子 最大的问题是分辨率问题,因为我的两个设备分辨率不同,比例不同 因此在小板上无法全屏显示(上下会有两个黑边) 而且不知道是分辨率问题还是网速问题,糊的一批,体验极差 因为我在此之前试过了windows远程桌面连接发现能自动改分辨率适配小板,高清的一批 因此心心念念的我走上了所谓的”内网渗透”(是这种说法吗)之路 这个似乎比较高深,反正我没怎么懂 方法一因该是通过路由器搞什么虚拟服务器之类,详情百度 我用的是我室友的Redmi路由器 AC2100,竟然没有虚拟服务器 然后我又尝试各种方法最终无法学会(别骂了) 我的忍道是能原生就原生 实在不行我看下其他软件,首先呼声较高的是花生壳 看了一下要收费欸,免费版带宽1Mbps流量1G/月,这显然不能用 然后我找到了Sakura Frp免费版 正常限速 10 Mbps 每月 5 GiB? 超量限速 4 Mbps 月超出流量上限 1 GiB 最重要的是可以每天通过签到可以随机获得 1~4 GiB 流量!!! 虽然说不够完美,但已经非常可用了!!!!!!!! 唯一的缺点是国内节点要实名认证,实名认证还要1元(搞不懂) 作为白嫖党,这1元让我望而却步,我先在没实名情况下体验了日本某节点 远程桌面连接是有响应的,说明方法可行,但是进展缓慢,一直连接中,显然网速不行 犹豫多天后我交了学费,芜湖起飞 教程你以为我会写教程吗,网上多的是 结果就成功了呗,所以写篇博客庆祝一下 实际体验大约5分钟跑了100M流量,感觉还是不太妙 清晰度流畅度感觉比局域网只差那么一丢丢,但远胜过向日葵了 日后也可用于Linux,Macos 问题2021 03 11 今天下午上课的时候连接失败了呜呜 晚上回到寝室看了一下,觉得问题出在IP地址上 因为我是用寝室移动拨号上网的,导致我每天重启后获得的IP会不一样 而Sakura Frp的隧道配置是有个IP参数的,然后就人没了 解决方法应该是要想办法使用静态IP,触及我的盲区了","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[{"name":"远程桌面连接","slug":"远程桌面连接","permalink":"http://kaizynx.github.io/tags/远程桌面连接/"},{"name":"SakuraFrp","slug":"SakuraFrp","permalink":"http://kaizynx.github.io/tags/SakuraFrp/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"ACL Beginner Contest F - Heights and Pairs","slug":"AtCoder-ABL-F","date":"2020-09-30T14:30:00.000Z","updated":"2022-04-10T07:52:45.122Z","comments":true,"path":"2020/09/30/AtCoder-ABL-F/","link":"","permalink":"http://kaizynx.github.io/2020/09/30/AtCoder-ABL-F/","excerpt":"","text":"题面链接 有 $2N$ 个人每个人有一个高度 $h_i$ 要求两两配对满足 每个人只能配对一次 每对俩人高度不同 问方案数 思路易得记 $ff[s]$ 为至少有 $s$ 对人高度相同情况下的方案数(就是容斥原理) $ans=\\sum\\limits_{s=0}^{n}{(-1)^{s}\\times ff[s]}$ 记 $fff[x]$ 为 $2x$ 个人任意配对的方案数 $fff[x]=fff[x-1]\\times(2x-1)$ 新加入两个可以配对也可以选择和前面的任意一人组合 然而容斥只想到 $2^n$ 做法(暴力枚举全部情况) $O(n^2)$ dp记 $dp[i][j]$ 为 $[1, i]$ 高度的人配对后剩下 $j$ 人未配对的方案数 初始条件 $dp[0][0]=1$ 记高度 $i$ 的人一共有 $t[i]$ 个 枚举这 $t[i]$ 个人中有 $j$ 个人和之前的配对了,剩下 $t[i]-j$ 人未配对 转移方程 $dp[i][k] = \\sum{C_{t[i]}^{j}\\times A_{k+j-(t[i]-j)}^{j}\\times dp[i-1][k+j-(t[i]-j)]}$ 这是以我的水平能想到的最快的算法了呜呜 分治NTT这你能信,上面那个容斥可以用分治NTT做出来 考虑当前的高度 $i$ 有 $t[i]$ 个人 那么当前高度对 $s$ 的大小贡献为 $x$ 时,方案数是 $C_{t[i]}^{2x}\\times fff[x]$ 求 $ff[]$ 其实就是把每个高度的贡献数组 NTT 起来,暴力 NTT 的话是 $O(n^2\\log n)$ 于是采用分治 NTT ,但是这个分治好像和我在洛谷上板子题不大一样呜呜 分治不是按照 $ff[]$ 数组的下标分治, 而是按照高度分治 先分别求出 $[l,mid],[mid+1,r]$ 高度的 NTT 乘积,再把两者卷积 $\\sum\\limits_{所有高度}t[i]=N$ 因为分治,每个高度的贡献最多被卷 $\\log n$ 次 总的复杂度是 $O(n\\log^2 n)$ 妙啊 需要注意的就是在算答案的时候当 $s$ 大小为 $x$ 时还要乘上 $fff[n−x]$,因为还有 $n−x$ 组没有分配完 代码dp代码 代码 signed main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n*2; ++i) { cin &gt;&gt; a[i]; ++t[a[i]]; m = max(m, a[i]); } comb.init(n); dp[0][0] = 1; for (int i = 1; i &lt;= m; ++i) { for (int j = 0; j &lt;= t[i]; ++j) { // j's paired with brefore ones for (int k = j; k &lt;= n; ++k) if (k-j+t[i]-j &lt;= n) { dp[i][k-j+t[i]-j] += comb.C(t[i], j)*comb.A(k, j)*dp[i-1][k]; } } } cout &lt;&lt; dp[m][0] &lt;&lt; endl; return 0; } 正解代码 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const int N = 1e5+7; template &lt;typename T, typename H&gt; inline T qpow(const T &amp;a, const H &amp;p, const int &amp;mo = MOD) { long long res = 1, x = a; for (H i = p; i; i &gt;&gt;= 1, x = x*x%mo) if (i&amp;1) res = res*x%mo; return static_cast&lt;T&gt;(res); } struct Combination { int fac[N], inv[N]; void init(const int &amp;n) { fac[0] = inv[0] = fac[1] = inv[1] = 1; for (int i = 2; i &lt;= n; ++i) { fac[i] = 1ll*fac[i-1]*i%MOD; inv[i] = 1ll*(MOD-MOD/i)*inv[MOD%i]%MOD; } for (int i = 2; i &lt;= n; ++i) { inv[i] = 1ll*inv[i]*inv[i-1]%MOD; } } int A(const int &amp;p, const int &amp;q) { return p &gt;= q ? 1ll*fac[p]*inv[p-q]%MOD : 0; } int C(const int &amp;p, const int &amp;q) { return p &gt;= q ? 1ll*fac[p]*inv[q]%MOD*inv[p-q]%MOD : 0; } }; // array [0, n) namespace NTT { static const int SIZE = (1&lt;&lt;17)+3; const int G = 3; int len, bit; int rev[SIZE]; long long f[SIZE], g[SIZE]; template &lt;class T&gt; void ntt(T a[], int flag = 1) { for (int i = 0; i &lt; len; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int base = 1; base &lt; len; base &lt;&lt;= 1) { long long wn = qpow(G, (MOD-1)/(base*2)), w; if (flag == -1) wn = qpow(wn, MOD-2); for (int i = 0; i &lt; len; i += base*2) { w = 1; for (int j = 0; j &lt; base; ++j) { long long x = a[i+j], y = w*a[i+j+base]%MOD; a[i+j] = (x+y)%MOD; a[i+j+base] = (x-y+MOD)%MOD; w = w*wn%MOD; } } } } template &lt;class T&gt; void work(T a[], const int &amp;n, T b[], const int &amp;m) { len = 1; bit = 0; while (len &lt; n+m) len &lt;&lt;= 1, ++bit; for (int i = 0; i &lt; n; ++i) f[i] = a[i]; for (int i = n; i &lt; len; ++i) f[i] = 0; for (int i = 0; i &lt; m; ++i) g[i] = b[i]; for (int i = m; i &lt; len; ++i) g[i] = 0; for (int i = 0; i &lt; len; ++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); ntt(f, 1); ntt(g, 1); for (int i = 0; i &lt; len; ++i) f[i] = f[i]*g[i]%MOD; ntt(f, -1); long long inv = qpow(len, MOD-2); for (int i = 0; i &lt; n+m-1; ++i) f[i] = f[i]*inv%MOD; } } int n, m; int a[N], fff[N]; // fff[i] pair 2i randly vector&lt;int&gt; ff[N]; Combination comb; void solve(int l, int r) { if (l == r) return; int m = (l+r)&gt;&gt;1; solve(l, m); solve(m+1, r); int ll = ff[l].size(), lr = ff[m+1].size(); NTT::work(ff[l].data(), ll, ff[m+1].data(), lr); ff[l].resize(ll+lr-1); for (int i = 0; i &lt; ll+lr-1; ++i) ff[l][i] = NTT::f[i]; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n; for (int i = 1; i &lt;= n*2; ++i) cin &gt;&gt; a[i]; comb.init(n*2); fff[0] = 1; for (int i = 1; i &lt;= n; ++i) fff[i] = fff[i-1]*(i*2-1ll)%MOD; sort(a+1, a+2*n+1); for (int i = 1, j; i &lt;= 2*n; i = j) { j = i+1; while (j &lt;= n*2 &amp;&amp; a[j] == a[i]) ++j; ++m; for (int k = 0; k*2 &lt;= j-i; ++k) ff[m].emplace_back(1ll*comb.C(j-i, k*2)*fff[k]%MOD); } solve(1, m); #ifdef DEBUG for (int &amp;i : ff[1]) cout &lt;&lt; i &lt;&lt; \" \"; cout &lt;&lt; endl; #endif int res = 0; for (int i = 0; i &lt; (int)ff[1].size(); ++i) { int val = 1ll*fff[n-i]*ff[1][i]%MOD; if (i&amp;1) val = (MOD-val)%MOD; (res += val) %= MOD; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 参考资料写这篇博客时官方题解并未发布,且百度上只有一篇题解","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"分治","slug":"分治","permalink":"http://kaizynx.github.io/tags/分治/"},{"name":"NTT","slug":"NTT","permalink":"http://kaizynx.github.io/tags/NTT/"},{"name":"容斥","slug":"容斥","permalink":"http://kaizynx.github.io/tags/容斥/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"TZOJ6200 图的生成树","slug":"tzoj6200","date":"2020-08-30T13:30:00.000Z","updated":"2022-04-10T07:52:45.156Z","comments":true,"path":"2020/08/30/tzoj6200/","link":"","permalink":"http://kaizynx.github.io/2020/08/30/tzoj6200/","excerpt":"","text":"题面链接 描述桃子现在有一张无向无自环无重边的图，图上有N个点和M条边，现在他想知道，如果固定一条边，再来求一个图上的最小生成树，并且在使得在最小生成树根为1的情况下，新的生成树移动的点数最多。 生成树：任意两个点连通，并且任意两个点之间有且仅有一条路径。 生成树权值和：生成树每一条边的权值w总和。 最小生成树：满足生成树的前提下，权值和w最小。 自环：u和v相同。 重边：(1,2)和(1,2)。 输入第一行两个正整数N，M（1&lt;=N&lt;=10^5，N-1&lt;=M&lt;=10^5），代表点数和边数。 接下来M条边，（u，v，w），(1&lt;=u，v&lt;=N，1&lt;=w&lt;=10^9)，代表u和v之间有一条w长度的边。 数据保证所有生成树存在，并且权值w各不相同。 输出输出M行，每行输出两个数，第一个数代表固定一条边的生成树权值和，第二个数是最多有多少个点需要跟着移动，两个数之间用空格隔开。 样例输入4 4 1 2 40 2 3 20 1 4 30 2 4 50 样例输出90 0 90 0 90 0 100 2 提示样例中最小生成树连的边为(1,2,40)和(2,3,20)和(1,4,30)。 固定(1,2,10)和(2,3,20)和(1,4,30)时新的生成树未发生变化。 固定(2,4,50)时新的最小生成树中最多变化的情况是2接到4下，此时变化了两个点，2和3。 思路首先嘛这个题意就该死的买看懂,什么叫做新的生成树移动的点数嘛 不过当你会写了自然就懂了(阿哲 先搞出最小生成树嘛,如果选定最小生成树上的边自然没影响 如果选定的不是最小生成树上的边,我们不考虑重新建树,而是改造最小生成树 相当于加入了一条边 (u, v, w) ,那么树上就会形成一个环 因为最小生成树上的边已经是最优的(边权各不相同,不存在并列最优) 所以不可能改动其他边,最优的做法是删掉环上边权最大的边,使得剩余的还是树 那么这个环就是 u, v 以及他俩一直沿父亲向上到 最近公共祖先 的环 此时我们再看这波加边删边改变了什么,什么叫做新的生成树移动的点数 稍微作图即可发现移动的点就是删除的那条边下面的那个子树 (自己作图自己意会) 以上这些操作可以用树剖或者树上倍增实现(当然是选择倍增啦 复杂度 O((n+m)logn) 代码 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const int N = 1e5+7; const int NN = (int)log2(N)+3; struct Edge { int u, v, w, id; friend bool operator &lt;(const Edge &amp;e1, const Edge &amp;e2) { return e1.w &lt; e2.w; } friend istream&amp; operator &gt;&gt;(istream &amp;is, Edge &amp;e) { return is &gt;&gt; e.u &gt;&gt; e.v &gt;&gt; e.w; } }; struct DSU { int fa[N]; void init(int sz) { for (int i = 0; i &lt;= sz; ++i) fa[i] = i; } int get(int s) { return s == fa[s] ? s : fa[s] = get(fa[s]); } int&amp; operator [] (int i) { return fa[get(i)]; } bool merge(int x, int y) { // merge x to y int fx = get(x), fy = get(y); if (fx == fy) return false; fa[fx] = fy; return true; } }; int n, m; vector&lt;pii&gt; e[N]; DSU dsu; Edge edge[N]; long long sum; long long res1[N]; int res2[N], val[N], num[N]; int f[N][NN], d[N], lg2[N]; long long w[N][NN]; int update(const int &amp;x, const int &amp;y) { return val[x] &lt; val[y] ? y : x; } void build(const int &amp;u = 1, const int &amp;fa = 0) { num[u] = 1; d[u] = d[fa]+1; f[u][0] = fa; for (int i = 1; (1&lt;&lt;i) &lt;= d[u]; ++i) { f[u][i] = f[f[u][i-1]][i-1]; w[u][i] = update(w[u][i-1], w[f[u][i-1]][i-1]); } for (auto &amp;v : e[u]) if (v.first != fa) { w[v.first][0] = v.first; val[v.first] = v.second; build(v.first, u); num[u] += num[v.first]; } } int fuck(int x, int y) { int res = 0; if (d[x] &lt; d[y]) swap(x, y); while (d[x] &gt; d[y]) { res = update(res, w[x][lg2[d[x]-d[y]]]); x = f[x][lg2[d[x]-d[y]]]; } if (x == y) return res; for (int i = lg2[d[x]]; i &gt;= 0; --i) if(f[x][i] != f[y][i]) { res = update(res, w[x][i]); res = update(res, w[y][i]); x = f[x][i], y = f[y][i]; } return update(res, update(w[x][0], w[y][0])); } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); for (int i = 2; i &lt; N; ++i) lg2[i] = lg2[i&gt;&gt;1]+1; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; edge[i]; edge[i].id = i; } sort(edge+1, edge+m+1); dsu.init(n); memset(res2, -1, sizeof res2); for (int i = 1, u, v, w, id; i &lt;= m; ++i) { u = edge[i].u; v = edge[i].v; w = edge[i].w; id = edge[i].id; if (dsu.merge(u, v)) { sum += w; res2[id] = 0; e[u].emplace_back(v, w); e[v].emplace_back(u, w); } } build(); for (int i = 1, u, v, w, id; i &lt;= m; ++i) { u = edge[i].u; v = edge[i].v; w = edge[i].w; id = edge[i].id; if (res2[id] != -1) { res1[id] = sum; } else { int p = fuck(u, v); res1[id] = sum+w-val[p]; res2[id] = num[p]; } } for (int i = 1; i &lt;= m; ++i) { cout &lt;&lt; res1[i] &lt;&lt; \" \" &lt;&lt; res2[i] &lt;&lt; endl; } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://kaizynx.github.io/tags/最小生成树/"},{"name":"树上倍增","slug":"树上倍增","permalink":"http://kaizynx.github.io/tags/树上倍增/"}],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"TZOJ6199 异或序列","slug":"tzoj6199","date":"2020-08-30T13:15:00.000Z","updated":"2022-04-10T07:52:45.155Z","comments":true,"path":"2020/08/30/tzoj6199/","link":"","permalink":"http://kaizynx.github.io/2020/08/30/tzoj6199/","excerpt":"","text":"题面链接 描述给出两个长度为N的序列A={A0,…,AN-1}和B={B0,…,BN-1}。 zdragon将会选择一个整数k（0 &lt;= k &lt; N）和一个非负整数x，来生成一个新的序列C={C0,…,CN-1}，满足Ci=A(i+k) mod N XOR x。 求所有满足B=C的（k，x）。 其中，XOR表示异或，参与运算的两个值，如果两个相应的二进制位相同，该位结果为0，否则为1。 例如：12 XOR 10 = 6 （1100 XOR 1010 = 0110） 输入第一行输入包含一个正整数N（1&lt;=N&lt;=200000）。 第二行输入包含N个整数Ai（0&lt;=Ai&lt;2^30）。 第三行输入包含N个整数Bi（0&lt;=Bi&lt;2^30）。 输出输出所有满足要求的（k，x），每对输出一行，按k升序输出。 若不存在，输出应该为空。 样例输入3 0 2 1 1 2 3 样例输出1 3 提示当（k，x）=（1，3）时，C0=(A1 XOR 3)=1，C1=(A2 XOR 3)=2，C2=(A0 XOR 3)=3。 满足B=C。 思路k 的作用就是把 A 数组平移 根据异或的性质 Bi = Aj ^ x 即 Bi ^ Aj = x 对于位移后每一对匹配的 A, B 都要满足异或相等 这种位运算的题目一般技巧就是把每一位拆开单独看 这样就只有 0, 1 不妨固定 B 数组, 那么 A 数组只有两种情况 要么对应位全相等,要么全相反,分类讨论满足一种即可 再加上 A 可以平移,把 A 看着一个环在旋转,一般情况就是倍长 此时就可以想到用 KMP 匹配, 在倍长的 A 中寻找 B 完全匹配的起点 然后就可以意会了吧,懒得敲了 复杂度 O(n log(maxA)) 代码 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5+7; int n; int aa[N], bb[N], a[N&lt;&lt;1], b[N], res[N], tmp[N]; int nex[N&lt;&lt;1]; inline void get_next(int s[], int sz) { nex[0] = nex[1] = 0; for (int i = 1, j = 0; i &lt; sz; ++i) { while (j &amp;&amp; s[i] != s[j]) j = nex[j]; nex[i+1] = s[i] == s[j] ? ++j : 0; } } inline void kmp() { for (int i = 0, j = 0; i &lt; 2*n; ++i) { while (j &amp;&amp; a[i] != b[j]) j = nex[j]; if (a[i] == b[j]) ++j; if (j == n) { tmp[i-n+1] |= 1; j = nex[j]; } } } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; aa[i]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; bb[i]; for (int i = 0; i &lt; n; ++i) res[i] = 1; for (int k = 0; k &lt; 30; ++k) { for (int i = 0; i &lt; n; ++i) { a[i] = a[i+n] = (aa[i]&gt;&gt;k)&amp;1; b[i] = (bb[i]&gt;&gt;k)&amp;1; tmp[i] = 0; } get_next(b, n); kmp(); for (int i = 0; i &lt; n; ++i) b[i] ^= 1; kmp(); for (int i = 0; i &lt; n; ++i) res[i] &amp;= tmp[i]; } for (int i = 0; i &lt; n; ++i) { if (res[i]) cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; (aa[i]^bb[0]) &lt;&lt; endl; } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://kaizynx.github.io/tags/位运算/"},{"name":"KMP","slug":"KMP","permalink":"http://kaizynx.github.io/tags/KMP/"}],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"ABC176F Brave CHAIN","slug":"AtCoder-ABC176F","date":"2020-08-23T10:00:00.000Z","updated":"2022-04-10T07:52:45.122Z","comments":true,"path":"2020/08/23/AtCoder-ABC176F/","link":"","permalink":"http://kaizynx.github.io/2020/08/23/AtCoder-ABC176F/","excerpt":"","text":"题面链接 给 $3N$ 张牌,值依次是 $A_i$ ,执行 $N-1$ 次如下操作 可以将前五张任意排序,删掉最左边三张,如果删掉的三张值相同,获得 1 分 最后剩下三张,如果值相同,获得 1 分 数据范围: $1 \\leq N \\leq 2000$ $1 \\leq A_i \\leq N$ 思路每次操作相关的卡牌只有上一轮剩下的两张,以及这一轮新加入的三张 考虑数据范围,应该是把上一轮的两张作为 dp 的状态,不难得出 $O(n^3)$ 简单 dp 吧(略 那么如果再稍加思考,就会发现状态转移并不需要对所有状态更新,开始分类讨论 设 $dp[i][j]$ 是上一轮剩下一张 $i$, 一张 $j$ 的最大得分 设新加入的三张分别为 $a[i], a[i+1], a[i+2]$ $a[i] == a[i+1] == a[i+2]$ 这时候如果我们删除这三张,即可使所有状态的 dp 值加 1 如果我们删掉其中两张或一张,再用上轮留下的相同值凑成1分删去,其实是等价的 但如果我们不删除这三张凑成1分,而留下其中几张和后面的凑 显然直接删这三张更优,是贪心的(稍加思考可得 所以一旦出现这种情况,只考虑删掉这三张即可,那么全部状态加1就可以用额外的标记记录 $a[i] == a[i+1] || a[i+1] == a[i+2]$ 此时只要前一轮中一张相同的值即可凑得 1 分 不妨设 $a[i] == a[i+1]$ 那么有 $dp[a[i+2]][k]=dp[a[i]][k]+1$ 新一轮的三个数保留其中两个,不得分 新一轮的三个数保留其中一个,不得分 新一轮的三个数全部删去,不得分,此时状态全不变 注意:状态转移时要用上一轮的状态值转移,为防止当前轮的影响,应先记录需要用到的 dp 值 代码 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const int N = 2e3+7; int n; int a[N*3]; int dp[N][N], mv[N], curmv[N], curdp[N]; inline void update(int x, int y, int z) { if (x &gt; y) swap(x, y); if (z &lt;= dp[x][y]) return; dp[x][y] = z; mv[x] = max(mv[x], z); mv[y] = max(mv[y], z); } inline void solve() { cin &gt;&gt; n; for (int i = 1; i &lt;= 3*n; ++i) cin &gt;&gt; a[i]; memset(dp, 0x9f, sizeof dp); memset(mv, 0x9f, sizeof mv); update(a[1], a[2], 0); int base = 0; for (int i = 3; i+2 &lt;= 3*n; i += 3) { if (a[i] == a[i+1] &amp;&amp; a[i] == a[i+2]) { ++base; continue; } int b[3], maxv = 0; sort(a+i, a+i+3); if (a[i+1] == a[i+2]) swap(a[i], a[i+2]); // fuck there for (int j = 1; j &lt;= n; ++j) { curdp[j] = dp[min(a[i], j)][max(a[i], j)]; curmv[j] = mv[j]; maxv = max(maxv, mv[j]); } for (int j = 0; j &lt; 3; ++j) b[j] = dp[a[i+j]][a[i+j]]; // spj if (a[i] == a[i+1]) for (int j = 1; j &lt;= n; ++j) { // fuck here update(a[i+2], j, curdp[j]+1); // dp[a[i]][j] -&gt; dp[a[i+2]][j] } update(a[i+1], a[i+2], b[0]+1); // get three a[i] update(a[i], a[i+2], b[1]+1); // get three a[i+1] update(a[i], a[i+1], b[2]+1); // get three a[i+2] // two of three rest update(a[i+1], a[i+2], maxv); update(a[i], a[i+2], maxv); update(a[i], a[i+1], maxv); // one of three rest for (int j = 1; j &lt;= n; ++j) { update(a[i], j, curmv[j]); update(a[i+1], j, curmv[j]); update(a[i+2], j, curmv[j]); } } int res = dp[a[3*n]][a[3*n]]+1; for (int i = 1; i &lt;= n; ++i) res = max(res, mv[i]); cout &lt;&lt; res+base &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T = 1; // cin &gt;&gt; T; for (int t = 1; t &lt;= T; ++t) { solve(); } return 0; }","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"杭电多校2020第9场1009 Yajilin","slug":"hdu6875","date":"2020-08-19T13:15:00.000Z","updated":"2022-04-10T07:52:45.151Z","comments":true,"path":"2020/08/19/hdu6875/","link":"","permalink":"http://kaizynx.github.io/2020/08/19/hdu6875/","excerpt":"","text":"题面hdu6875 给 n*n 的平面, 每个点有权值 求把一些点涂黑,要求黑点不共边,且所有白点能形成一条回路 求黑点权值和最大是多少 题解大家都能一眼看出来是典型的插头dp了 Luogu P5056 【模板】插头dp 没错,确实就是插头dp的入门题型,稍加变形,题解也就一句话 插头dp,在求哈密尔顿回路的基础上对每个格子加上一个状态表示是否为黑格即可 前置做这道题的前提是你把上述模板题搞懂 那么就在模板题的基础上讲,按照此人题解讲 定义 state 为当前轮廓线的二进制状态 b1,b2 分别表示右插头和下插头 0表示无插头,1表示左端点,2表示右端点, 3表示涂黑(增加的状态) 其他转移其实和模板题一样,不同的地方就是涂黑的情况和结束情况 涂黑情况因为限制黑格不能上下左右相邻,所以当且仅当右插头和下插头都为0时才能涂黑 小技巧:特判涂黑之后,使3(涂黑)和0(无插头)等价,之后就真的一模一样不用改了 结束情况由于黑格不能上下左右相邻,所以不可能扫描到一半终止(下面全黑) 只可能有两种情况 能在最后一格闭合回路(b1==1 &amp;&amp; b2 == 2) 最后一格涂黑,在倒数第二格闭合回路 特判即可,注意最后一格涂黑的前提是倒数第二行最后一格不涂黑 还有一点模板题求的是方案数,所以 dp 是各种情况相加 这题求的是最值,那么,那么就取最值呗 代码 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; typedef pair&lt;int, int&gt; pii; typedef long long ll; const int P = 1572869; // 3145739 const int INF = 0x3f3f3f3f; const int N = 1e1+7; int n; int a[N][N]; int dp[2][P]; int head[2][P], nex[2][P], tot[2], ver[2][P]; inline void clear(const int &amp;u) { for (int i = 0; i &lt;= tot[u]; ++i) { dp[u][i] = 0; nex[u][i] = 0; head[u][ver[u][i]%P] = 0; } tot[u] = 0; } inline void insert(const int &amp;u, const int &amp;x, const int &amp;v) { int p = x%P; for (int i = head[u][p]; i; i = nex[u][i]) { // 此处取最值而非相加 if (ver[u][i] == x) return dp[u][i] = max(dp[u][i], v), void(); } ++tot[u]; ver[u][tot[u]] = x; nex[u][tot[u]] = head[u][p]; head[u][p] = tot[u]; dp[u][tot[u]] = v; } inline int solve() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { cin &gt;&gt; a[i][j]; } } int u = 0, res = 0, base = (1&lt;&lt;n*2+2)-1; clear(u); insert(u, 0, 0); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { clear(u ^= 1); for (int k = 1; k &lt;= tot[u^1]; ++k) { int state = ver[u^1][k], val = dp[u^1][k]; if (j == 1) state = (state&lt;&lt;2)&amp;base; // b1 right b2 down // 0 no 1 left 2 right 3 black int b1 = (state&gt;&gt;j*2-2)%4, b2 = (state&gt;&gt;j*2)%4; // 处理能涂黑的情况 if (!b1 &amp;&amp; !b2) insert(u, state+(3&lt;&lt;j*2-2)+(3&lt;&lt;j*2), val+a[i][j]); if (b1 == 3) state -= 3&lt;&lt;j*2-2, b1 = 0; if (b2 == 3) state -= 3&lt;&lt;j*2, b2 = 0; // 以下操作和模板题完全一致 if (!b1 &amp;&amp; !b2) { if (i &lt; n &amp;&amp; j &lt; n) insert(u, state+(1&lt;&lt;j*2-2)+(2&lt;&lt;j*2), val); } else if (!b1 &amp;&amp; b2) { if (j &lt; n) insert(u, state, val); if (i &lt; n) insert(u, state+(b2&lt;&lt;j*2-2)-(b2&lt;&lt;j*2), val); } else if (b1 &amp;&amp; !b2) { if (i &lt; n) insert(u, state, val); if (j &lt; n) insert(u, state-(b1&lt;&lt;j*2-2)+(b1&lt;&lt;j*2), val); } else if (b1 == 1 &amp;&amp; b2 == 1) { // find 2 turn to 1 for (int k = j+1, t = 1; k &lt;= n; ++k) { if ((state&gt;&gt;k*2)%4 == 1) ++t; if ((state&gt;&gt;k*2)%4 == 2) --t; if (!t) { insert(u, state-(1&lt;&lt;j*2-2)-(1&lt;&lt;j*2)-(1&lt;&lt;k*2), val); break; } } } else if (b1 == 2 &amp;&amp; b2 == 2) { // find 1 turn to 2 for (int k = j-2, t = 1; k &gt;= 0; --k) { if ((state&gt;&gt;k*2)%4 == 1) --t; if ((state&gt;&gt;k*2)%4 == 2) ++t; if (!t) { insert(u, state-(2&lt;&lt;j*2-2)-(2&lt;&lt;j*2)+(1&lt;&lt;k*2), val); break; } } } else if (b1 == 2 &amp;&amp; b2 == 1) { insert(u, state-(2&lt;&lt;j*2-2)-(1&lt;&lt;j*2), val); } else if (b1 == 1 &amp;&amp; b2 == 2) { // 结束条件的特判 if (i &lt; n) continue; if (j == n-1) { if ((state&gt;&gt;n*2)%4 != 3) res = max(res, val+a[n][n]); } else if (j == n) { res = max(res, val); } } } } } return res; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T = 1; cin &gt;&gt; T; for (int t = 1; t &lt;= T; ++t) { cout &lt;&lt; solve() &lt;&lt; endl; } return 0; } 另附上鄙人板子题代码 总结这题确实感觉就是很基础的插头dp题型,我是恰好暑假开始的时候才学了插头dp,有幸拿了一血 但赛场上这题惨不忍睹,最后只有三个队伍过了,还wa上加wa(我1a1b感到无比自豪) 可能插头dp确实不简单(实不相瞒我洛谷那道入门模板题肝了起码一天吧) 另一方面可能插头dp的题并不常见,甚至罕见,人生能有一次这样的高光时刻可遇而不可求,感谢出题人XP","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[{"name":"插头DP","slug":"插头DP","permalink":"http://kaizynx.github.io/tags/插头DP/"}],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"CF914G Sum the Fibonacci","slug":"Codeforces914G","date":"2020-08-16T10:00:00.000Z","updated":"2022-04-10T07:52:45.132Z","comments":true,"path":"2020/08/16/Codeforces914G/","link":"","permalink":"http://kaizynx.github.io/2020/08/16/Codeforces914G/","excerpt":"","text":"题面洛谷链接 原题地址 思路首先很难过的告诉你这是道纯纯的板子题,但又不是蠢蠢的板子题 你需要对板子有一定的理解才行 首先处理一下输入,重定义 $s_i$ 为值为 $i$ 的数量 然后只要你够熟悉板子,就知道可以分别 FST, FWT 卷积一下就可以求出 $(s_a | s_b),(s_d \\bigotimes s_e)$ 的各种方案的数量 注: $s_a\\&amp; s_b = 0$ 稍加思索,数量乘上对应的斐波那契值就是该二进制对应的权值 记 $(s_a | s_b),s_a \\&amp; s_b = 0$ 的权值数组为 $aor$ 记 $(s_d \\bigotimes s_e)$ 的权值数组为 $axor$ 再把 $s$ 数组乘上斐波那契也变成权值 求 $aor_a \\&amp; s_b \\&amp; axor_c = 2^i$ 我第一个想法是枚举这个 $i$ 此时所需考虑的即第 $i$ 位为 1 的 $a,b,c$ 把 $a,b,c$ 的第 $i$ 位去掉,再做子集卷积即可满足要求 复杂度 $O(17\\times 16^2 2^{16})$ 时限 4s 该做法就 4.5s TLE (菜得不会卡常) 这我就迷惑了,听说 $3^n$ 都给暴艹过去我这怎么不行 然后仔细再看 $A_j \\&amp; B_k = 2^i$ 发现在做子集卷积的时候,只要满足或起来的位数比状态位数恰好多一位即可 即 fwt[__builtin_popcount(i)+1][i] 懂的都懂 复杂度就是子集卷积的复杂度 $O(n^2 2^n)$ 代码都是板子,主要看 main() 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int MOD = 1e9+7; const int N = 1e6+7; const int B = 17; template &lt;typename T&gt; T exgcd(const T a, const T b, T &amp;x, T &amp;y) { if (!b) { x = 1; y = 0; return a; } T d = exgcd(b, a%b, y, x); y -= a/b*x; return d; } template &lt;typename T&gt; inline T mul_inverse(const T &amp;a, const T &amp;mo = MOD) { T x, y; exgcd(a, mo, x, y); return (x%mo+mo)%mo; } namespace FWT { #define forforfor for (int l = 2; l &lt;= len; l &lt;&lt;= 1)\\ for (int i = 0, k = l&gt;&gt;1; i &lt; len; i += l)\\ for (int j = 0; j &lt; k; ++j) const int SIZE = 1&lt;&lt;17; int len; int f[SIZE], g[SIZE]; template &lt;class T&gt; void init(T a[], const int &amp;n, T b[], const int &amp;m) { len = 1; while (len &lt; max(n, m)) len &lt;&lt;= 1; for (int i = 0; i &lt; n; ++i) f[i] = a[i]; for (int i = n; i &lt; len; ++i) f[i] = 0; for (int i = 0; i &lt; m; ++i) g[i] = b[i]; for (int i = m; i &lt; len; ++i) g[i] = 0; } template &lt;class T&gt; void fwt_or(T a[], const int x = 1) { forforfor a[i+j+k] = (a[i+j+k]+1ll*a[i+j]*x)%MOD; } template &lt;class T&gt; void fwt_and(T a[], const int x = 1) { forforfor a[i+j] = (a[i+j]+1ll*a[i+j+k]*x)%MOD; } template &lt;class T&gt; void fwt_xor(T a[], const int x = 1) { forforfor { (a[i+j] += a[i+j+k]) %= MOD; a[i+j+k] = (a[i+j]-2*a[i+j+k]%MOD+MOD)%MOD; a[i+j] = 1ll*a[i+j]*x%MOD; a[i+j+k] = 1ll*a[i+j+k]*x%MOD; } } template &lt;class T&gt; void work_or(const T a[], const int &amp;n, const T b[], const int &amp;m) { init(a, n, b, m); fwt_or(f); fwt_or(g); for (int i = 0; i &lt; len; ++i) f[i] = 1ll*f[i]*g[i]%MOD; fwt_or(f, MOD-1); // fwt_or(x, -1) } template &lt;class T&gt; void work_and(const T a[], const int &amp;n, const T b[], const int &amp;m) { init(a, n, b, m); fwt_and(f); fwt_and(g); for (int i = 0; i &lt; len; ++i) f[i] = 1ll*f[i]*g[i]%MOD; fwt_and(f, MOD-1); // fwt_and(x, -1) } template &lt;class T&gt; void work_xor(const T a[], const int &amp;n, const T b[], const int &amp;m) { init(a, n, b, m); fwt_xor(f); fwt_xor(g); for (int i = 0; i &lt; len; ++i) f[i] = 1ll*f[i]*g[i]%MOD; fwt_xor(f, mul_inverse(2)); // fwt_xor(x, 1/2) } #undef forforfor } // namespace FWT namespace FST { const int W = 17; const int N = 1&lt;&lt;W; int len, bit; int f[W+2][N], g[W+2][N], h[W+2][N], res[N]; template &lt;class T&gt; void fwt(T a[], const int x = 1) { for (int l = 2; l &lt;= len; l &lt;&lt;= 1) for (int i = 0, k = l&gt;&gt;1; i &lt; len; i += l) for (int j = 0; j &lt; k; ++j) a[i+j+k] = (a[i+j+k]+1ll*a[i+j]*x)%MOD; } template &lt;class T&gt; void work(const T a[], const int &amp;n, const T b[], const int &amp;m) { len = 1; bit = 0; while (len &lt; max(n, m)) len &lt;&lt;= 1, ++bit; for (int i = 0; i &lt;= bit+1; ++i) for (int j = 0; j &lt; len; ++j) f[i][j] = g[i][j] = h[i][j] = 0; for (int i = 0; i &lt; n; ++i) f[__builtin_popcount(i)][i] = a[i]; for (int i = 0; i &lt; m; ++i) g[__builtin_popcount(i)][i] = b[i]; for (int i = 0; i &lt;= bit+1; ++i) { fwt(f[i]); fwt(g[i]); for (int j = 0; j &lt;= i; ++j) for (int k = 0; k &lt; len; ++k) h[i][k] = (h[i][k]+1ll*f[j][k]*g[i-j][k])%MOD; fwt(h[i], MOD-1); // fwt(h[i], -1) } for (int i = 0; i &lt; len; ++i) res[i] = h[__builtin_popcount(i)][i]; } } // namespace FST int n; int s[1&lt;&lt;B], fib[1&lt;&lt;B], aor[1&lt;&lt;B], axor[1&lt;&lt;B], aand[1&lt;&lt;B]; signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); fib[0] = 0; fib[1] = 1; for (int i = 2; i &lt; 1&lt;&lt;B; ++i) fib[i] = (fib[i-2]+fib[i-1])%MOD; cin &gt;&gt; n; for (int i = 1, si; i &lt;= n; ++i) cin &gt;&gt; si, ++s[si]; FST::work(s, 1&lt;&lt;B, s, 1&lt;&lt;B); for (int i = 0; i &lt; 1&lt;&lt;B; ++i) aor[i] = 1ll*FST::res[i]*fib[i]%MOD; FWT::work_xor(s, 1&lt;&lt;B, s, 1&lt;&lt;B); for (int i = 0; i &lt; 1&lt;&lt;B; ++i) axor[i] = 1ll*FWT::f[i]*fib[i]%MOD; FWT::work_and(aor, 1&lt;&lt;B, axor, 1&lt;&lt;B); memcpy(aand, FWT::f, sizeof aand); for (int i = 0; i &lt; 1&lt;&lt;B; ++i) s[i] = 1ll*s[i]*fib[i]%MOD; int res = 0; FST::work(aand, 1&lt;&lt;B, s, 1&lt;&lt;B); for (int i = 0; i &lt; 1&lt;&lt;B; ++i) (res += FST::h[__builtin_popcount(i)+1][i]) %= MOD; cout &lt;&lt; res &lt;&lt; endl; return 0; } 另附上述 4.5s TLE 代码 代码 int a[1&lt;&lt;B-1], b[1&lt;&lt;B-1]; signed main() { // 略略略 FST::work(s, 1&lt;&lt;B, s, 1&lt;&lt;B); for (int i = 0; i &lt; 1&lt;&lt;B; ++i) aor[i] = 1ll*FST::res[i]*fib[i]%MOD; FWT::work_xor(s, 1&lt;&lt;B, s, 1&lt;&lt;B); for (int i = 0; i &lt; 1&lt;&lt;B; ++i) axor[i] = 1ll*FWT::f[i]*fib[i]%MOD; FWT::work_and(aor, 1&lt;&lt;B, axor, 1&lt;&lt;B); memcpy(aand, FWT::f, sizeof aand); for (int i = 0; i &lt; 1&lt;&lt;B; ++i) s[i] = 1ll*s[i]*fib[i]%MOD; int res = 0; for (int bit = 0; bit &lt; B; ++bit) { // (sa|sb)&amp;sc&amp;(sd^se) == 1&lt;&lt;bit for (int i = 0, j; i &lt; 1&lt;&lt;B-1; ++i) { j = (i&amp;((1&lt;&lt;bit)-1))+(i&gt;&gt;bit&lt;&lt;bit+1)+(1&lt;&lt;bit); a[i] = aand[j]; b[i] = s[j]; } FST::work(a, 1&lt;&lt;B-1, b, 1&lt;&lt;B-1); for (int i = 0; i &lt; 1&lt;&lt;B-1; ++i) (res += FST::res[i]) %= MOD; } cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"卷积","slug":"卷积","permalink":"http://kaizynx.github.io/tags/卷积/"},{"name":"FWT","slug":"FWT","permalink":"http://kaizynx.github.io/tags/FWT/"},{"name":"FST","slug":"FST","permalink":"http://kaizynx.github.io/tags/FST/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"2020牛客暑期多校训练营(第五场)G","slug":"nowcoder5670G","date":"2020-08-08T14:30:00.000Z","updated":"2022-04-10T07:52:45.153Z","comments":true,"path":"2020/08/08/nowcoder5670G/","link":"","permalink":"http://kaizynx.github.io/2020/08/08/nowcoder5670G/","excerpt":"","text":"序好难一道题呜呜,补题补了半个月 前置知识点: 二分 网络流 虚树 线段树优化建图 树链剖分 题意给 $n$ 个结点的树 ( $n \\leq 20000$)，每个结点给定一个颜色 $c$ 对于每个结点 $u$ 任选一个 $d_u$ 假设以 $u$ 为根的子树中共有 $k_u$ 个颜色为 $d_u$ 的结点 那么这个结点的值为 $k_u\\times d_u$ 求所有结点 值 的 $MEX$ (最小的 不在集合内的 非负整数) 题解暴力容易想到(赛场上想到)这个数据范围甚至可以 $O(n^2)$ 暴力求出每个结点各种颜色有几个 枚举每种颜色，然后树上跑 dfs 即可 然后暴力网络流建图,二分答案,如果能跑满流即满足条件 因为是二分图,时间复杂度 $O(n\\sqrt{m} \\log{n})$ 唯一的缺陷就是空间复杂度,也即边数 $m = n^2$ 正解废话官方给出了可行的方案是线段树优化建图 (什么玩意给我整蒙了) 但学习一下发现所谓的线段树优化建图并不难(吧 但我还是不会嘛,官方给出的题解也是感觉很大一部分都没讲 参考了牛客上的一巨佬用户题解,然后又去学了虚树(我怎么什么都不会) 咕咕了差不多半个月,王老师队出了题解,我总算开始懂了 正文定义 值 为上述 $k_u\\times d_u$ 对于每种颜色建立虚树,每个结点到他父亲的区间 [结点, 父亲) 左闭右开区间 这个区间内结点的子树中当前颜色结点的数量相同,即这些点可以连向一种值 (这里不要忘了虚树顶端到树根节点1的连边) 此处即可线段树优化建图,在寻找 [结点, 父亲) 时可以用树剖往上跳 复杂度分析虚树 时间 $O(n\\log n)$ 空间 $O(n)$ 虚树的点数总和是 $O(n)$ 树剖往上眺每个结点 $O(\\log n)$ 总的复杂度 $O(n\\log n)$ 线段树优化建图总每条边 $O(\\log n)$ 总的 $O(n\\log^2n)$ 网络流点数 $O(n)$ 边数 $O(n\\log^2n)$ 复杂度$O(玄学)$ 优化这里有个奇妙的操作,即在网络流图中,对于树上每条重链 该重链中所有父亲结点向儿子结点连一条边(不包括重链底部的最后一个点) 如果在寻找 [结点, 父亲) 时树剖向上跳跳过了一条重链顶端 就可以把你在这条重链上起跳点往对应的值连INF边即可 就不必对整个区间线段树优化建图 为什么呢?因为起跳点到重链顶端这个区间的点都可以流向对应值 因为父亲往儿子建边,起跳点上面的点就可以流下来到起跳点再到对应值 而该重链上起跳点下面的点则不会流到对应值 另外对于二分,可以跑残余网络 也即当前二分点 $mid$ 满足条件的话,就在残余网络上加边继续跑 如果不满足,就重新建图,或者题解的方法是保存之前网络流图,然后回退(详情见代码 那么二分的这个 $\\log n$ 复杂度应该是能去掉 再分析复杂度除了没有跳过重链顶端的那次,也就是最后一次,最多只会有一次 除了这次用线段树优化建图 $O(\\log n)$ 其他连边边数都是 $O(1)$ 一次树剖跳 $O(\\log n)$ 所以每个区间连的边数就是 $O(\\log n)$ 网络流点数 $O(n)$ 边数 $O(n\\log n)$ 复杂度 $O(能过)$ 小声逼逼我引以为傲的 $ISAP$ 算法竟然被 $Dinic$ 吊打了至少20倍 不知道为什么 $ISAP$ 就妥妥 $TLE$ 呗, $Dinic$ 就跑贼快 果然网络流只有 $O(能过)$ 和 $O(不能过)$ 牛客巨佬用户题解有张图挺好的,建议看下,详情见文末链接 代码 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int INF = 0x3f3f3f3f; const int N = 2e4+7; const int NN = (int)log2(N)+3; struct Dinic { typedef int T; struct EDGE { int v, nex; T w; EDGE(const int &amp;_v, const int &amp;_nex, const T &amp;_w) : v(_v), nex(_nex), w(_w) {} }; vector&lt;EDGE&gt; e; int n, s, t; T maxflow; int fir[N*3], dep[N*3], cur[N*3]; T work(const int &amp;_s, const int &amp;_t) { s = _s; t = _t; T flow; while (bfs()) while ((flow = dfs(s, INF))) maxflow += flow; return maxflow; } void init(const int &amp;_n) { n = _n; e.clear(); maxflow = 0; memset(fir, -1, sizeof(int)*(n+3)); } void add_edge(const int &amp;u, const int &amp;v, const T &amp;w) { e.emplace_back(v, fir[u], w); fir[u] = e.size()-1; e.emplace_back(u, fir[v], 0); fir[v] = e.size()-1; } bool bfs() { queue&lt;int&gt; q; memset(dep, 0, sizeof(int)*(n+3)); q.push(s); dep[s] = 1; for (int i = 0; i &lt;= n; ++i) cur[i] = fir[i]; while (q.size()) { int u = q.front(); q.pop(); for (int i = fir[u], v; i != -1; i = e[i].nex) { v = e[i].v; if (dep[v] || !e[i].w) continue; dep[v] = dep[u]+1; if (v == t) return true; q.push(v); } } return false; } T dfs(const int &amp;u, const T &amp;flow) { if (!flow || u == t) return flow; T rest = flow, now; for (int &amp;i = cur[u], v; i != -1; i = e[i].nex) { v = e[i].v; if (dep[v] != dep[u]+1 || !e[i].w) continue; now = dfs(v, min(rest, e[i].w)); if (!now) { dep[v] = 0; } else { e[i].w -= now; e[i^1].w += now; rest -= now; if (rest == flow) break; } } return flow-rest; } }; Dinic dinic, dinic2; struct SegmentTreeGarph { struct TreeNode { int l, r, ls, rs; int len() const { return r-l+1; } } tr[N&lt;&lt;1]; int tot, root; void build(const int &amp;n) { tot = n; for (int i = 1; i &lt;= n; ++i) tr[i].l = tr[i].r = i; build(1, n, root); } void build(const int &amp;l, const int &amp;r, int &amp;i) { if (l == r) return i = l, void(); i = ++tot; tr[i].l = l; tr[i].r = r; int mid = (l+r)&gt;&gt;1; build(l, mid, tr[i].ls); build(mid+1, r, tr[i].rs); dinic.add_edge(tr[i].ls, i, INF); dinic.add_edge(tr[i].rs, i, INF); } void insert(const int &amp;o, int l, int r) { if (l &gt; r) swap(l, r); insert(o, l, r, root); } void insert(const int &amp;o, const int &amp;l, const int &amp;r, const int &amp;i) { if (tr[i].l &gt;= l &amp;&amp; tr[i].r &lt;= r) return dinic.add_edge(i, o, INF); int mid = (tr[i].l+tr[i].r)&gt;&gt;1; if (l &lt;= mid) insert(o, l, r, tr[i].ls); if (r &gt; mid) insert(o, l, r, tr[i].rs); } } stg; struct HLD { int dfn; int fa[N], d[N], num[N], son[N], id[N], tp[N]; vector&lt;int&gt; *e; template &lt;typename E&gt; void build(E *_e, const int &amp;rt = 1) { e = _e; fa[rt] = dfn = 0; dfs1(rt); dfs2(rt); } void dfs1(const int &amp;u = 1) { d[u] = d[fa[u]]+1; num[u] = 1; son[u] = 0; for (const int &amp;v : e[u]) if (v != fa[u]) { fa[v] = u; dfs1(v); num[u] += num[v]; if (num[v] &gt; num[son[u]]) son[u] = v; } } void dfs2(const int &amp;u = 1) { tp[u] = son[fa[u]] == u ? tp[fa[u]] : u; id[u] = ++dfn; if (son[u]) dfs2(son[u]); for (const int &amp;v : e[u]) if (v != son[u] &amp;&amp; v != fa[u]) dfs2(v); } int lca(int x, int y) { while (tp[x] != tp[y]) { if (d[tp[x]] &lt; d[tp[y]]) swap(x, y); x = fa[tp[x]]; } return d[x] &lt; d[y] ? x : y; } void add_edge(int o, int x, int y) { if (d[x] &lt; d[y]) swap(x, y); // x is son of y while (tp[x] != tp[y]) { dinic.add_edge(id[x], o, INF); x = fa[tp[x]]; } if (x != y) stg.insert(o, id[y]+1, id[x]); } } hld; int n, C, last_mid, last_mid2; int c[N], vfa[N]; vector&lt;int&gt; e[N], ve[N], col[N]; // VirtualTree begin void virtual_tree_clear(const int &amp;u = 1) { for (const int &amp;v : ve[u]) virtual_tree_clear(v); vfa[u] = 0; ve[u].clear(); } // build a VirtualTree return the root int virtual_tree_build(vector&lt;int&gt; &amp;vset) { // id ==&gt; dfn rank, d ==&gt; depth static int stk[N], top; static int *id = hld.id, *d = hld.d; sort(vset.begin(), vset.end(), [&amp;](const int &amp;x, const int &amp;y) { return id[x] &lt; id[y]; }); top = 0; int x, z; for (const int &amp;v : vset) { if (top &amp;&amp; (z = hld.lca(v, stk[top])) != stk[top]) { x = stk[top--]; while (top &amp;&amp; d[stk[top]] &gt; d[z]) { ve[stk[top]].emplace_back(x); vfa[x] = stk[top]; x = stk[top--]; } ve[z].emplace_back(x); vfa[x] = z; if (!top || stk[top] != z) stk[++top] = z; } stk[++top] = v; } x = stk[top--]; while (top) { ve[stk[top]].emplace_back(x); vfa[x] = stk[top]; x = stk[top--]; } return x; } // VirtualTree end // (k*d) ==&gt; 2*n+(k*d) int build_stg(const int &amp;u = 1) { int sum = c[u] == C; for (const int &amp;v : ve[u]) sum += build_stg(v); if (sum*C &lt; n) hld.add_edge(2*n+sum*C, u, vfa[u]); return sum; } void build_network() { dinic.init(n*3+2); stg.build(n); assert(stg.tot &lt; n*2); for (C = 1; C &lt;= n; ++C) if (col[C].size()) { int rt = virtual_tree_build(col[C]); build_stg(rt); virtual_tree_clear(rt); } int st = n*3+1, ed = n*3+2; dinic.add_edge(2*n, ed, 1); // k*d == 0 for (int i = 1; i &lt;= n; ++i) { dinic.add_edge(st, i, 1); dinic.add_edge(i, 2*n, 1); // dinic.add_edge(2*n+i, ed, 0); // key if (hld.fa[i] &amp;&amp; hld.tp[i] != i) dinic.add_edge(hld.fa[i], i, INF); } } bool check(const int &amp;mid) { int st = n*3+1, ed = n*3+2; while (last_mid &lt; mid) dinic.add_edge(2*n+(++last_mid), ed, 1); return dinic.work(st, ed) &gt;= mid+1; } void save_graph() { dinic2 = dinic; last_mid2 = last_mid; } void get_graph() { dinic = dinic2; last_mid = last_mid2; } signed main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(NULL); cin &gt;&gt; n; for (int i = 2, p; i &lt;= n; ++i) { cin &gt;&gt; p; e[p].emplace_back(i); } for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; c[i]; col[c[i]].emplace_back(i); } hld.build(e); int l = 0, r = n-1, mid; last_mid = 0; build_network(); save_graph(); while (l &lt; r) { mid = (l+r+1)&gt;&gt;1; if (check(mid)) { l = mid; save_graph(); } else { r = mid-1; get_graph(); } } cout &lt;&lt; l+1 &lt;&lt; endl; return 0; } 参考资料线段树优化建图网上某博客 题解官方题解 BonVoyage 大爹队的题解 牛客用户 XLor 的题解","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://kaizynx.github.io/tags/网络流/"},{"name":"虚树","slug":"虚树","permalink":"http://kaizynx.github.io/tags/虚树/"},{"name":"线段树优化建图","slug":"线段树优化建图","permalink":"http://kaizynx.github.io/tags/线段树优化建图/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://kaizynx.github.io/tags/树链剖分/"}],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"Educational Codeforces Round 87 (Rated for Div. 2)","slug":"Codeforces1354","date":"2020-05-17T12:30:00.000Z","updated":"2022-04-10T07:52:45.131Z","comments":true,"path":"2020/05/17/Codeforces1354/","link":"","permalink":"http://kaizynx.github.io/2020/05/17/Codeforces1354/","excerpt":"","text":"写在前头应该是鄙人CF史上最好的一次成绩(如果没有fst逃 链接 A - Alarm Clock简单模拟? 特判一下两个特殊情况 一开始就睡爽了,不用补交 $c \\leq d$ 怎么补都肾虚 其他算没补一次 $c-d$ 共要补 $\\lceil\\frac{a-b}{c-d}\\rceil$ (向上取整 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; const int MOD = 998244353; const int INF = 0x3f3f3f3f; int a, b, c, d; inline void solve() { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if (b &gt;= a) return void(cout &lt;&lt; b &lt;&lt; endl); if (c &lt;= d) return void(cout &lt;&lt; -1 &lt;&lt; endl); int e = c-d; long long res = (a-b+e-1ll)/e*c+b; cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T = 1; cin &gt;&gt; T; for (int t = 1; t &lt;= T; ++t) { solve(); } return 0; } B - Ternary String求最短的区间包含 1, 2, 3 设右边界为 $r$ 设 $p[i]$ 是数字 $i$ 出现的最右边位置 则此时的左边界 $l=min({p[1], p[2], p[3]})$ emmm 不多说了 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const int N = 2e5+7; string s; int p[5]; inline void solve() { cin &gt;&gt; s; memset(p, -1, sizeof p); int n = s.size(); int res = 0; for (int i = 0; i &lt; n; ++i) { p[s[i]-'0'] = i; if (p[1] == -1 || p[2] == -1 || p[3] == -1) continue; int cur = i-min({p[1], p[2], p[3]})+1; res = res ? min(res, cur) : cur; } cout &lt;&lt; res &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T = 1; cin &gt;&gt; T; for (int t = 1; t &lt;= T; ++t) { solve(); } return 0; } C - (Not So) Simple Polygon Embedding真就是纯数学几何题 当 $n$ 为偶数 由几何对称美可知(呸)如图多边形就这卡在正方形里面 多边形总有四条边刚好拄在正方形边的中间 $\\theta = \\frac{\\pi}{n}$ $h = \\frac{0.5}{\\tan\\frac{\\theta}{2}}$ 正方形边长 $=2\\times h$ 其实我代码里取的角度不是图上的那个角度,不过这么简单问题不大 当 $n$ 为奇数 根据哦我的上帝啊几何的对称美(明明是瞎转了好久才看出来的)可知 多边形按照如图所示的那个对称轴放置 正方形对角线 $2\\times h$ 正方形边长 $\\frac{2\\times h}{\\sqrt{2}}$ $\\beta = 45°$ $l = \\frac{0.5}{\\sin\\frac{\\theta}{2}}$ 显然 $h$ 的长度和 $l$ 有关 首先知道了这个多边形,我们的正方形怎么得到 我们要用 $a$ 这条边(这条边的斜率是确定的), 去切 $l$ 边的顶点 所以枚举所有顶点,计算不同 $\\theta,l$ 情况下形成不同切边 $a$ 围成正方形 $h$ 的最大值 求最大值是因为要保证所有顶点都在正方形内 又由于哦这该死的对称美我们只需要枚举右上角(第一象限)的顶点即可 怎么求,纯数学几何 $\\begin{cases}2 \\cos\\theta \\cdot h\\cdot l = h^2+l^2-a^2 \\\\2 \\cos\\beta \\cdot h\\cdot a = h^2+a^2-l^2 \\\\\\end{cases}$ 两式相减得 $h\\cdot(\\cos \\theta \\cdot l-\\cos \\beta \\cdot a) = l^2-a^2$ 两式相加得 $h\\cdot(\\cos \\theta \\cdot l+\\cos \\beta \\cdot a) = h^2$ 由相加式得 $h = \\cos \\theta \\cdot l+\\cos \\beta \\cdot a$ 代入相减式得 $(\\cos \\theta \\cdot l)^2+(\\cos \\beta \\cdot a)^2=l^2-a^2$ 解得 $a = \\sqrt{\\frac{(1-\\cos^2\\theta)}{(1-\\cos^2\\beta)}} \\cdot l$ 此时就可以解得 $h$ 了 不过注意这里的 $\\theta$ 第 $i$ 个顶点的 $\\theta=\\frac{i\\cdot\\pi}{n}$ 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const int N = 4e2+7; int n; inline void solve() { double res = 0; // cin &gt;&gt; n; scanf(\"%d\", &amp;n); if (n%2 == 0) { res = tan((n-1)*PI/n/2); } else { double h, theta, l, a, cost; l = 0.5/sin(PI/n/2); for (int i = 1; i &lt;= n/2; ++i) { theta = PI/n*i; cost = cos(theta); a = sqrt(2*(1-cost*cost))*l; h = cost*l+a/sqrt(2); res = max(res, h); } res = 2*res/sqrt(2); } printf(\"%.9f\\n\", res); } signed main() { // ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T = 1; // cin &gt;&gt; T; scanf(\"%d\", &amp;T); for (int t = 1; t &lt;= T; ++t) { solve(); } return 0; } D - Multiset看题第一感觉平板电视红黑树?(可惜我不会也不知道能不能 此题有内存限制(意义不明 我采用树状数组+二分做法,时间复杂度 $O(n\\log^2n)$ (坚信伟大的cf神秘力量) 使用 cin 1341 ms, 吓得我改了 scanf 748 ms,加上手抖罚时 +2 具体就是类似桶排?记录每个值的数字个数 查询的时候二分,某个值之前的数字个数就是排名 应该不难理解? 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const int N = 1e6+7; template &lt;typename T&gt; struct BinaryIndexedTree { int n; T tr[N&lt;&lt;1]; BinaryIndexedTree() { memset(tr, 0, sizeof tr); } void init(const int &amp;_n) { n = _n; clear(); } void clear() { for (int i = 1; i &lt;= n; ++i) tr[i] = 0; } void add(const int &amp;x, const T &amp;v) { for (int i = x ; i &lt;= n; i += i&amp;-i) tr[i] += v; } void add(const int &amp;x, const int &amp;y, const T &amp;v) { add(x, v); add(y+1, -v); } T query(const int &amp;x) { T res = 0; for (int i = x ; i; i -= i&amp;-i) res += tr[i]; return res; } T query(const int &amp;x, const int &amp;y) { return query(y)-query(x-1); } }; int n, q; BinaryIndexedTree&lt;int&gt; bit; int t[N]; inline void solve() { // cin &gt;&gt; n &gt;&gt; q; scanf(\"%d %d\", &amp;n, &amp;q); bit.init(n); for (int i = 1, a; i &lt;= n; ++i) { // cin &gt;&gt; a; scanf(\"%d\", &amp;a); bit.add(a, 1); } for (int i = 1, k, l, r, mid; i &lt;= q; ++i) { // cin &gt;&gt; k; scanf(\"%d\", &amp;k); if (k &gt; 0) { bit.add(k, 1); } else { k = -k; l = 1; r = n; while (l &lt; r) { mid = (l+r)&gt;&gt;1; if (bit.query(mid) &gt;= k) r = mid; else l = mid+1; } bit.add(l, -1); } } // if (bit.query(n) == 0) return void(cout &lt;&lt; 0 &lt;&lt; endl); if (bit.query(n) == 0) return void(puts(\"0\")); for (int i = 1; i &lt;= n; ++i) { if (bit.query(i) &gt; 0) { printf(\"%d\\n\", i); return; } } } signed main() { // ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T = 1; // cin &gt;&gt; T; for (int t = 1; t &lt;= T; ++t) { solve(); } return 0; } E - Graph Coloring能与 1 相邻的有 2 能与 2 相邻的有 1, 3 能与 3 相邻的有 2 不难发现, 1, 3 可以看成一种颜色 于是问题转化为对图奇偶染色(黑白染色) 我们先黑白染色,然后有两种情况 白的赋 2 或者黑的赋 2, 要满足赋 2 的点数为 $n2$ (为什么考虑 2 ? 因为 2 特殊啊, 当然把 1,3 看成一个整体也可以 但是又有一个严重的问题,这个图不一定连通,每个子图都要考虑是黑还是白赋 2 我们用背包来解决这个问题 设 $dp[i][j]$ 是给前 $i$ 个子图黑或白赋 2,是否恰好有 $j$ 个点被赋值 2 然后我们可以 $O(n^2)$ 转移出来,也可以根据 $dp$ 数组倒推回去得到具体方案 (这什么操作啊,我叫不出具体名词) 总之这题大致思路到此应该清晰了,但是细节还是很多很繁琐,详情见代码(溜 另,不满足的情况就是: 无法黑白染色 或 无法恰好有 $n2$ 个点赋 2 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const int N = 5e3+7; struct DSU { int fa[N]; void init(int sz) { for (int i = 0; i &lt;= sz; ++i) fa[i] = i; } int get(int s) { return s == fa[s] ? s : fa[s] = get(fa[s]); } int&amp; operator [] (int i) { return fa[get(i)]; } bool merge(int x, int y) { int fx = get(x), fy = get(y); if (fx == fy) return false; fa[fx] = fy; return true; } }; int n, m, t; int n1, n2, n3; DSU dsu; int col[N], cnt[N][2]; int dp[N][N]; int mp[N], pt[N], paint[N]; int res[N]; vector&lt;int&gt; e[N]; queue&lt;int&gt; q; vector&lt;int&gt; odd; void bfs(const int &amp;s) { q.push(s); col[s] = 0; while (q.size()) { int u = q.front(); q.pop(); for (const int &amp;v : e[u]) { if (col[v] == -1) { col[v] = col[u]^1; q.push(v); dsu.merge(u, v); } else { if (col[u] == col[v]) { cout &lt;&lt; \"NO\" &lt;&lt; endl; exit(0); } } } } } inline void solve() { memset(col, -1, sizeof col); cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; n3; for (int i = 1, u, v; i &lt;= m; ++i) { cin &gt;&gt; u &gt;&gt; v; e[u].emplace_back(v); e[v].emplace_back(u); } dsu.init(n); for (int i = 1; i &lt;= n; ++i) { if (col[i] == -1) bfs(i); } for (int i = 1; i &lt;= n; ++i) { ++cnt[dsu[i]][col[i]]; if (dsu[i] == i) { pt[++t] = i; mp[i] = t; } } dp[0][0] = 1; for (int i = 1; i &lt;= t; ++i) { for (int j = cnt[pt[i]][0]; j &lt;= n; ++j) { dp[i][j] |= dp[i-1][j-cnt[pt[i]][0]]; } for (int j = cnt[pt[i]][1]; j &lt;= n; ++j) { dp[i][j] |= dp[i-1][j-cnt[pt[i]][1]]; } } if (!dp[t][n2]) return void(cout &lt;&lt; \"NO\" &lt;&lt; endl); for (int i = t, rest = n2; i; --i) { if (rest-cnt[pt[i]][0] &gt;= 0 &amp;&amp; dp[i-1][rest-cnt[pt[i]][0]]) { rest -= cnt[pt[i]][0]; paint[pt[i]] = 0; } else { rest -= cnt[pt[i]][1]; paint[pt[i]] = 1; } } for (int i = 1; i &lt;= n; ++i) { if (col[i] == paint[dsu[i]]) res[i] = 2; else odd.emplace_back(i); } for (int i = 0; i &lt; (int)odd.size(); ++i) { res[odd[i]] = (i &lt; n1 ? 1 : 3); } cout &lt;&lt; \"YES\" &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; res[i]; cout &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T = 1; // cin &gt;&gt; T; for (int t = 1; t &lt;= T; ++t) { solve(); } return 0; } F - Summoning Minions首先要观察思考手玩得出: 假设我们选好了前 $k-1$ 个 因为 $b \\geq 0$ 所以对于剩下的全都选一下再删掉(最后一个不删) 为了使结果最优 前 $k-1$ 个要按 $b$ 的升序选 最后留下的(没有删掉的)应该是除掉前 $k-1$ 剩下的当中 $a$ 最大的 想到这里,那么我们要枚举前 $k-1$ 个分别是多少吗? 不,枚举最后一个是哪个就好了 然后我们用动态规划找前 $k-1$ 个的选法 设 $dp[i][j]$ 是在前 $i$ 个中选了 $j$ 个的最大“价值” 我们还需要定义一个所谓的“价值”来衡量一个选法的优秀与否 不妨考虑最后的值 (这里的 $(a_i,b_i)$ 表示第 $i$ 个被选的属性) $=\\sum\\limits_{i=1}^{k}{a_i+(i-1)\\cdot b_i}+\\sum\\limits_{没选的}{k\\cdot b}$ $=\\sum\\limits_{全部}{k\\cdot b}+\\sum\\limits_{i=1}^{k}{a_i-(k-i)\\cdot b_i}$ 因此我们可以把 $\\sum\\limits_{i=1}^{k}{a_i-(k-i)\\cdot b_i}$ 作为衡量函数(即当作$dp$转移的时候的值) 同 E 题,我们可以倒推出到底选了哪几个,那么方案就出来了 时间复杂度 $O(T\\cdot n^3)$ 详情同见代码(溜 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const int N = 80; struct Node { int a, b, id; friend bool operator &lt;(const Node &amp;lhs, const Node &amp;rhs) { return lhs.b &lt; rhs.b; } friend istream&amp; operator &gt;&gt;(istream &amp;is, Node &amp;nd) { return is &gt;&gt; nd.a &gt;&gt; nd.b; } }; int n, k; Node c[N], d[N]; int dp[N][N], val[N], vis[N]; vector&lt;int&gt; seq; // dp[i][j] choose j's [1, i] // val[i] the val choose i as last inline int work() { memcpy(d+1, c+1, sizeof(Node)*n); sort(d+1, d+n); fill(dp[0], dp[0]+n*N, -INF); dp[0][0] = 0; for (int i = 1; i &lt; n; ++i) { memcpy(dp[i], dp[i-1], sizeof(int)*k); for (int j = 1; j &lt; k; ++j) { dp[i][j] = max(dp[i][j], dp[i-1][j-1]+d[i].a-d[i].b*(k-j)); } } return dp[n-1][k-1]+d[n].a; } inline void solve() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i], c[i].id = i; int last = 1; for (int i = 1; i &lt;= n; ++i) { // choose c[i] as last swap(c[i], c[n]); val[i] = work(); if (val[i] &gt; val[last]) last = i; swap(c[i], c[n]); } swap(c[last], c[n]); work(); vector&lt;int&gt;().swap(seq); memset(vis+1, 0, sizeof(int)*n); vis[d[n].id] = 1; for (int i = n-1, j = k-1; i &amp;&amp; j; --i) { if (dp[i][j] == dp[i-1][j-1]+d[i].a-d[i].b*(k-j)) { vis[d[i].id] = 1; seq.emplace_back(d[i].id); --j; } } reverse(seq.begin(), seq.end()); cout &lt;&lt; 2*n-k &lt;&lt; endl; for (auto &amp;i : seq) cout &lt;&lt; i &lt;&lt; \" \"; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) { cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; -i &lt;&lt; \" \"; } cout &lt;&lt; d[n].id &lt;&lt; endl; #ifdef DEBUG for (int i = 1; i &lt;= n; ++i) val[last] += c[i].b*(k-1); cout &lt;&lt; \"val = \" &lt;&lt; val[last] &lt;&lt; endl; #endif } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T = 1; cin &gt;&gt; T; for (int t = 1; t &lt;= T; ++t) { solve(); } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"2020华为软挑小结","slug":"HuaweiCodecraft2020","date":"2020-04-30T15:00:00.000Z","updated":"2022-04-10T07:52:45.134Z","comments":true,"path":"2020/04/30/HuaweiCodecraft2020/","link":"","permalink":"http://kaizynx.github.io/2020/04/30/HuaweiCodecraft2020/","excerpt":"","text":"序言因疫情原因天梯赛遥遥无期，被老刘嫌弃没事干强行安利 最终在lzj巨佬的伟大指引下决定抱hjt巨佬大腿而一试 初赛口头定下了参赛协议然后咕了好几天 后来成功挤进校竞赛群，有幸遇到17级的某技术方面大佬lxy 队伍组建完成，正式开始乱搞 lxy负责输入输出,测试等技术问题,hjt负责核心算法,我负责乱搞(确信 前期hjt巨佬开天辟地提供了一个算法 我执迷于爆搜(dfs)肯定慢，我要搞折半搜索,结果写出来复杂度极高不知道在搞什么 然后基于这个版本优化了一段时间 lxy对IO优化成功提升2s! 大概卡在了2~3s 中期通过对代码各部分耗时分析 发现对环排序耗时大，于是改用了按顺序搜的方式 基于hjt巨佬的核心思路写(并干掉了一个负优化 一举踏入 1s 然后又对常数优化(主要vector换数组，递归改7for大法) 进入了0.5时代 此时也略见端倪，意识到这不是简单的算法比赛，测试数据并不是我们想的那种极端 后期开启多线程时代，玄学调参，常数优化 最后靠调参调到0.35s 但也愈发觉得不对劲，多线程本地提升三倍有余，可线上。。线上数据集到底如何 末期你经历过绝望吗，从三十几名，就这最后两三天，狂掉到一百多名，人都傻了 赛后得知一个绝望的事实线上测试数据只有一组 我就不解释这是个多么窒息的操作了 并且 非常极端，答案集中在三个点上 哦，原来这不是算法大赛，是面向数据编程啊(什么狗屎辣鸡! 真的对华为好感爆减，这届比赛时是真的不行 小结好在前面都是大佬小号,苟进复赛了,不然我操爆华为(雾 搞这种比赛真是挺忙的,不像ACM半天打完,一道题ac即可 现在是对着一份代码使劲优化，每天写不同的版本比较运行效率，真的要投入很大精力 总的通过这次比赛也见识到，学习到一些新奇,ACM几乎碰不到的玩意，像递归改迭代，多线程，mmap等 也算不负此番努力 复赛划水，摸鱼 继起始阶段写了一个版本后就咕咕到了最后一天 期间那个版本经历了 99% -&gt; 0% 始终找不出原因 最后一天下午(正式复赛) 我们竟然试图现场重写(呜呜 理所当然得爆零了,结束 奖品,应该还是混到了的吧(逃 本阶段比赛高光时刻还属 hjt 巨爷在赛后活动了抢答对了一道题 一举成为活动 12 名,赢得了比复赛奖品还要丰厚的礼品(tql 决赛别想了，不可能的 告辞","categories":[],"tags":[],"keywords":[]},{"title":"hexo-mathjax 转义问题","slug":"hexo_mathjax","date":"2020-04-23T11:30:00.000Z","updated":"2022-04-10T07:52:45.151Z","comments":true,"path":"2020/04/23/hexo_mathjax/","link":"","permalink":"http://kaizynx.github.io/2020/04/23/hexo_mathjax/","excerpt":"","text":"之前遇到博客文章的公示显示错误 研究发现是换行没有起作用(换行是两个反斜杠\\) 搜索发现这个是 hexo 的转义造成的 网上流传的方法都是改本地 \\node_modules 里某个文件 可这也…首先这个文件夹存的是 nodejs 的一些插件等 其次我这可是高贵的自动部署博客,这种方法怎么适用呢 废话完 最终在知乎找到了答案 使用四个反斜杠 \\\\\\\\ 同理一个反斜杠不行的地方用两个反斜杠 参考资料","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"绝对值","slug":"abs","date":"2020-04-22T01:50:00.000Z","updated":"2022-04-10T07:52:45.150Z","comments":true,"path":"2020/04/22/abs/","link":"","permalink":"http://kaizynx.github.io/2020/04/22/abs/","excerpt":"","text":"绝对值的性质记 $\\vert a\\vert \\Leftrightarrow abs(a)$ $\\vert a \\vert =\\begin{cases}a, a \\geq 0 \\\\-a, a \\leq 0 \\\\\\end{cases}$ $\\vert a-b \\vert = \\max(a,b)-\\min(a,b)$ $\\vert a-b \\vert = \\max\\{a-b,b-a\\}$ $\\max(a,b)=\\frac{a+b+\\vert a-b \\vert}{2}$ $\\min(a,b)=\\frac{a+b-\\vert a-b \\vert}{2}$ 例题leetcode 1330. 翻转子数组得到最大的数组值题意给定一个数组 $a$ ,可以翻转(reverse)一个区间一次 求 $\\sum \\vert a_i-a_{i+1} \\vert$ 最大值 思路1观察发现 翻转一个数(长度为 1 的区间)不变 翻转后改变的值只和所选区间左右端点有关,区间中间的贡献无影响 我们先计算出没有翻转(或者翻转一个数)情况下的值记为 $base$ 设翻转区间为 $[l, r]$ 则翻转后值为 $base-\\vert a_{l}-a_{l-1}\\vert-\\vert a_{r}-a_{r+1}\\vert+\\vert a_{l-1}-a_{r}\\vert+\\vert a_{l}-a_{r+1}\\vert$ 记 $dif=-\\vert a_{l}-a_{l-1}\\vert-\\vert a_{r}-a_{r+1}\\vert+\\vert a_{l-1}-a_{r}\\vert+\\vert a_{l}-a_{r+1}\\vert$ $\\because \\vert a-b \\vert = \\max(a-b,b-a)$ $\\therefore$ 拆开绝对值后 $a_{l-1},a_{r}$ 异号, $a_{l},a_{r+1}$ 异号 记 $f_1, f_2 \\in \\{1,-1\\}$ $dif=f_1a_{l-1}+f_2a_{l}-\\vert a_{l}-a_{l-1}\\vert-(f_1a_{r}+f_2a_{r+1}+\\vert a_{r}-a_{r+1}\\vert)$ 记 $F(l)=f_1a_{l-1}+f_2a_{l}-\\vert a_{l}-a_{l-1}\\vert$ $G(r)=f_1a_{r}+f_2a_{r+1}+\\vert a_{r}-a_{r+1}\\vert$ 要使得 $dif$ 最大,即求 $\\max F(l)-\\min G(r)$ 枚举所有情况 代码 class Solution { public: int maxValueAfterReverse(vector&lt;int&gt;&amp; nums) { static const int INF = 1e9; int n = nums.size(), base = 0, res, maxf, ming; for (int i = 1; i &lt; n; ++i) base += abs(nums[i-1]-nums[i]); res = base; for (int i = 1; i &lt; n-1; ++i) { res = max(res, base-abs(nums[i]-nums[i+1])+abs(nums[i+1]-nums[0])); // reverse [0, i] res = max(res, base-abs(nums[i]-nums[i-1])+abs(nums[i-1]-nums[n-1])); // reverse [i, n-1] } for (int f1 : {-1, 1}) { for (int f2 : {-1, 1}) { maxf = -INF; ming = INF; for (int i = 1; i &lt; n; ++i) { maxf = max(maxf, f1*nums[i-1]+f2*nums[i]-abs(nums[i-1]-nums[i])); ming = min(ming, f1*nums[i-1]+f2*nums[i]+abs(nums[i-1]-nums[i])); } res = max(res, base+maxf-ming); } } return res; } }; 思路2记 $dif=-\\vert a_{l}-a_{l-1}\\vert-\\vert a_{r}-a_{r+1}\\vert+\\vert a_{l-1}-a_{r}\\vert+\\vert a_{l}-a_{r+1}\\vert$ 因为 $l, r$ 之间关系难料,不妨考虑拆掉 $l, r$ 有关的项 不妨假设 $a_{r} \\leq a_{l-1}$ , 如果条件不成立,就重新假设我们翻转的是 $[r, l]$ 就成立了(逃 咳咳,总之他们的关系没有影响,但一定要严谨得来说的话,设变量 $i, j$ 如果 $a_{r} \\leq a_{l-1}, i=l,j=r$ 如果 $a_{l-1} \\leq a_{r}, i=r+1,j=l-1$ 如此这般,保证了 $a_{r} \\leq a_{i-1}$ $\\begin{aligned}dif&amp;=-\\vert a_{l}-a_{l-1}\\vert-\\vert a_{r}-a_{r+1}\\vert+\\vert a_{l-1}-a_{r}\\vert+\\vert a_{l}-a_{r+1}\\vert \\\\dif&amp;=-\\vert a_{i}-a_{i-1}\\vert-\\vert a_{j}-a_{j+1}\\vert+\\vert a_{i-1}-a_{j}\\vert+\\vert a_{i}-a_{j+1}\\vert \\\\&amp;=a_{i-1}-\\vert a_{i}-a_{i-1}\\vert+\\vert a_{i}-a_{j+1}\\vert-a_{j}-\\vert a_{j}-a_{j+1}\\vert \\\\\\end{aligned}$ 此时分类讨论(上面的不算) 如果 $a_{j+1} \\leq a_{i}$ $\\begin{aligned}dif&amp;=a_{i-1}+a_{i}-\\vert a_{i}-a_{i-1}\\vert-(a_{j}+a_{j+1}+\\vert a_{j}-a_{j+1}\\vert) \\\\&amp;=2\\times\\big( \\min(a_{i-1},a_{i})-max(a_{j}, a_{j+1}) \\big )\\end{aligned}$ 此时要求最大值,则最大化 $\\min(a_{i-1},a_{i})$ 最小化 $max(a_{j}, a_{j+1})$ 就是分别取最值嘛 如果 $a_{i} \\leq a_{j+1}$ $dif=a_{i-1}-a_{i}-\\vert a_{i}-a_{i-1}\\vert-(a_{j}-a_{j+1}+\\vert a_{j}-a_{j+1}\\vert)$ $\\because a_{i-1}-a_{i}-\\vert a_{i}-a_{i-1}\\vert \\leq 0, a_{j}-a_{j+1}+\\vert a_{j}-a_{j+1}\\vert \\geq 0$ $\\therefore dif \\leq 0$ 最后记得特判一下 $l = 0$ 或者 $r=n-1$ 的情况 代码 class Solution { public: int maxValueAfterReverse(vector&lt;int&gt;&amp; nums) { int n = nums.size(), base = 0, res, minmax = 1e9, maxmin = -1e9; for (int i = 1; i &lt; n; ++i) base += abs(nums[i-1]-nums[i]); res = base; for (int i = 1; i &lt; n-1; ++i) { res = max(res, base-abs(nums[i]-nums[i+1])+abs(nums[i+1]-nums[0])); // reverse [0, i] res = max(res, base-abs(nums[i]-nums[i-1])+abs(nums[i-1]-nums[n-1])); // reverse [i, n-1] } for (int i = 1; i &lt; n; ++i) { minmax = min(minmax, max(nums[i-1], nums[i])); maxmin = max(maxmin, min(nums[i-1], nums[i])); } res = max(res, base+2*(maxmin-minmax)); return res; } }; hdoj6435 Problem J. CSGO题意有 $n$ 个 $MW$ 类物品和 $m$ 个 $SW$ 类物品 每个物品有一个属性 $S$ 和 $K$ 个属性 $X$ 求 $S_{MW}+S_{SW}+\\sum\\limits_{i=1}^{k} \\vert X_{MW}[i]-X_{SW}[i] \\vert$ 的最大值 $n \\leq 10^5, K \\leq 5$ 思路想必聪明的你一定注意到了 $K$ 的取值范围,此中一定有鬼! $\\vert a-b \\vert = a-b$ 或 $b-a$ 我们不妨考虑物品每个属性的符号,我们选定的两个物品的同种属性的符号一定是相反的 那么无非两种情况,一正一负,一负一正,我们猜测要么正确,要么相反 正确不用管,我们看一下如果猜错了 设正确答案是 $a-b \\geq 0$ ,猜测为 $b-a \\leq 0$ 猜错得到的结果肯定劣于正确结果,那我们就可以放心大胆的枚举所有情况了 详细地说就是记录物品每种属性取正负($2^k$ 种)情况下的贡献 合并两种物品只要保证这两种物品的属性选取正负完全相反即可(位运算) 贪心可得当物品属性选取正负确定时,要取值最大的物品 感觉讲起来没有代码清楚 $O(nk2^k)$ 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const int N = 1e5+7; const int K = 5; const int MOD = 998244353; const long long INF = 1e18; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; int n, m, k; int xmw[N][K], xsw[N][K]; long long vmw[N][1&lt;&lt;K], vsw[N][1&lt;&lt;K]; long long mmw[1&lt;&lt;K], msw[1&lt;&lt;K]; inline void solve() { memset(mmw, 0x8f, sizeof mmw); memset(msw, 0x8f, sizeof msw); scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); for (int i = 1, s; i &lt;= n; ++i) { scanf(\"%d\", &amp;s); for (int j = 0; j &lt; k; ++j) scanf(\"%d\", &amp;xmw[i][j]); for (int j = 0; j &lt; 1&lt;&lt;k; ++j) { vmw[i][j] = s; for (int l = 0; l &lt; k; ++l) vmw[i][j] += ((j&gt;&gt;l)&amp;1 ? 1 : -1)*xmw[i][l]; mmw[j] = max(mmw[j], vmw[i][j]); } } for (int i = 1, s; i &lt;= m; ++i) { scanf(\"%d\", &amp;s); for (int j = 0; j &lt; k; ++j) scanf(\"%d\", &amp;xsw[i][j]); for (int j = 0; j &lt; 1&lt;&lt;k; ++j) { vsw[i][j] = s; for (int l = 0; l &lt; k; ++l) vsw[i][j] += ((j&gt;&gt;l)&amp;1 ? 1 : -1)*xsw[i][l]; msw[j] = max(msw[j], vsw[i][j]); } } long long res = -INF; for (int i = 0, j, base = (1&lt;&lt;k)-1; i &lt; 1&lt;&lt;k; ++i) { j = base^i; res = max(res, mmw[i]+msw[j]); } printf(\"%lld\\n\", res); } signed main() { int testcase = 1; scanf(\"%d\", &amp;testcase); for (int i = 1; i &lt;= testcase; ++i) { solve(); } return 0; } $O(n2^k)$ 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const int N = 1e5+7; const int K = 5; const int MOD = 998244353; const long long INF = 1e18; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; int n, m, k; int xmw[K], xsw[K]; long long vmw[1&lt;&lt;K], vsw[1&lt;&lt;K], mmw[1&lt;&lt;K], msw[1&lt;&lt;K]; int lg2[1&lt;&lt;K]; inline int lowbit(const int &amp;x) { return x&amp;-x; } inline void solve() { memset(mmw, 0x8f, sizeof mmw); memset(msw, 0x8f, sizeof msw); scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); for (int i = 1, s; i &lt;= n; ++i) { scanf(\"%d\", &amp;s); vmw[0] = s; for (int j = 0; j &lt; k; ++j) { scanf(\"%d\", &amp;xmw[j]); vmw[0] -= xmw[j]; } mmw[0] = max(mmw[0], vmw[0]); for (int j = 1, l; j &lt; 1&lt;&lt;k; ++j) { l = lowbit(j); vmw[j] = vmw[j^l]+2*xmw[lg2[l]]; mmw[j] = max(mmw[j], vmw[j]); } } for (int i = 1, s; i &lt;= m; ++i) { scanf(\"%d\", &amp;s); vsw[0] = s; for (int j = 0; j &lt; k; ++j) { scanf(\"%d\", &amp;xsw[j]); vsw[0] -= xsw[j]; } msw[0] = max(msw[0], vsw[0]); for (int j = 1, l; j &lt; 1&lt;&lt;k; ++j) { l = lowbit(j); vsw[j] = vsw[j^l]+2*xsw[lg2[l]]; msw[j] = max(msw[j], vsw[j]); } } long long res = -INF; for (int i = 0, j, base = (1&lt;&lt;k)-1; i &lt; 1&lt;&lt;k; ++i) { j = base^i; res = max(res, mmw[i]+msw[j]); } printf(\"%lld\\n\", res); } signed main() { for (int i = 0; i &lt; K; ++i) lg2[1&lt;&lt;i] = i; int T; scanf(\"%d\", &amp;T); while (T--) solve(); return 0; } codeforces1093G. Multidimensional Queries题意与上一题(hdoj)类似,区别是多次询问,求给定区间内的最大值 思路加以数据结构维护最值即可(口胡起来真容易 这里用了单点修改区间查询的线段树 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const int N = 2e5+7; const int K = 5; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; template &lt;typename T, typename U = greater&lt;T&gt;&gt; struct SegmentTree { U cmp = U(); int n; T tr[N&lt;&lt;2], lazy[N&lt;&lt;2], init_val = cmp(0, 1) ? INF : -INF; SegmentTree(){} T mv(const T &amp;x, const T &amp;y) { return cmp(x, y) ? x : y;} void build(const int &amp;_n, const T &amp;k = 0) { n = _n; _build(1, n, k); } void modify(const int &amp;x, const T &amp;k) { _modify(x, k, 1, n); } T query(const int &amp;l, const int &amp;r) { return _query(l, r, 1, n); } private : void push_up(const int &amp;i) { tr[i] = mv(tr[i&lt;&lt;1], tr[i&lt;&lt;1|1]); } void push_down(const int &amp;i) { if (!lazy[i]) return; tr[i&lt;&lt;1] += lazy[i]; tr[i&lt;&lt;1|1] += lazy[i]; lazy[i&lt;&lt;1] += lazy[i]; lazy[i&lt;&lt;1|1] += lazy[i]; lazy[i] = 0; } void _build(const int &amp;l, const int &amp;r, const T &amp;k = 0, const int &amp;i = 1) { lazy[i] = 0; if (l == r) { tr[i] = k; return; } int mid = (l+r)&gt;&gt;1; _build(l, mid, k, i&lt;&lt;1); _build(mid+1, r, k, i&lt;&lt;1|1); push_up(i); } void _modify(const int &amp;x, const T &amp;k, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl == x &amp;&amp; trr == x) { tr[i] = k; return; } push_down(i); int mid = (trl+trr)&gt;&gt;1; if (x &lt;= mid) _modify(x, k, trl, mid, i&lt;&lt;1); else _modify(x, k, mid+1, trr, i&lt;&lt;1|1); push_up(i); } T _query(const int &amp;l, const int &amp;r, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl &gt;= l &amp;&amp; trr &lt;= r) return tr[i]; push_down(i); int mid = (trl+trr)&gt;&gt;1; T res = init_val; if (l &lt;= mid) res = mv(res, _query(l, r, trl, mid, i&lt;&lt;1)); if (r &gt; mid) res = mv(res, _query(l, r, mid+1, trr, i&lt;&lt;1|1)); return res; } }; int n, k, q; int a[N][K]; int va[N][1&lt;&lt;K]; int lg2[1&lt;&lt;K]; SegmentTree&lt;int&gt; ST[1&lt;&lt;K]; inline void calc(const int &amp;x) { va[x][0] = 0; for (int i = 0; i &lt; k; ++i) { va[x][0] -= a[x][i]; } for (int i = 1, j; i &lt; 1&lt;&lt;k; ++i) { j = i&amp;-i; va[x][i] = va[x][i^j]+2*a[x][lg2[j]]; } } inline void update(const int &amp;x) { for (int i = 0; i &lt; 1&lt;&lt;k; ++i) { ST[i].modify(x, va[x][i]); } } signed main() { for (int i = 1; i &lt; K; ++i) lg2[1&lt;&lt;i] = i; scanf(\"%d %d\", &amp;n, &amp;k); for (int i = 0; i &lt; 1&lt;&lt;k; ++i) ST[i].build(n); for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt; k; ++j) { scanf(\"%d\", &amp;a[i][j]); } calc(i); update(i); } scanf(\"%d\", &amp;q); int op, x, l, r, res; while (q--) { scanf(\"%d\", &amp;op); if (op == 1) { scanf(\"%d\", &amp;x); for (int i = 0; i &lt; k; ++i) { scanf(\"%d\", &amp;a[x][i]); } calc(x); update(x); } else { scanf(\"%d %d\", &amp;l, &amp;r); res = -INF; for (int i = 0, j, base = (1&lt;&lt;k)-1; i &lt;= base; ++i) { j = base^i; res = max(res, ST[i].query(l, r)+ST[j].query(l, r)); } printf(\"%d\\n\", res); } } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[{"name":"abs","slug":"abs","permalink":"http://kaizynx.github.io/tags/abs/"}],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"递归改迭代","slug":"recursion_to_iteration","date":"2020-04-21T06:00:00.000Z","updated":"2022-04-10T07:52:45.154Z","comments":true,"path":"2020/04/21/recursion_to_iteration/","link":"","permalink":"http://kaizynx.github.io/2020/04/21/recursion_to_iteration/","excerpt":"","text":"序言不得不承认递归是个神奇且强大的东西 但它却也存在致命的缺陷:递归层数太大会爆栈 另一方面递归开销也大于循环,因面临相关方面(时空受限)问题,于此寻找递归改迭代方法 正文思路应该很明了? 就是自己模拟一个栈,记录函数运行的信息 栈是先进后出的数据结构,符合递归的要求 本试图在某度上寻找,结果都是无关紧要的尾递归改迭代? 下面就以 SCC|Tarjan 算法为例(其实我只会了这个) 例题汉诺塔20210406 update 在做程序设计课程实践作业时有一题是用非递归实现汉诺塔 我当时就震惊了,递归改迭代这么高级的技术都能写吗 我并不知正解,也许是栈之类,反正我改迭代了,其实这个比下面的例子简单 自行看代码,懒得写解析了,可以直接看下面的例子 void hanio(int n, int t1 = 1, int t2 = 2, int t3 = 3) { if (n &lt; 1) return; hanio(n-1, t1, t3, t2); cout &lt;&lt; &quot;from &quot; &lt;&lt; t1 &lt;&lt; &quot; to &quot; &lt;&lt; t3 &lt;&lt; &#39;\\n&#39;; hanio(n-1, t2, t1, t3); } void hanio(int sz) { stack&lt;int&gt; sn, st1, st2, st3, ss; int n, t1, t2, t3, state; function&lt;void()&gt; push = [&amp;]() { sn.push(n); st1.push(t1); st2.push(t2); st3.push(t3); ss.push(state); }; function&lt;void()&gt; top = [&amp;]() { n = sn.top(); t1 = st1.top(); t2 = st2.top(); t3 = st3.top(); state = ss.top(); }; function&lt;void()&gt; pop = [&amp;]() { sn.pop(); st1.pop(); st2.pop(); st3.pop(); ss.pop(); }; n = sz; t1 = 1; t2 = 2; t3 = 3; state = 0; push(); while (sn.size()) { top(); pop(); switch (state) { case 0: if (n &lt; 1) continue; state = 1; push(); n -= 1; swap(t2, t3); state = 0; push(); continue; case 1: cout &lt;&lt; &quot;from &quot; &lt;&lt; t1 &lt;&lt; &quot; to &quot; &lt;&lt; t3 &lt;&lt; &#39;\\n&#39;; n -= 1; swap(t1, t2); state = 0; push(); } } } 例题Tarjan[USACO06JAN]The Cow Prom S 题目描述: 有一个 n 个点，m 条边的有向图，请求出这个图点数大于 1 的强联通分量个数。 递归版接下来将根据这份代码来改成非递归版本 代码 #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const int N = 1e4+7; const int MOD = 998244353; const int INF = 0x3f3f3f3f; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; int n, m; vector&lt;int&gt; e[N]; int cnt[N]; int _dfn, _col, _top; int dfn[N], low[N], ins[N], col[N], sta[N]; void tarjan(const int &amp;u) { dfn[u] = low[u] = ++_dfn; ins[u] = 1; sta[++_top] = u; for (int i = 0; i &lt; (int)e[u].size(); ++i) { int v = e[u][i]; if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (ins[v]) { low[u] = min(low[u], low[v]); } } if (dfn[u] == low[u]) { ++_col; do { col[sta[_top]] = _col; ins[sta[_top]] = 0; } while (sta[_top--] != u); } } signed main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1, u, v; i &lt;= m; ++i) { cin &gt;&gt; u &gt;&gt; v; e[u].emplace_back(v); } for (int i = 1; i &lt;= n; ++i) { if (!dfn[i]) tarjan(i); ++cnt[col[i]]; #ifdef DEBUG cout &lt;&lt; col[i] &lt;&lt; \" \\n\"[i==n]; #endif } int res = 0; for (int i = 1; i &lt;= _col; ++i) { res += cnt[i] &gt; 1; } cout &lt;&lt; res &lt;&lt; endl; return 0; } 非递归版本先贴代码 int _dfn, _col, _top; int dfn[N], low[N], ins[N], col[N], sta[N]; struct Stack_Node { // 1 int u; int edge_info; int state; } tarjan_stack[N]; void tarjan(const int &amp;u) { static int stack_top; stack_top = 0; // 2 tarjan_stack[++stack_top] = {u, 0, 0}; while (stack_top) { bool flag = false; // 3 int &amp;u = tarjan_stack[stack_top].u; // 4 auto &amp;i = tarjan_stack[stack_top].edge_info; switch (tarjan_stack[stack_top].state) { case 0 : tarjan_stack[stack_top].state = 1; // 5 flag = false; dfn[u] = low[u] = ++_dfn; ins[u] = 1; sta[++_top] = u; for (; i &lt; (int)e[u].size(); ++i) { #define v e[u][i] // 6 if (!dfn[v]) { tarjan_stack[++stack_top] = {v, 0, 0}; // 7 flag = true; break; case 1 : // 8 flag = false; low[u] = min(low[u], low[v]); } else if (ins[v]) { low[u] = min(low[u], low[v]); } #undef v } if (flag) break; // 9 if (dfn[u] == low[u]) { ++_col; do { col[sta[_top]] = _col; ins[sta[_top]] = 0; } while (sta[_top--] != u); } --stack_top; } } } 以上代码如果只看三层缩进的代码,其实就几乎是递归版本的代码 一层缩进是模拟栈 二层缩进就是神奇的 switch 大法控制递归状态了(重点) 记住一个特性,如果 switch 没有 break, 那么匹配项(case) 之后的代码会一直执行下去,直到 break 或 switch 末尾为止 定义了个结构体用来存储函数运行的信息 依次存了当前的结点 u 循环到的边的信息 edge_info(本文存储的是边的序号,也可以存迭代器等等) 函数的递归状态 state(后面详细讲) 因为 tarjan 函数不只执行一次,记得清空栈(虽然不清空一般没事) 然后就是原本第一层的函数,将它入栈,开始模拟栈 这个 flag 标记很重要(重点)后面详细讲 取出栈里的信息,得到当前函数的信息 注意我在这里采用了引用的形式,因为函数一般执行那么函数信息就会改变 比如你遍历了一条边,该轮到下一条边了,栈里存储的信息也要对于改变,用引用就省去了记录 修改状态,下面讲 注意这里使用了宏替换,也是方便起见,为什么不能像原来一样呢? 因为如果你直接跳转到了 case 1, 这个 v 就是未定义的 不过方便的同时这个宏定义也非常危险(宏定义代码块内不得出现字符 v ) 当然最保险的办法还是老老实实写 e[u][i] 重点来了,递归部分,我们模拟栈,那么应该入栈(开辟下一层函数) 然后我们应该暂时跳出当前函数,这里通过 flag 来实现 这里真就是 switch 的神奇了.注意这里的 break, 跳出的是 for 循环(不是 case) 也就是说我们来到了 9 的位置(通过简单的 gdb 调试易得) 通过 break,我们就推出了 switch 也就相当于推出了当前函数 注意到 5, 这一层函数递归状态改为了 1, 如果没有进入下一层(7) 就会继续执行下去没有影响 但如果有下一层递归,我们知道下一层(7)执行完毕后要回到 8, state 的记录满足了这一条件,同时不要忘记把 flag 改回去 如 7 所述 如果不明白想一下所有情况 if(!dfn[v]) 进入下一层递归,在 7 处入栈,跳出switch,下一层 while, 此时栈顶就是新加的函数 if(dfn[v]) 跳到 elseif 正常执行 执行完了回退到上一层递归函数,会进入 case 1, 循环往复 如果还不明白呢,建议单步调试一下看一下过程(毕竟我只会口胡 总结据此可以类比到任何形式递归改迭代了吧?(反正我不行(逃 总的来说并不是很好写吧(递归不香吗 如果不是对时间空间有限制的话(汇编手动扩栈不香吗 参考资料github Yangff/dfs-benchmark","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://kaizynx.github.io/tags/递归/"},{"name":"常数优化","slug":"常数优化","permalink":"http://kaizynx.github.io/tags/常数优化/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"多线程","slug":"MultiThread","date":"2020-04-03T10:00:00.000Z","updated":"2022-04-10T07:52:45.147Z","comments":true,"path":"2020/04/03/MultiThread/","link":"","permalink":"http://kaizynx.github.io/2020/04/03/MultiThread/","excerpt":"","text":"线程管理线程管理基础void do_some_work(); std::thread my_thread(do_some_work); my_thread.detach(); // 分离,不管这个线程了继续执行 if(my_thread.joinable()) my_thread.join(); // 等这个线程执行完 向线程函数传递参数void f(int i, std::string const&amp; s); std::thread t(f, 3, &quot;hello&quot;); 引用传递std::thread 的构造函数无视函数期待的参数类型，并盲目地拷贝已提供的变量… void f(int a, int &amp;b); int c, d; std::thread my_thread(f, c, std::ref(d)); 线程数量std::thread::hardware_concurrency() 这个函数会返回能并发在一个程序中的线程数量。例如，多核系统中，返回值可以是CPU核芯的数量。返回值也仅仅是一个提示，当系统信息无法获取时，函数也会返回0。 标识线程std::thread::id // 数据类型 my_thread.get_id() std::this_thread::get_id() // 自己线程id 线程间共享数据使用互斥量保护共享数据C++中使用互斥量C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，在构造时就能提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。 std::list&lt;int&gt; some_list; // 1 std::mutex some_mutex; // 2 void add_to_list(int new_value) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); // 3 some_list.push_back(new_value); } bool list_contains(int value_to_find) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); // 4 return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end(); } 菜鸡理解:some_mutex 作为一个标记，当执行3,4时，标记置为 lock，则无法访问，函数结束后自行 unlock 一意咕行pthreadthread 是 C++11 对 pthread 的封装 原生 windows 不支持 pthread ,需要捣鼓一番 #include &lt;pthread.h&gt; const int THREAS_COUNT = 8; struct Info { int start, end; }; void* f(void *_arg) { Info arg = *(Info*)_arg; // do something } int main() { int part = n / THREAD_COUNT; pthread_attr_t attr; void *status; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); Info info[THREAD_COUNT]; pthread_t threads[THREAD_COUNT]; for (re int i = 0; i &lt; THREAD_COUNT; ++i) { info[i].start = i * part, info[i].end = i * part + part; } info[THREAD_COUNT-1].end = n; for (re int i = 0; i &lt; THREAD_COUNT; ++i) { int rc = pthread_create(&amp;threads[i], NULL, f, (void*)&amp;(info[i])); if (rc) cerr &lt;&lt; &quot;Wrong!&quot; &lt;&lt; endl; } pthread_attr_destroy(&amp;attr); for (re int i = 0; i &lt; THREAD_COUNT; ++i) { int rc = pthread_join(threads[i], &amp;status); if (rc) cerr &lt;&lt; &quot;Wrong!&quot; &lt;&lt; endl; } } 参考资料《C++ Concurrency in Action - SECOND EDITION》 linux下把进程/线程绑定到特定cpu核上运行","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://kaizynx.github.io/tags/多线程/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"KMP+数位DP","slug":"kmp_and_dp","date":"2020-04-02T03:00:00.000Z","updated":"2022-04-10T07:52:45.152Z","comments":true,"path":"2020/04/02/kmp_and_dp/","link":"","permalink":"http://kaizynx.github.io/2020/04/02/kmp_and_dp/","excerpt":"","text":"例一luogu P3193 [HNOI2008]GT考试 思路容易想到是数位dp, 设 $dp[i]$ 是准考证号到第 $i$ 位的方案数 错误思路: $dp[i] = dp[i-1]*(当前位可选方案数)-(选了第i位重复的方案)$ 简单的想重复的方案就是最后一段是不吉利数字,就有 $dp[i-m]$ 但就如样例所示的不吉利数字如果是 111 在 $dp[i-1]$ 已经排除了 $i-1$ 位是 1, $i-2$ 位是 1 的情况 转移 $dp[i]$ 要在 $dp[i-1]$ 的基础上做排除, 就会重复排除 $i-1$ 位是 1, $i-2$ 位是 1 的情况 所以这时候就要考虑 KMP 设 $dp[i][j]$ 是到第 $i$ 位准考证, 正在匹配不吉利数字的第 $j$ 位 时候的方案数 对于下一位加进来的数字,就可以根据 KMP 转移 $j$ 如果匹配 $dp[i][j] -&gt; dp[i+1][j+1]$ 如果不匹配 $dp[i][j] -&gt; dp[i+1][用KMP匹配找到某next?]$ 最后答案要求不能完全匹配不吉利数字 设不吉利数组是 $[0, m)$ 那么 $j == m$ 就是全匹配了 $res=\\sum\\limits_{i=0}^{m-1}dp[n][i]$ 因为 $n$ 很大，所以考虑 矩阵快速幂 预处理出一个数组 $g[i][k]$ 表示从不吉利数字匹配到 $i$ 位转移到第 $k$ 位的方案 对于不吉利数字每一位 $i$ 枚举新加入的数字 $0 -9$ 用KMP匹配出 $k$ 此时状态转移方程为 $dp[i][j] = \\sum\\limits_{k=0}^{m-1}dp[i-1][k]\\times g[k][j]$ 构造矩阵 $$\\begin{bmatrix}f[i][0] &amp; f[i][1] &amp; \\cdots &amp; f[i][m]\\end{bmatrix}\\times\\begin{bmatrix}g[0][0] &amp; g[0][1] &amp; \\cdots &amp; g[0][m] \\\\g[1][0] &amp; g[1][1] &amp; \\cdots &amp; g[1][m] \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\g[m][0] &amp; g[m][1] &amp; \\cdots &amp; g[m][m]\\end{bmatrix}=\\begin{bmatrix}f[i+1][0] &amp; f[i+1][1] &amp; \\cdots &amp; f[i+1][m]\\end{bmatrix}$$ $F_0\\times G^n=F_n$ 初始状态 $f[0][0]=1$ $F_n[\\cdots]=G^n[0][\\cdots]$ 代码 代码 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 30; const int INF = 0x3f3f3f3f; const double eps = 1e-7; const double PI = acos(-1); typedef pair&lt;int, int&gt; pii; int MOD = 998244353; template &lt;typename T&gt; struct Martix { int n, m; T a[N][N]; Martix(){} Martix(const int &amp;_n) : n(_n), m(_n) { init(); } Martix(const int &amp;_n, const int &amp;_m) : n(_n), m(_m) { init(); } T* operator [] (const int &amp;i) { return a[i]; } void init(const int &amp;tag = 0) { for (int i = 0; i &lt; n; ++i) memset(a[i], 0, sizeof(T)*(n+1)); for (int i = 0; i &lt; n; ++i) a[i][i] = tag; } friend Martix operator * (const Martix &amp;m1, const Martix &amp;m2) { Martix res(m1.n, m2.m); for (int i = 0; i &lt; res.n; ++i) for (int j = 0; j &lt; res.m; ++j) for (int k = 0; k &lt; m1.m; ++k) res.a[i][j] = (res.a[i][j]+m1.a[i][k]*m2.a[k][j])%MOD; return res; } Martix&amp; operator *= (const Martix &amp;mx) { return *this = *this*mx; } template &lt;typename TT&gt; Martix pow(const TT &amp;p) const { Martix res(n, m), a = *this; res.init(1); for (TT i = p; i; i &gt;&gt;= 1, a *= a) if (i&amp;1) res *= a; return res; } friend ostream&amp; operator &lt;&lt; (ostream &amp;os, Martix&lt;T&gt; &amp;mx) { for (int i = 0; i &lt; mx.n; ++i) for (int j = 0; j &lt; mx.m; ++j) os &lt;&lt; mx[i][j] &lt;&lt; \" \\n\"[j==mx.m-1]; return os; } }; int n, m; int nex[N]; string s; Martix&lt;int&gt; g; inline void get_next() { nex[0] = nex[1] = 0; for (int i = 1, j = 0; i &lt; (int)s.size(); ++i) { while (j &amp;&amp; s[i] != s[j]) j = nex[j]; nex[i+1] = s[i] == s[j] ? ++j : 0; } } inline void kmp() { for (int i = 0; i &lt; m; ++i) { for (int j = 0, k; j &lt;= 9; ++j) { for (k = i; k &amp;&amp; j != s[k]-'0'; k = nex[k]) {} if (j == s[k]-'0') ++k; ++g[i][k]; } } } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m &gt;&gt; MOD &gt;&gt; s; g.n = g.m = m+1; get_next(); kmp(); g = g.pow(n); int res = 0; for (int i = 0; i &lt; m; ++i) (res += g[0][i]) %= MOD; cout &lt;&lt; res &lt;&lt; endl; return 0; } 例二leetcode P3193 [HNOI2008]GT考试 思路这题与上题不同的地方主要就是有上限下限限制 一般的解决技巧就是 [0, 上限] - [0, 下限) 转化成只有上限 设 $dp[i][j][k]$ 是枚举到第 $i$ 位正在匹配 $evil[j]$ , $k$ 表示是否达到上限 因为对每一位的字母有要求,所以我们修改一下 $g$ 数组 令 $g[i][j]$ 表示匹配 $evil[i]$ 时新加的字母是 $j$ 转移到的下标 $dp$ 状态转移应该就是经典的数位dp转移 (其实是懒得写了) tips: 因为难以得到 下限-1, 所以用 [0, 上限]-[0, 下限]+(下限是好字符串就减多了) 代码 代码 class Solution { public: int findGoodStrings(int n, string s1, string s2, string evil) { const int MOD = 1e9+7; int m = evil.size(); int nex[n+3]; int g[m+3][30]; int dp[n+3][m+3][2]; memset(g, 0, sizeof g); memset(nex, 0, sizeof nex); // get_next nex[0] = nex[1] = 0; for (int i = 1, j = 0; i &lt; m; ++i) { while (j &amp;&amp; evil[i] != evil[j]) j = nex[j]; nex[i+1] = evil[i] == evil[j] ? ++j : 0; } // use 'a'+j to kmp i'th evil to the pos for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; 26; ++j) { if (evil[i]-'a' == j) g[i][j] = i+1; else g[i][j] = g[nex[i]][j]; } } function&lt;int(const string&amp;)&gt; calc = [&amp;](const string &amp;s) -&gt; int { memset(dp, 0, sizeof dp); dp[0][0][1] = 1; for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt; m; ++j) { for (int k = 0; k &lt; 26; ++k) { // 前面小了这一位可以选任意的 (dp[i][g[j][k]][0] += dp[i-1][j][0]) %= MOD; // 前面相等,这一位要小于 s[i-1] if (k &lt; s[i-1]-'a') (dp[i][g[j][k]][0] += dp[i-1][j][1]) %= MOD; } // 上限的情况 (dp[i][g[j][s[i-1]-'a']][1] += dp[i-1][j][1]) %= MOD; } } int res = 0; for (int i = 0; i &lt; m; ++i) (res += (dp[n][i][0]+dp[n][i][1])%MOD) %= MOD; return res; }; int flag = s1.find(evil) == s2.npos; return (calc(s2)-calc(s1)+flag+MOD)%MOD; } };","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://kaizynx.github.io/tags/矩阵快速幂/"},{"name":"KMP","slug":"KMP","permalink":"http://kaizynx.github.io/tags/KMP/"},{"name":"数位DP","slug":"数位DP","permalink":"http://kaizynx.github.io/tags/数位DP/"}],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"卷积","slug":"convolution","date":"2020-04-01T15:00:00.000Z","updated":"2022-04-10T07:52:45.150Z","comments":true,"path":"2020/04/01/convolution/","link":"","permalink":"http://kaizynx.github.io/2020/04/01/convolution/","excerpt":"","text":"卷积初步本菜鸡的板子参考 傻逼起见,数组为 $f[0, n]$ 一般线性卷积$f[k]=\\sum\\limits_{i=0}^{k}a[i]\\times b[k-i]$ a 的下标加上 b 的下标等于一个数 类比至多项式乘法 $x^i \\times x^j = x^{i+j}$ 使用 FFT 就可以快速求出 f 每一项 二般线性卷积$f[k]=\\sum\\limits_{i=0}^{n-k}a[i]\\times b[i+k]$ 考虑一般卷积 $\\sum\\limits_{i=0}^{n-k}a[i]\\times b[n-k-i] = f’[n-k]$ 于是令 $f[k]=f’[n-k], b’[i] = b[n-i]$ 此时 $f’[n-k]=\\sum\\limits_{i=0}^{n-k}a[i]\\times b’[n-k-i]$ $=\\sum\\limits_{i=0}^{n-k}a[i]\\times b[i+k] = f[k]$ 例题hdoj6061 RXD and functions 参考博客 代码 int n, m, a; int c[N]; long long f[N], g[N], powa[N]; long long fac[N], inv[N]; inline void solve() { for (int i = 0 ; i &lt;= n; ++i) cin &gt;&gt; c[i]; cin &gt;&gt; m; a = 0; for (int i = 1, x; i &lt;= m; ++i) { cin &gt;&gt; x; a = (a-x+MOD)%MOD; } powa[0] = 1; for (int i = 1; i &lt;= n; ++i) powa[i] = (powa[i-1]*a%MOD+MOD)%MOD; for (int i = 0; i &lt;= n; ++i) { f[i] = c[n-i]*fac[n-i]%MOD; g[i] = powa[i]*inv[i]; } NTT::work(f, n+1, g, n+1); for (int i = 0; i &lt;= n; ++i) cout &lt;&lt; NTT::f[n-i]*inv[i]%MOD &lt;&lt; \" \"; cout &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); fac[0] = inv[0] = 1; for (int i = 1; i &lt; N; ++i) { fac[i] = fac[i-1]*i%MOD; inv[i] = qpow(fac[i], MOD-2); } while (cin &gt;&gt; n) solve(); return 0; } 三般线性卷积$f[k]=\\sum\\limits_{i=0}^{n}a[i]\\times b[k-i]$ 其中 $b[i]=i^2,-n \\leq i \\leq n$ 因为 $k-i$ 可能为负, 令 $b’[i] = b[i-n] = (i-n)^2,0 \\leq i \\leq 2n$ $f’[n+k]=\\sum\\limits_{i=0}^{n}a[i]\\times b’[n+k-i]$ $=\\sum\\limits_{i=0}^{n}a[i]\\times b[k-i] = f[k]$ hdoj4656 Evaluation 参考博客 代码 int n, b, c, d; int a[N]; long long f[N], g[N&lt;&lt;1], p[N], fac[N], inv[N], c2[N]; void init() { fac[0] = fac[1] = inv[0] = inv[1] = 1; for (int i = 2; i &lt; N; ++i) { fac[i] = fac[i-1]*i%MOD; inv[i] = (MOD-MOD/i)*inv[MOD%i]%MOD; } for (int i = 2; i &lt; N; ++i) (inv[i] *= inv[i-1]) %= MOD; } inline void solve() { long long pw = 1; for (int i = 0; i &lt; n; ++i, (pw *= d) %= MOD) { f[i] = a[n-1-i]*fac[n-1-i]%MOD; g[i] = pw*inv[i]%MOD; } MTT::work(f, n, g, n); for (int i = 0; i &lt; n; ++i) p[i] = MTT::f[n-1-i]; pw = 1; for (int i = 0; i &lt; n; ++i, (pw *= b) %= MOD) { c2[i] = qpow(c, 1ll*i*i%(MOD-1)); f[i] = pw*c2[i]%MOD*p[i]%MOD*inv[i]%MOD; g[i+(n-1)] = g[-i+(n-1)] = qpow(c2[i], MOD-2); } // for (int i = -n+1; i &lt; n; ++i) g[i+(n-1)] = qpow(qpow(c, 1ll*i*i), MOD-2); MTT::work(f, n, g, n*2-1); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; MTT::f[n-1+i]*c2[i]%MOD &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); init(); while (cin &gt;&gt; n &gt;&gt; b &gt;&gt; c &gt;&gt; d) { for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; solve(); } return 0; } 循环卷积咕咕咕 二进制卷积本菜鸡的板子参考 数组一般为 $f[0, 2^n)$ 简介快速沃尔什变换|FWT推导详解 公式参考 洛谷例题 复杂度 $O(n\\log n) | O(n2^n)$ $FWT(A\\pm B)=FWT(A)\\pm FWT(B)$ $FWT(cA)=cFWT(A)$ 定义⊕为任意集合运算 $FWT(A\\bigoplus B)=FWT(A)\\times FWT(B)$ 求 $C_i = \\sum\\limits_{i=j\\bigoplus k}{a_j b_k}$ 或运算$FWT(A)[i] = \\sum\\limits_{j|i=i}{A[j]}$ $FWT(A) = [FWT(A_0),FWT(A_0+A_1)]$ $IFWT(A) = [IFWT(A_0),IFWT(A_1)-IFWT(A_0)]$ 与运算$FWT(A)[i] = \\sum\\limits_{i\\&amp;j=j}{A[i]}$ $FWT(A) = [FWT(A_0+A_1),FWT(A_1)]$ $IFWT(A) = [IFWT(A_0)-IFWT(A_1),IFWT(A_1)]$ 异或运算令 $d(x)$ 为 $x$ 在二进制下拥有的1的数量 $FWT(A)[i] = \\sum\\limits_{d(j\\&amp;i)为偶数}{A[j]}-\\sum\\limits_{d(k\\&amp;i)为奇数}{A[k]}$ $FWT(A) = [FWT(A_0+A_1),FWT(A_0-A_1)]$ $IFWT(A) = [\\frac{IFWT(A_1-A_0)}{2},\\frac{IFWT(A_1+A_0)}{2}]$ 快速莫比乌斯变换|FMT据说 FWT 做的事情完全包含 FMT 且常数是一半(咕之 快速子集变换(子集卷积)|FST$C_k = \\sum\\limits_{i\\&amp;j=0,i|j=k}{A_i B_j}$ 复杂度 $O(n\\log^2 n) | O(n^22^n)$ 应用倍增子集卷积hdu6851 设多项式 $A = \\sum\\limits_{i=0}^{2^n-1}{a_i x^i},B=\\sum\\limits_{i=0}^{2^n-1}{b_i x^i}$ 求 $C = A*B = \\sum\\limits_{i=0}^{2^n-1}{x^i \\sum\\limits_{d\\subseteq i}{a_d b_{i-d}}}$ 按照每个状态的最高位进行分组，然后卷 $n$ 次 复杂度 $O(\\sum\\limits_{i=1}^{n}{i^2 2^i}) = O(n^2 2^n)$ 以上为官方说辞?以下为个人理解 给出 $A$ 求 $C$ 满足 $C_k = \\sum\\limits^{所有能组成k的子集集合S}{\\prod\\limits_{i\\in S}{A_i}}$ 不知道怎么表达就是 $\\forall i \\in S,j \\in S, i \\neq j \\rightarrow i\\&amp;j =0$ 且集合内所有数按位或等于 $k$ 如果直接拿两个 $A$ 子集卷积会有很多重复 可以先赋 $C=[1,0,0,0\\cdots]$ 像背包一样,把 $A$ 按照最高位依次拿去更新,就不会重复 就是把 $A$ 分成 $A_{0001},A_{001?},A_{01??},A_{1???}$ 这么些物品这个意思 杂糅好题CF914G Sum the Fibonacci 差不多各种板子都用上了,还要加上一定的理解掌握 详情我另写了篇博客 参考资料浅谈FFT–从DFT到*CZT,及一些技巧 位运算卷积(FWT)与其扩展","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[{"name":"卷积","slug":"卷积","permalink":"http://kaizynx.github.io/tags/卷积/"},{"name":"FFT","slug":"FFT","permalink":"http://kaizynx.github.io/tags/FFT/"}],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"abc160F - Distributing Integers","slug":"Atcoder-ABC160F","date":"2020-03-30T00:30:00.000Z","updated":"2022-04-10T07:52:45.124Z","comments":true,"path":"2020/03/30/Atcoder-ABC160F/","link":"","permalink":"http://kaizynx.github.io/2020/03/30/Atcoder-ABC160F/","excerpt":"","text":"题意题目链接 给一个树的结点标序号，每次只能标相邻的点 问从每一个结点开始标，可行方案数 思路对于一个结点 u 和他的子节点 vi 单考虑 vi 为根的子树，就相当于 [1, size(vi)] 的编号分配给这颗树的方案数 那么假设 vi 子树的方案数算好了, 更新 u 的时候, 要先分配给 vi size(vi)个编号 因为把分配给 vi 的编号离散化,就等价于 [1, size(vi)] 第一个子节点分配方案 C(size(u)-1, size(v1)), 第二个 C(size(u)-1-size(v1), size(v2)) 以此类推 -1 是 u 结点本身肯定是先编号的 然后就应该想到是换根DP了 换根之后(第二遍dfs)就感觉有点麻烦了 考虑原先父节点 u 对子节点 v 的影响 设这个影响值为 val, 就是 u 所有子节点的累计答案(就是第一遍下来的答案)去掉 v 的贡献再加上 u 父亲的贡献 之前计算 v 对 u 贡献时 C(size(u)-1, size(v1)), C(size(u)-1-size(v1), size(v2))… 因为是乘法，所以组合数可以提取出来，(因此搜索子节点的顺序不影响答案) 我们考虑去掉了子节点 v, 那么剩下的就是 size(u)-size(v) 给排列组合，相当于 C(size(u)-1-size(v1), size(v2)) 之后等等 所以我们去掉 v 贡献时, 去掉 C(size(u)-1, size(v))*dp[u][v] 即可 那么 u 父亲的贡献计算，u 父亲的大小就是 n-size(u) 先考虑 u 对 v 贡献，也就是 v 又分配给 u 结点 n-size(u) 个序号 同上，如果我们先考虑把序号分给 u 父亲，那么就不会对其他产生影响 代码赛场上打的，有点乱 代码 /* * @Author: Kaizyn * @Date: 2020-03-28 19:32:21 * @LastEditTime: 2020-03-28 20:48:49 */ #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const int N = 2e5+7; const int MOD = 1e9+7; const double eps = 1e-7; const int INF = 0x3f3f3f3f; typedef pair&lt;int, int&gt; pii; template &lt;int _MOD&gt; struct Mint { int v = 0; Mint() {} Mint(int _v) : v((_v%_MOD+_MOD)%_MOD) {} Mint(long long _v) : v(static_cast&lt;int&gt;((_v%_MOD+_MOD)%_MOD)) {} Mint operator = (const int &amp;_v) { return *this = Mint(_v); } Mint operator = (const long long &amp;_v) { return *this = Mint(_v); } bool operator ! () const { return !this-&gt;v; } bool operator &lt; (const Mint &amp;b) const { return v &lt; b.v; } bool operator &gt; (const Mint &amp;b) const { return v &gt; b.v; } bool operator == (const Mint &amp;b) const { return v == b.v; } bool operator != (const Mint &amp;b) const { return v != b.v; } bool operator &lt;= (const Mint &amp;b) const { return v &lt; b.v || v == b.v; } bool operator &gt;= (const Mint &amp;b) const { return v &gt; b.v || v == b.v; } Mint operator + (const Mint &amp;b) const { return Mint(v+b.v); } Mint operator - (const Mint &amp;b) const { return Mint(v-b.v); } Mint operator * (const Mint &amp;b) const { return Mint(1ll*v*b.v); } Mint operator / (const Mint &amp;b) const { return Mint(b.inv()*v); } Mint&amp; operator += (const Mint &amp;b) { return *this = *this+b; } Mint&amp; operator -= (const Mint &amp;b) { return *this = *this-b; } Mint&amp; operator *= (const Mint &amp;b) { return *this = *this*b; } Mint&amp; operator /= (const Mint &amp;b) { return *this = *this/b; } Mint operator - () const { return Mint(-v); } Mint&amp; operator ++ () { return *this += 1; } Mint&amp; operator -- () { return *this -= 1; } Mint operator ++ (int) { Mint tmp = *this; *this += 1; return tmp; } Mint operator -- (int) { Mint tmp = *this; *this -= 1; return tmp; } Mint pow(int p) const { Mint res(1), x(*this); while (p) { if (p&amp;1) res = res*x; x *= x; p &gt;&gt;= 1; } return res; } Mint inv() const { return pow(_MOD-2); } friend istream&amp; operator &gt;&gt; (istream &amp;is, Mint &amp;mt) { return is &gt;&gt; mt.v; } friend ostream&amp; operator &lt;&lt; (ostream &amp;os, const Mint &amp;mt) { return os &lt;&lt; mt.v; } }; using mint = Mint&lt;MOD&gt;; int n; int num[N]; mint fac[N], inv[N], res[N]; vector&lt;int&gt; e[N]; vector&lt;mint&gt; w[N]; inline mint C(const int &amp;p, const int &amp;q) { return fac[p]*inv[q]*inv[p-q]; } int dfs1(const int &amp;u, const int &amp;fa) { num[u] = 0; for (int i = 0, v; i &lt; (int)e[u].size(); ++i) { v = e[u][i]; if (v == fa) continue; dfs1(v, u); num[u] += num[v]; } for (int i = 0, v, sum = num[u]; i &lt; (int)e[u].size(); ++i) { v = e[u][i]; if (v == fa) continue; w[u][i] = C(sum, num[v])*res[v]; res[u] *= w[u][i]; sum -= num[v]; } return ++num[u]; // itself } void dfs2(const int &amp;u, const int &amp;fa, const mint &amp;val) { for (int i = 0, v; i &lt; (int)e[u].size(); ++i) { v = e[u][i]; if (v == fa) continue; mint tmp = res[u]/(C(num[u]-1, num[v])*res[v]); tmp *= val*C(n-num[v]-1, n-num[u]); dfs2(v, u, tmp); } res[u] *= C(n-1, n-num[u])*val; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n; fac[0] = inv[0] = 1; for (int i = 1; i &lt;= n; ++i) { fac[i] = fac[i-1]*i; inv[i] = fac[i].inv(); } for (int i = 1, u, v; i &lt; n; ++i) { cin &gt;&gt; u &gt;&gt; v; e[u].emplace_back(v); e[v].emplace_back(u); } for (int i = 1; i &lt;= n; ++i) { w[i].resize(e[i].size(), 0); res[i] = 1; } dfs1(1, 0); dfs2(1, 0, 1); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; res[i] &lt;&lt; endl; return 0; }","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"换根DP","slug":"换根DP","permalink":"http://kaizynx.github.io/tags/换根DP/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"网络流","slug":"network_flows","date":"2020-03-26T02:00:00.000Z","updated":"2022-04-10T07:52:45.152Z","comments":true,"path":"2020/03/26/network_flows/","link":"","permalink":"http://kaizynx.github.io/2020/03/26/network_flows/","excerpt":"","text":"序引用hjt巨佬的语录，网络流主要在建图 一些概念部分转载自hjt巨佬博客 $c(u,v)$ 为 $u$ 到 $v$ 的容量，$f(u,v)$ 为 $u$ 到 $v$ 的流量，$f(u,v)&lt;c(u,v)$ $c[X,Y]$ 为 $X$ 到 $Y$ 的容量和，不包括 $Y$ 到 $X$ 的容量；$f(X,Y)$ 为 $X$ 到 $Y$ 的流量和，要减去 $Y$ 到 $X$ 的流量 费用流（最小费用最大流）：保证最大流后的最小费用割：割 $[S,T]$ 是点集的一个分割且 $S$ 包含源点，$T$ 包含汇点，称 $f(S,T)$ 为割的净流，$c[S,T]$ 为割的容量 最大流最小割定理：最大流即最小割容量 求最小割：在最大流残量网络中，令源点可达的点集为 $S$，其余的为 $T$ 即可（但是满流边不一定都在 $S,T$ 之间） 简单割：割集中所有的边，都与s或t相连接。 最小点权覆盖集：在二分图中，对于每条边，两个端点至少选一个，求所选取的点最小权值和。 最大点权独立集：在二分图中，对于每条边，两个端点至多选一条边，求所选取的点的最大权值和。 最小点权覆盖集=最小割，最大点权独立集=总权值-最小点权覆盖集 网络流模板见模板 实战二分图匹配设二分图一边为左，一边为右 从 s 向左边每个点连权为 1 的边 (保证左边每个最多被匹配一次) 左右之间的边权为 1 (其实任意) 从右边每个点向 t 连权为 1 的边 (保证右边每个最多被匹配一次) loj6000「网络流 24 题」搭配飞行员代码 代码 int n, m; ISAP&lt;int&gt; isap; inline void solve() { cin &gt;&gt; n &gt;&gt; m; int s = 0, t = n + 1; isap.init(n + 1); for (int i = 1; i &lt;= m; ++i) isap.add_edge(s, i, 1); for (int i = m + 1; i &lt;= n; ++i) isap.add_edge(i, t, 1); for (int a, b; cin &gt;&gt; a &gt;&gt; b;) isap.add_edge(a, b, 1); cout &lt;&lt; isap.work(s, t) &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int testcase = 1; // cin &gt;&gt; testcase; for (int i = 1; i &lt;= testcase; ++i) { solve(); } return 0; } 最大流hdu3572 Task Schedule题意要完成 n 个任务，每个任务需要在某个时间段 [s, e] 执行 p 时间(不一定连续),同一时间可以同时执行 m 个任务， 求是否能完成所有任务 分析我们把时间看作流量，每个时间点一开始有 m 个流量 一个任务完成的条件就是是否有 p 流量流经 所以从每个任务往 T 连一条边权为 p 的边，判断最大流是否为 所有任务 p 之和 对于每个任务 [s, e] 中每个时间都可以给这个任务 1 点流量 建图S 向每个时间点连边 权为 m 每个 [s, e] 向任务连边 权为1 每个任务向 T 连边 权为 p 代码 代码 ISAP&lt;int&gt; isap; inline bool solve() { int n, m; static int vis[N]; scanf(\"%d %d\", &amp;n ,&amp;m); int src = 0, dst = 500+n+1; memset(vis, 0, sizeof(int)*(500+n+3)); isap.init(500+n+1); int sum = 0; for (int i = 1, p, s, e; i &lt;= n; ++i) { scanf(\"%d %d %d\", &amp;p, &amp;s, &amp;e); isap.add_edge(src, 500+i, p); sum += p; for (int j = s; j &lt;= e; ++j) { isap.add_edge(500+i, j, 1); vis[j] = 1; } } for (int i = 1; i &lt;= 500; ++i) if (vis[i]) { isap.add_edge(i, dst, m); } return isap.work(0, dst) == sum; } int main() { int T = 1; scanf(\"%d\", &amp;T); for (int i = 1; i &lt;= T; ++i) { printf(\"Case %d: %s\\n\\n\", i, solve() ? \"Yes\" : \"No\"); } return 0; } hdoj2883 kebab分析一样的题型，只不过需要离散化，把时间点合成时间段 代码 代码 struct Node { int s, n, e, t; friend istream&amp; operator &gt;&gt; (istream &amp;is, Node &amp;nd) { return is &gt;&gt; nd.s &gt;&gt; nd.n &gt;&gt; nd.e &gt;&gt; nd.t; } }; int n, m; Node a[N]; vector&lt;int&gt; d; ISAP&lt;int&gt; isap; inline bool solve() { d.clear(); for (int i = 1; i &lt;= n; ++i) { d.emplace_back(a[i].s); d.emplace_back(a[i].e); } sort(d.begin(), d.end()); d.erase(unique(d.begin(), d.end()), d.end()); int tm = d.size()-1, s = tm+n+1, t = tm+n+2; // time zone[i] = [d[i-1], d[i]], i [1, tm] // custom [tm+1, tm+n] isap.init(tm+n+2); int sum = 0; for (int i = 1; i &lt;= tm; ++i) isap.add_edge(s, i, (d[i]-d[i-1])*m); for (int i = 1; i &lt;= n; ++i) { a[i].s = lower_bound(d.begin(), d.end(), a[i].s)-d.begin(); a[i].e = lower_bound(d.begin(), d.end(), a[i].e)-d.begin(); for (int j = a[i].s+1; j &lt;= a[i].e; ++j) isap.add_edge(j, tm+i, INF); // isap.add_edge(j, tm+i, (d[j]-d[j-1])*min(m, a[i].n)); isap.add_edge(tm+i, t, a[i].n*a[i].t); sum += a[i].n*a[i].t; } return isap.work(s, t) == sum; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); d.reserve(N); while (cin &gt;&gt; n &gt;&gt; m) { for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; cout &lt;&lt; (solve() ? \"Yes\" : \"No\") &lt;&lt; endl; } return 0; } 拆点一般网络流对每条边有流量限制 遇到对点有流量限制,如结点 u 有限制 f 拆成两点一边 u-&gt;v 边权 f hdoj2732 Leapin’ Lizards代码 代码 int n, m, d, s, t; char a[25][25], b[25][25]; ISAP&lt;int&gt; isap; inline int mp(const int &amp;x, const int &amp;y) { return (x*m+y)&lt;&lt;1; } inline void walk(const int &amp;x, const int &amp;y) { int flag = 0; for (int i = -d, nx, ny; i &lt;= d; ++i) { for (int j = abs(i)-d; j &lt;= d-abs(i); ++j) { if (i == 0 &amp;&amp; j == 0) continue; nx = x+i; ny = y+j; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m) { if (!flag) isap.add_edge(mp(x, y)^1, t, INF), flag = 1; continue; } if (a[nx][ny] == '0') continue; isap.add_edge(mp(x, y)^1, mp(nx, ny), INF); } } } inline int solve() { scanf(\"%d %d\", &amp;n, &amp;d); for (int i = 0; i &lt; n; ++i) scanf(\"%s\", a[i]); for (int i = 0; i &lt; n; ++i) scanf(\"%s\", b[i]); int num = 0; m = strlen(a[0]); s = 2*n*m; t= 2*n*m+1; isap.init(2*n*m+2); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; m; ++j) { if (a[i][j] != '0') isap.add_edge(mp(i, j), mp(i, j)^1, a[i][j]-'0'); if (b[i][j] == 'L') isap.add_edge(s, mp(i, j), 1), ++num; walk(i, j); } } return num-isap.work(s, t); } signed main() { int testcase = 1; scanf(\"%d\", &amp;testcase); for (int i = 1; i &lt;= testcase; ++i) { int res = solve(); printf(\"Case #%d: \", i); if (res == 0) puts(\"no lizard was left behind.\"); else if (res == 1) puts(\"1 lizard was left behind.\"); else printf(\"%d lizards were left behind.\\n\", res); } return 0; } codeforces 546E. Soldier and Traveling题意给一张图，每个点有一些人，每个人只能最多移动 1 步 问能否使每个点的人数达到给定值 思路简单题,每个点拆成移动前和移动后 代码 代码 int n, m; int res[N][N]; ISAP&lt;int&gt; isap; signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m; // turn pt i to i*2-1, i*2 int s = 2*n+1, t = 2*n+2, suma = 0, sumb = 0; isap.init(t); for (int i = 1, a; i &lt;= n; ++i) { cin &gt;&gt; a; suma += a; isap.add_edge(s, i*2-1, a); isap.add_edge(i*2-1, i*2, INF); } for (int i = 1, b; i &lt;= n; ++i) { cin &gt;&gt; b; sumb += b; isap.add_edge(i*2, t, b); } for (int i = 1, u, v; i &lt;= m; ++i) { cin &gt;&gt; u &gt;&gt; v; isap.add_edge(u*2-1, v*2, INF); isap.add_edge(v*2-1, u*2, INF); } if (suma != sumb || isap.work(s, t) != sumb) return cout &lt;&lt; \"NO\\n\", 0; for (int u = 1; u &lt;= n; ++u) { for (int i = isap.fir[u*2], v; i != -1; i = isap.e[i].nex) { v = (isap.e[i].v+1)/2; res[v][u] = isap.e[i].w; } } cout &lt;&lt; \"YES\\n\"; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { cout &lt;&lt; res[i][j] &lt;&lt; \" \\n\"[j==n]; } } return 0; } luoguP2153 [SDOI2009]晨跑思路费用流板子题,限制:路口只能走一次 代码 代码 int n, m; ZKW_SPFA&lt;int&gt; zkw; signed main() { // pt i ==&gt; i*2-1, i*2 ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m; zkw.init(n*2); for (int i = 2; i &lt; n; ++i) zkw.add_edge(i*2-1, i*2, 1, 0); for (int i = 1, u, v, w; i &lt;= m; ++i) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; zkw.add_edge(u*2, v*2-1, 1, w); } pair&lt;int, int&gt; res = zkw.work(2, n*2-1); cout &lt;&lt; res.first &lt;&lt; \" \" &lt;&lt; res.second &lt;&lt; endl; return 0; } luoguP1251 餐巾计划问题思路把每天拆成早上(可用毛巾)晚上(待洗毛巾) // 详情见洛谷题解 代码 代码 int r[N]; ZKW_SPFA&lt;long long&gt; zkw; signed main() { // day i ==&gt; i to wash | evening, i+n can use | morning ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int n, p, t1, m1, t2, m2; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; r[i]; cin &gt;&gt; p &gt;&gt; t1 &gt;&gt; m1 &gt;&gt; t2 &gt;&gt; m2; int s = 0, t = n*2+1; zkw.init(t); for (int i = 1; i &lt;= n; ++i) { zkw.add_edge(s, i, r[i], 0); zkw.add_edge(i+n, t, r[i], 0); if (i+1 &lt;= n) zkw.add_edge(i, i+1, INF, 0); // do not wash if (i+t1 &lt;= n) zkw.add_edge(i, i+n+t1, INF, m1); // fast if (i+t2 &lt;= n) zkw.add_edge(i, i+n+t2, INF, m2); // slow zkw.add_edge(s, i+n, INF, p); // buy new } cout &lt;&lt; zkw.work(s, t).second &lt;&lt; endl; return 0; } 另见于 有向无环图最小不相交路径覆盖拆边动态费用 如果对于某条边，其费用是关于流量的一个函数，并且这个函数的斜率是单调增加的，我们就可以拆边，第x条费用设为𝑓(𝑥)−𝑓(𝑥−1) hdoj3667 Transportation题意N个城市，M条边，你要从1号点运送k个货物到N号点。每条边(u,v,a,c)表示u-&gt;v有一条边容量为c，从这条边运送x个物品花费为 ，问最小花费为多少？ N &lt;= 100, M &lt;= 5000, c &lt;= 5 思路对于每一条边，原本的容量为c，我们可以把它拆成c条边 这c条边的容量都为1，花费为1a,3a,5a,7a…(c&lt;=5) 由于费用流会优先流花费较小的边，因此假设最终的流中我们的流量经过了前k小的边，花费就是1a+3a+..+2(k-1)a=ak^2，与题意相符 代码 代码 int n, m, k; ZKW_SPFA&lt;int&gt; zkw; signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) { int s = 0, t = n; zkw.init(n); zkw.add_edge(s, 1, k, 0); for (int i = 1, u, v, a, c; i &lt;= m; ++i) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; a &gt;&gt; c; for (int j = 1; j &lt;= c; ++j) { zkw.add_edge(u, v, 1, (2*j-1)*a); } } pair&lt;int, int&gt; res = zkw.work(s, t); cout &lt;&lt; (res.first == k ? res.second : -1) &lt;&lt; endl; } return 0; } 虚点其实没什么好讲的 luoguP1361 小M的作物思路考虑最小割 每个点向 S, T 连边，设 S 是种在 A, B 是种在 B, 通过最小割拆成两个图即为所求 对于每个组合，建立一个虚点往 A 连边权为额外收益的边，再往组合里的每个点连 INF 边 这样如果某个作物要种在 B (割掉与 A 连边),此时因为该点还通过组合与 A 有连边 所以如果不种在 A 此时组合的边必定被割掉 代码 代码 int n, m; int a[N], b[N]; ISAP&lt;int&gt; isap; signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; b[i]; cin &gt;&gt; m; // plant [1, n] combination n+i*2-1, n+i*2 isap.init(n+m*2+2); int s = n+m*2+1, t = n+m*2+2, sum = 0; for (int i = 1, k, c1, c2; i &lt;= m; ++i) { cin &gt;&gt; k &gt;&gt; c1 &gt;&gt; c2; isap.add_edge(s, n+i*2-1, c1); isap.add_edge(n+i*2, t, c2); sum += c1+c2; for (int j = 1, x; j &lt;= k; ++j) { cin &gt;&gt; x; isap.add_edge(n+i*2-1, x, INF); isap.add_edge(x, n+i*2, INF); } } for (int i = 1; i &lt;= n; ++i) { sum += a[i]+b[i]; isap.add_edge(s, i, a[i]); isap.add_edge(i, t, b[i]); } cout &lt;&lt; sum-isap.work(s, t) &lt;&lt; endl; return 0; } 最小点权覆盖和最大点权独立集原二分图中的边(u,v)替换为容量为INF的有向边(u,v)，设立源点s和汇点t，将s和x集合中的点相连，容量为该点的权值；将y中的点同t相连，容量为该点的权值。求最小割 hdoj1565 方格取数(1)题意给你一个n*n的格子的棋盘，每个格子里面有一个非负数。从中取出若干个数，使得任意的两个数所在的格子没有公共边，就是说所取的数所在的2个格子不能相邻，并且取出的数的和最大。 建图黑白染色成二分图 S 连黑，权值为黑点权值 黑与相邻的白连，权值为 INF 白连 T, 权值白点权值 分析求最小割 那么就不可能割 INF 边，反证，有一方案，割掉所有 S 与黑的边，比 INF 小 所以每对点中连向源汇点边权最小的边被割断，整体来看，就是对于任意一对端点，都选了一个较小权值，得到我们要的结果。 代码 代码 int n; int a[25][25]; ISAP&lt;int&gt; isap; inline void solve() { int sum = 0; for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; n; ++j) { cin &gt;&gt; a[i][j]; sum += a[i][j]; } } int s = n*n+1, t = n*n+2; isap.init(t); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; n; ++j) { if ((i+j)&amp;1) { isap.add_edge(s, i*n+j+1, a[i][j]); for (int k = 0, nx, ny; k &lt; 4; ++k) { nx = i+dir[k]; ny = j+dir[k+1]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n) continue; isap.add_edge(i*n+j+1, nx*n+ny+1, INF); } } else { isap.add_edge(i*n+j+1, t, a[i][j]); } } } cout &lt;&lt; sum-isap.work(s, t) &lt;&lt; endl; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); while (cin &gt;&gt; n) solve(); return 0; } hdoj3657 Game题意与上题类似，不同的是 相邻的可以选，但要付出一定代价 有些点必选 建图同上 相邻两点的边权由 INF 改为代价，要么割掉其中一个，要么割掉两点连边表示两个都选 这个点到源点(汇点)的边权改为 INF ,以防被割掉 代码 代码 `cppint n, m, k;int a[N][N], c[N][N];Dinic dinic; inline int mp(const int &amp;x, const int &amp;y) { return (x-1)*m+y; } inline void solve(){ int sum = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { cin &gt;&gt; a[i][j]; sum += a[i][j]; c[i][j] = a[i][j]; } } for (int i = 1, x, y; i &lt;= k; ++i) { cin &gt;&gt; x &gt;&gt; y; c[x][y] = INF; } int s = nm+1, t = nm+2; dinic.init(nm+2); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { if ((i+j)&amp;1) { dinic.add_edge(s, mp(i, j), c[i][j]); for (int k = 0, x, y; k &lt; 4; ++k) { x = i+dir[k]; y = j+dir[k+1]; if (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m) continue; dinic.add_edge(mp(i, j), mp(x, y), 2(a[i][j]&amp;a[x][y])); } } else { dinic.add_edge(mp(i, j), t, c[i][j]); } } } cout &lt;&lt; sum-dinic.work(s, t) &lt;&lt; endl;}`cpp 最大权闭合图定义参考博客证明参考博客 S 连正点，权值为点值 正连负，权值为INF 负点连 T，权值为点值绝对值 答案为所有正点权值和-最小割 loj6001 「网络流 24 题」太空飞行计划分析用Dninc求最大流的好处是便于我们输出，因为层数如果为0，那么显然该边容量大于0，这就说明这条边并没有流量流过，那么显然与它相连的实验或者器材没有被使用（因为使用过的话，边的容量会变为0） 代码 代码 int n, m; string str; stringstream ss; Dinic&lt;int&gt; dinic; inline void solve() { getline(cin, str); ss.clear(); ss &lt;&lt; str; ss &gt;&gt; n &gt;&gt; m; int s = 0, t = n+m+1; dinic.init(t); int sum = 0; for (int i = 1, j, w; i &lt;= n; ++i) { getline(cin, str); ss.clear(); ss &lt;&lt; str; ss &gt;&gt; w; sum += w; dinic.add_edge(s, i, w); while (ss &gt;&gt; j) dinic.add_edge(i, j+n, INF); } for (int i = 1, w; i &lt;= m; ++i) { cin &gt;&gt; w; dinic.add_edge(i+n, t, w); } int res = sum-dinic.work(s, t); vector&lt;int&gt; choose; for (int i = 1; i &lt;= n; ++i) if (dinic.dep[i]) choose.emplace_back(i); for (int i = 0, sz = choose.size(); i &lt; sz; ++i) cout &lt;&lt; choose[i] &lt;&lt; \" \\n\"[i==sz-1]; choose.clear(); for (int i = 1; i &lt;= m; ++i) if (dinic.dep[i+n]) choose.emplace_back(i); for (int i = 0, sz = choose.size(); i &lt; sz; ++i) cout &lt;&lt; choose[i] &lt;&lt; \" \\n\"[i==sz-1]; cout &lt;&lt; res &lt;&lt; endl; } 有向无环图最小不相交路径覆盖参考博客 定义在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。 最小不相交路径覆盖：每一条路径经过的顶点各不相同。 算法把原图的每个点V拆成Vx和Vy两个点，如果有一条有向边A-&gt;B，那么就加边Ax−&gt;By。这样就得到了一个二分图。那么最小路径覆盖=原图的结点数-新图的最大匹配数。 证明一开始每个点都是独立的为一条路径，总共有n条不相交路径。我们每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于路径数减少了1。所以找到了几条匹配边，路径数就减少了多少。所以有最小路径覆盖=原图的结点数-新图的最大匹配数。 loj6002「网络流 24 题」最小路径覆盖分析二分图匹配求方案 如果两个点被匹配了，那么这两个点之间的边就有流量，则剩余流量为0 代码 代码 int n, m; int du[N], to[N]; ISAP&lt;int&gt; isap; inline void solve() { cin &gt;&gt; n &gt;&gt; m; // pt i ==&gt; i*2-1 - i*2 int s = 0, t = n*2+1; isap.init(t); for (int i = 1; i &lt;= n; ++i) { isap.add_edge(s, i*2-1, 1); isap.add_edge(i*2, t, 1); } for (int i = 1, u, v; i &lt;= m; ++i) { cin &gt;&gt; u &gt;&gt; v; isap.add_edge(u*2-1, v*2, 1); } int res = n-isap.work(s, t); for (int u = 1; u &lt;= n*2; u += 2) { for (int i = isap.fir[u], v; i != -1; i = isap.e[i].nex) { v = isap.e[i].v; if (v == s || isap.e[i].w) continue; to[u/2+1] = v/2; ++du[v/2]; break; } } for (int i = 1; i &lt;= n; ++i) { if (du[i]) continue; for (int u = i; u; u = to[u]) cout &lt;&lt; u &lt;&lt; \" \\n\"[to[u]==0]; } cout &lt;&lt; res &lt;&lt; endl; } loj6003「网络流 24 题」魔术球有向无环图最小可相交路径覆盖定义在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。 最小可相交路径覆盖：每一条路径经过的顶点可以相同。 切糕模型codeforces434 D. Nanami’s Power Plant详情见文末郑学长pdf,有图有真相(逃 题意给N个二次方程f(x)=ax^2+bx+c,每个方程的x取值范围为[l, r],并给出M个限制条件(u, v, d),表示要求满足xu &lt;= xv+d,问你所有函数值之和的最大值 思路 最小割,建图略了.(注:大致思路如此，我的代码略有不同) 如果割了f1(l1+2),我们发现如果割f2(l2)的话S,T还是联通,所以(贪心)没必要割,只能割后面的，因此做到了限制条件 但周知最小割是最小值,那么求最大值就把边权改为负,如果是负数求出来最大流量可能是0(逃)所以边权再加上一个很大的值使之为正，最后减去即可 代码 代码 const int LIM = 1e6; struct F { int a, b, c, l, r; int calc(const int &amp;x) const { return LIM-(a*x*x+b*x+c); } }; int n, m; int sum[55]; F f[55]; ISAP&lt;long long&gt; isap; inline int id(const int &amp;i, const int &amp;j) { return sum[i-1]+j-f[i].l; } signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; f[i].a &gt;&gt; f[i].b &gt;&gt; f[i].c; } for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; f[i].l &gt;&gt; f[i].r; sum[i] = sum[i-1]+(f[i].r-f[i].l+2); } int s = sum[n], t = sum[n]+1; isap.init(t+1); // start from 0 for(int i = 1; i &lt;= n; ++i) { isap.add_edge(s, id(i, f[i].l), INF); for (int j = f[i].l; j &lt;= f[i].r; ++j) { isap.add_edge(id(i, j), id(i, j+1), f[i].calc(j)); } isap.add_edge(id(i, f[i].r+1), t, INF); } // xu &lt;= xv+d for (int i = 1, u, v, d; i &lt;= m; ++i) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; d; for (int j = f[u].l; j &lt;= f[u].r; ++j) { if (j-d &gt;= f[v].l &amp;&amp; j-d &lt;= f[v].r+1) { isap.add_edge(id(u, j), id(v, j-d), INF); } } } cout &lt;&lt; (LIM*n-isap.work(s, t)) &lt;&lt; endl; return 0; } 二分最大流：新加进一条边不会使最大流变小； 费用流：费用流中费用是单调的； 优化建图POJ1149 PIGS题意有N个顾客，M个猪圈，每个猪圈有若干头猪，在开始的时候猪圈都是关闭的，每个顾客有一些猪圈的钥匙，每个顾客可以买最多hi头猪； 顾客依次来买猪，当一个顾客打开一些猪圈并且买完猪之后，你可以调整这些开着门的猪圈中猪的数量，然后再关门，等下一个顾客；求最多能卖多少头猪； n &lt;= 100, m &lt;= 1000 思路见文末郑学长pdf 未完待续一些资料郑学长的讲座 收获很多 luogu网络流24题 胡伯涛《最小割模型在信息学竞赛中的应用》 LibreOJ网络流24题(不全) codeforces网络流标签","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://kaizynx.github.io/tags/网络流/"}],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"Windows vscode cmd 中文乱码","slug":"cmd_chinese","date":"2020-03-22T05:00:00.000Z","updated":"2022-04-10T07:52:45.150Z","comments":true,"path":"2020/03/22/cmd_chinese/","link":"","permalink":"http://kaizynx.github.io/2020/03/22/cmd_chinese/","excerpt":"","text":"主要参考博客 次要参考博客 查看命令行属性发现 当前代码页编码是 936 GBK 网上有一种方法是在cmd输入 chcp 65001, 并在注册表中让该语句自动执行 但这种方法并不能解决 vscode 中命令行的乱码问题,于是采用如下方法 在运行中通过regedit进入注册表 找到HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe 新建一个 DWORD（32位值）,命名为CodePage，值设为65001 已有CodePage的话，修改它，改为十进制，65001","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"Hexo-Sakura主题配置","slug":"Sakura_setting","date":"2020-03-19T02:00:00.000Z","updated":"2022-04-10T07:52:45.149Z","comments":true,"path":"2020/03/19/Sakura_setting/","link":"","permalink":"http://kaizynx.github.io/2020/03/19/Sakura_setting/","excerpt":"","text":"主题介绍github 直接整个下载,作为博客的根目录,在此基础上配置 初级配置官方文档 参考文档可以完成大部分主流配置 cdn百度搜索例如 jsDelivr+github搭建免费的cdn 的关键字 $ https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 # 栗子： $ https://cdn.jsdelivr.net/gh/Fofade/cnblogsThemes@1.0/live2dw/assets/z16.model.json # 加载1.0版本 # 注意： 如果不加 @发布的版本号 默认加载最新版本 # 栗子： $ https://cdn.jsdelivr.net/gh/Fofade/cnblogsThemes/live2dw/assets/z16.model.json # 加载最新版本 进阶配置主要参考 博客链接 这篇超好用 博客链接 作者的 bilibili 某个使用该主题的大佬，很喜欢他的博客博客链接 切换背景第一次尝试上面博客提供的切换背景方法失败 于是百度到如下方法 另一篇博客 修改文件 \\themes\\Sakura\\layout\\_partial\\footer.ejs 在 &lt;/footer&gt; 前添加如下代码 &lt;!--壁纸切换--&gt; &lt;div class=&quot;skin-menu no-select&quot; id=&quot;mainskin&quot; style=&quot;position: fixed&quot;&gt; &lt;div class=&quot;theme-controls row-container&quot;&gt; &lt;ul class=&quot;menu-list&quot;&gt; &lt;li id=&quot;white-bg&quot;&gt; &lt;i class=&quot;fa fa-television&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;sakura-bg&quot;&gt; &lt;i class=&quot;iconfont icon-sakura&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;gribs-bg&quot;&gt; &lt;i class=&quot;fa fa-slack&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;KAdots-bg&quot;&gt; &lt;i class=&quot;iconfont icon-dots&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;totem-bg&quot;&gt; &lt;i class=&quot;fa fa-optin-monster&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;pixiv-bg&quot;&gt; &lt;i class=&quot;iconfont icon-pixiv&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;bing-bg&quot;&gt; &lt;i class=&quot;iconfont icon-bing&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li id=&quot;dark-bg&quot;&gt; &lt;i class=&quot;fa fa-moon-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;font-family-controls row-container&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;control-btn-serif selected&quot; data-mode=&quot;serif&quot; onclick=&quot;mashiro_global.font_control.change_font()&quot;&gt;Serif&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;control-btn-sans-serif&quot; data-mode=&quot;sans-serif&quot; onclick=&quot;mashiro_global.font_control.change_font()&quot;&gt;Sans Serif&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;canvas id=&quot;night-mode-cover&quot;&gt;&lt;/canvas&gt; &lt;div class=&quot;changeSkin-gear no-select&quot;&gt; &lt;div class=&quot;keys&quot; id=&quot;setbtn&quot;&gt; &lt;span id=&quot;open-skinMenu&quot;&gt; 切换壁纸 | SCHEME TOOL &amp;nbsp;&lt;i class=&quot;iconfont icon-gear inline-block rotating&quot;&gt;&lt;/i&gt; &lt;/span&gt;&lt;/div&gt; &lt;/div&gt;&lt;!--skin.end--&gt; 但是令人震惊的是，之前博客的方法突然又起效了。 背景动画参考博客 花瓣飘落、文字，爱心，连线，飘动的彩带 修改文件 \\themes\\Sakura\\layout\\_partial\\footer.ejs &lt;!--浏览器搞笑标题--&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/hititle.js&quot;&gt;&lt;/script&gt; &lt;!-- 🌸飘落 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/sakura.js&quot;&gt;&lt;/script&gt; &lt;!-- 雪花飘落 --&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/snow1.js&quot;&gt;&lt;/script&gt; --&gt; &lt;!-- // 文字 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/shehuizhuyi.js&quot;&gt;&lt;/script&gt; &lt;!-- // 烟花 --&gt; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/Yafine/cdn@2.5/source/js/fireworks.js&quot;&gt;&lt;/script&gt; &lt;!-- // 星星跟随坠落 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/cungudafa/cdn@2.1.2/js/cursor.js&quot;&gt;&lt;/script&gt; &lt;!-- // 爱心 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/love.js&quot;&gt;&lt;/script&gt; &lt;!-- // 连线 --&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/canvas-nest.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js&quot;&gt;&lt;/script&gt; --&gt; &lt;!-- 样式二（飘动的彩带） --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/piao.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;!--背景切换--&gt; &lt;script src=&quot;//instant.page/3.0.0&quot; type=&quot;module&quot; defer integrity=&quot;sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1&quot;&gt;&lt;/script&gt; 添加页面底部图片修改文件 \\themes\\Sakura\\layout\\_partial\\footer.ejs 在一堆 &lt;script type=&quot;&quot;,url=&quot;&quot;&gt; 之间(其实我不清楚插哪不可以反正这里可以)插入 &lt;center&gt; &lt;img src=&quot;&quot;&gt; &lt;/center&gt; 代码渲染问题根目录下的 _config.yml 文件 highlight: enable: false line_number: false auto_detect: false tab_replace: 上面三个选项之前全写了 true 导致渲染出错 置顶 和 加密参考博客 按照博客里的一步一步做 关于置顶标签的问题，也确实是找不到放哪里哭了 不过勇于尝试多次之后就找到一个较为合适的位置了。。略 修改字体2020-03-20 巨佬博客 一个不太大众的博客主题最糟心的事情估计是技术博客不好找吧 也可能是之前用的 Next 主题太火了，把我惯坏了 不过这个大佬是用 Wordpress 搭建的，和 Hexo 有很大的出入 不过还是可以借鉴模仿的(不会网页语言的我感到自己好厉害) 在这个文件 \\themes\\Sakura\\source\\css\\style.css 找到里面的关键词 font-family: 类似 font-family:Arial,Helvetica,sans-serif; 这后面就是字体,虽然有很多个,但经过我的盲目分析,显示的应该是第一个 然后你改一下第一个就好… 不过文件中有好多,应该是不同地方用不同字体,至于具体什么地方,看括号外名字猜测吧 暂时不知道外部字体的导入方法,你可以改成一些常用字体或系统自带的字体吧 修改 关于-我 中的对话内容2020-03-21 修改文件 \\themes\\Sakura\\source\\js\\botui.js 图片放大2020-03-21 在 .md 插入图片时使用如下代码 &lt;img src=&quot;&quot; data-action=&quot;zoom&quot;&gt; 效果演示 内容折叠2020-03-22 参考博客 找这个教程也是把我气的，一搜索全是 next 的教程 HTML语法测试代码渲染失败cpp int main() { return 0; } 插件效果测试 插件 代码能渲染 int main() { return 0; } 仿Github文章日历2020-03-23 博客链接 另注 博客末尾中给出的style并不完美(长度宽度设置)，这里提供此博客版本 &lt;style type=&quot;text/css&quot;&gt; #contentss { position: relative; width: 80%; height: auto; max-height: 1200px; margin-bottom: 15px; margin-top: 15px; text-align: center; border: 0; border-radius: 10px; color: rgba(0, 0, 0, .87); background: #fff 50%; background-size: cover; box-shadow: 0 15px 35px rgba(50, 50, 93, .1), 0 5px 15px rgba(0, 0, 0, .07); margin:0 auto; } &lt;/style&gt; 随机图片2020-03-24 网址1 网址2 经测试应该可以直接作为 post 的 photos 不过鉴于我的博客是由之前的博客换主题而来的，之前的文章都没有封面 一个一个写岂不是太麻烦了？一劳永逸不香吗 修改\\themes\\Sakura\\layout\\_widget\\common-article.ejs &lt;% if (post.photos &amp;&amp; post.photos.length){ %&gt; &lt;div class=&quot;pattern-center single-center&quot;&gt; &lt;!-- 有配图默认渲染第一张 --&gt; &lt;div class=&quot;pattern-attachment-img lazyload&quot; style=&quot;background-image: url(&lt;%= post.photos[0] %&gt;);&quot; src=&quot;&lt;%- theme.lazyloadImg%&gt;&quot; data-src=&quot;&lt;%= post.photos[0] %&gt;&quot;&gt; &lt;/div&gt; &lt;header class=&quot;pattern-header single-header&quot;&gt; &lt;h1 class=&quot;entry-title&quot;&gt; &lt;%- post.title %&gt;&lt;/h1&gt; &lt;p class=&quot;entry-census&quot;&gt; &lt;span&gt; &lt;a href=&quot;&lt;%- post.authorLink%&gt;&quot;&gt; &lt;img src=&quot;&lt;%- post.avatar%&gt;&quot;&gt; &lt;/a&gt; &lt;/span&gt; &lt;span&gt; &lt;a href=&quot;&lt;%- post.authorLink%&gt;&quot;&gt;&lt;%- post.author %&gt;&lt;/a&gt; &lt;/span&gt; &lt;span class=&quot;bull&quot;&gt; ·&lt;/span&gt; &lt;%= date(post.date, &#39;YYYY-M-D&#39;) %&gt;&lt;span class=&quot;bull&quot;&gt; ·&lt;/span&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&lt;/p&gt; &lt;/header&gt; &lt;/div&gt; &lt;% } %&gt; 修改为 &lt;!-- 有配图默认渲染第一张 --&gt; &lt;% if (post.photos &amp;&amp; post.photos.length){ %&gt; &lt;div class=&quot;pattern-attachment-img lazyload&quot; style=&quot;background-image: url(&lt;%= post.photos[0] %&gt;);&quot; src=&quot;&lt;%- theme.lazyloadImg%&gt;&quot; data-src=&quot;&lt;%= post.photos[0] %&gt;&quot;&gt; &lt;/div&gt; &lt;% } else { %&gt; &lt;div class=&quot;pattern-attachment-img lazyload&quot; style=&quot;background-image: url(https://random.52ecy.cn/randbg.php);&quot; src=&quot;&lt;%- theme.lazyloadImg%&gt;&quot; data-src=&quot;https://random.52ecy.cn/randbg.php&quot;&gt; &lt;/div&gt; &lt;% } %&gt; &lt;header class=&quot;pattern-header single-header&quot;&gt; &lt;h1 class=&quot;entry-title&quot;&gt; &lt;%- post.title %&gt;&lt;/h1&gt; &lt;p class=&quot;entry-census&quot;&gt; &lt;span&gt; &lt;a href=&quot;&lt;%- post.authorLink || &#39;https://kaizynx.github.io/&#39; %&gt;&quot;&gt; &lt;img src=&quot;&lt;%- post.avatar || &#39;https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/custom/avatar.jpg&#39; %&gt;&quot;&gt; &lt;/a&gt; &lt;/span&gt; &lt;span&gt; &lt;a href=&quot;&lt;%- post.authorLink || &#39;https://kaizynx.github.io/&#39; %&gt;&quot;&gt;&lt;%- post.author || &#39;Kaizyn&#39; %&gt;&lt;/a&gt; &lt;/span&gt; &lt;span class=&quot;bull&quot;&gt; ·&lt;/span&gt; &lt;%= date(post.date, &#39;YYYY-M-D&#39;) %&gt;&lt;span class=&quot;bull&quot;&gt; ·&lt;/span&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&lt;/p&gt; &lt;/header&gt; &lt;/div&gt; 修改 \\themes\\Sakura\\layout\\_widget\\index-items.ejs 大概第六行 &lt;img class=&quot;lazyload&quot; onerror=&quot;imgError(this,3)&quot; src=&quot;&lt;%- theme.lazyloadImg%&gt;&quot; data-src=&quot;&lt;%= post.photos[0] || &#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/image-404.png&#39; %&gt;&quot;&gt; &lt;img class=&quot;lazyload&quot; onerror=&quot;imgError(this,3)&quot; src=&quot;&lt;%- theme.lazyloadImg%&gt;&quot; data-src=&quot;&lt;%= post.photos[0] || &#39;https://random.52ecy.cn/randbg.php&#39; %&gt;&quot;&gt; 但是这么改糟糕的就是可能很多图是一样的,暂时没找到解决方法呢。。不过也总比404强了吧 最后从昨晚一直折腾到今天下午三点半，总算是初步建立好了，累die 总的来说，想折腾一个好看的博客，可能并不是需要你学多少专业的知识，会多少专业的技能 而是看你有没有耐心，一颗坚持不懈的狂热的心 你需要的是借鉴模仿，以及如何从百度等搜索引擎找到解决问题方法的能力","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kaizynx.github.io/tags/Blog/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"博客魔改","slug":"Blog_modify","date":"2020-03-18T12:00:00.000Z","updated":"2022-04-10T07:52:45.125Z","comments":true,"path":"2020/03/18/Blog_modify/","link":"","permalink":"http://kaizynx.github.io/2020/03/18/Blog_modify/","excerpt":"心血来潮给差不多一年半前建的博客换波主题，然后遇到了史上难题","text":"心血来潮给差不多一年半前建的博客换波主题，然后遇到了史上难题 主题这次换的主题是 Sakura 这也太好看了吧 步骤下载主题git clone 到 theme 文件夹 准备环境去官网安装 node.js 安装 hexo npm i hexo-cli -g 修改配置文件，修改主题在 _config.yml 文件中把 theme: 选项修改 初步测试hexo g 报错 INFO Start processing FATAL Something&#39;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Template render error: (unknown path) [Line 147, Column 2] unknown block tag: note at Object._prettifyError (D:\\Blog\\node_modules\\nunjucks\\src\\lib.js:36:11) at Template.render (D:\\Blog\\node_modules\\nunjucks\\src\\environment.js:524:21) at Environment.renderString (D:\\Blog\\node_modules\\nunjucks\\src\\environment.js:362:17) at D:\\Blog\\node_modules\\hexo\\lib\\extend\\tag.js:66:9 at Promise._execute (D:\\Blog\\node_modules\\bluebird\\js\\release\\debuggability.js:303:9) at Promise._resolveFromExecutor (D:\\Blog\\node_modules\\bluebird\\js\\release\\promise.js:483:18) at new Promise (D:\\Blog\\node_modules\\bluebird\\js\\release\\promise.js:79:10) at Tag.render (D:\\Blog\\node_modules\\hexo\\lib\\extend\\tag.js:64:10) at Object.tagFilter [as onRenderEnd] (D:\\Blog\\node_modules\\hexo\\lib\\hexo\\post.js:230:16) at D:\\Blog\\node_modules\\hexo\\lib\\hexo\\render.js:65:19 at tryCatcher (D:\\Blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Promise._settlePromiseFromHandler (D:\\Blog\\node_modules\\bluebird\\js\\release\\promise.js:512:31) at Promise._settlePromise (D:\\Blog\\node_modules\\bluebird\\js\\release\\promise.js:569:18) at Promise._settlePromise0 (D:\\Blog\\node_modules\\bluebird\\js\\release\\promise.js:614:10) at Promise._settlePromises (D:\\Blog\\node_modules\\bluebird\\js\\release\\promise.js:693:18) at Async._drainQueue (D:\\Blog\\node_modules\\bluebird\\js\\release\\async.js:133:16) at Async._drainQueues (D:\\Blog\\node_modules\\bluebird\\js\\release\\async.js:143:10) at Immediate.Async.drainQueues (D:\\Blog\\node_modules\\bluebird\\js\\release\\async.js:17:14) at processImmediate (internal/timers.js:456:21) 我换回了原来的主题 next 还是报错一样的 可以看出问题出在 \\node_modules 也就是刚装的 node.js ?? 然后，对，没错，我就这么死在了第一步。 全文终 重新测试嗯，没错，我在原来的拷贝上是可以 hexo g 那么就是新的 node_modules 出了问题，可是为什么呢 然后我换了新主题又该死的报一样的错，我。。。 是的我又自闭了 傻瓜包于是我尝试傻瓜一键式安装包 npm install hexo-cli -g --save npm install hexo g 呜呜，好像成功了呜呜呜 于是本次不是博客整改升级了，而是 博客迁徙 文章迁徙最重要的一部分内容 然后，呜呜呜，又是同样的错误，大胆猜测自己之前的文章格式和新主题不符 嗯，，好像确实。。。 要勇敢舍弃，才能更好得前行(雾) 开始配置替换 _config.yml 文件 然后又错? WARN No layout: index.html 所以还是一项一项小心翼翼改 按照文档里面的改 末了总之这个主题是可以用了？ 之后就是配置这个主题了呜呼 之前下载的主题问题应该是，那个不是 hexo 的主题，是 wordpress 的主题 找到解决方法第二天进行博客迁徙 通过一篇一篇复制，终于找到了问题所在 错误信息 FATAL Something&#39;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html Nunjucks Error: [Line 108, Column 4] unknown block tag: note 错误原因是某篇 .md 中用了一下语法 {% note default %} K が奇数の時、 a,b,c を K で割ったあまりはすべて 0 である必要があります。 K が偶数の時、 a,b,c をK で割ったあまりはすべて 0 であるか、あるいはすべて K/2 である必要があります。このような組の個数は、 N 以下で K で割って 0 あまるものの個数と K/2 あまるものの個数から求めることができるので、この問題を解くことができました。 {% endnote %} 出错的就是 note 原来这个语法是 Next 主题的特性，该死 删掉即可","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kaizynx.github.io/tags/Blog/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"CF1243E. Sum Balance","slug":"Codeforces1243E","date":"2019-11-11T12:30:00.000Z","updated":"2022-04-10T07:52:45.127Z","comments":true,"path":"2019/11/11/Codeforces1243E/","link":"","permalink":"http://kaizynx.github.io/2019/11/11/Codeforces1243E/","excerpt":"","text":"题面思路这题最重要的信息是 每个数字 $a$ 都不相同 首先容易得出每行的和应该要为 $(\\sum {a_{ij}})/k$ 如果不能整除,直接不行了 记第 $i$ 行的和为 $sum_i$, $(\\sum{a_{ij}})/k = need$ 要使第 $i$ 行满足要求,设拿走的是 $a_{ij}$ 那么 $sum_i-a_{ij}+takein == need$ $takein = a_{ij}-(sum_i-need)$ 那么找到 $takein$ 是否存在于某一行 那么那一行去掉的就是 $takein$, 用同样的方法求出这行要拿进来的 那么如果能回到最初的 $a_{ij}$,则可行 也就是形成一个环,因为 每个数字都不相同,所以一个拿走要拿来的只会一一对应 也就是这些环是独立不交叉的 那么链不行,环上有多个点同一行不行 找出一些环把所有行都恰好覆盖一次就是可行方案 找环用暴力 求方案用状压dp O(3^k) 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 5e3+7; const int K = 15; int k, dfn; int n[K], p[K], c[K], a[K][N]; long long all; long long sum[K]; vector&lt;pair&lt;int, int&gt;&gt; dp[1&lt;&lt;K]; map&lt;long long, int&gt; mp; inline void check(int col, int val) { int i = col, v = val, state = 1&lt;&lt;col; long long target; vector&lt;pair&lt;int, int&gt;&gt; tmp; while (true) { target = v-sum[i]; if (!mp.count(target)) return; v = static_cast&lt;int&gt;(target); tmp.emplace_back(v, i); i = mp[target]; if (v == val) break; if (state&amp;(1&lt;&lt;i)) return; state |= 1&lt;&lt;i; } dp[state] = tmp; } int main() { cin &gt;&gt; k; for (int i = 0; i &lt; k; ++i) { cin &gt;&gt; n[i]; for (int j = 0; j &lt; n[i]; ++j) { cin &gt;&gt; a[i][j]; sum[i] += a[i][j]; mp.insert({a[i][j], i}); } all += sum[i]; } if (all%k) { cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; } all /= k; for (int i = 0; i &lt; k; ++i) sum[i] -= all; for (int i = 0; i &lt; k; ++i) { for (int j = 0; j &lt; n[i]; ++j) { check(i, a[i][j]); } } for (int i = 1; i &lt; (1&lt;&lt;k); ++i) { if (dp[i].size()) continue; for (int j = i; j; j = (j-1)&amp;i) { if (dp[j].size() &amp;&amp; dp[i-j].size()) { dp[i] = dp[i-j]; dp[i].insert(dp[i].end(), dp[j].begin(), dp[j].end()); } } } if (dp[(1&lt;&lt;k)-1].empty()) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else { cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; for (auto pr : dp[(1&lt;&lt;k)-1]) { c[mp[pr.first]] = pr.first; p[mp[pr.first]] = pr.second; } for (int i = 0; i &lt; k; ++i) { cout &lt;&lt; c[i] &lt;&lt; &quot; &quot; &lt;&lt; p[i]+1 &lt;&lt; endl; } } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1243D. 0-1 MST","slug":"Codeforces1243D","date":"2019-11-11T12:15:00.000Z","updated":"2022-04-10T07:52:45.126Z","comments":true,"path":"2019/11/11/Codeforces1243D/","link":"","permalink":"http://kaizynx.github.io/2019/11/11/Codeforces1243D/","excerpt":"","text":"题面思路一看就是最小生成树,可是边好多啊 零边肯定先随便连,再连 1 的边 先删点,再跑最小生成树 删度最小的点,(边最少) 就是保留这个点,把这点有零边相连的点都删掉 假设最坏的情况是度都一样大 $n \\times du \\leq m$ $du = m/n$ 剩下的点即为这个点的度,最坏情况也不超过 $10^3$ 级别 那么就可以跑最小生成树了 问题在于删点,删点其实相当于用 0 的代价把这些点都连上了 问题删了一波点,这波被删的点的 0 边所连点也要删去 (不妨递归?) 由于后边的删点只需判断 还没删的点 有没有和删的点有 1 边 第二波复杂度最大为 $(n-du)\\times du == (n-m/n)\\times m/n \\leq 10^5$ 所以可行 代码#include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const int N = 1e5+7; int n, m; int flag[N]; vector&lt;int&gt; e[N]; queue&lt;int&gt; del; set&lt;int&gt; p; map&lt;pair&lt;int, int&gt;, int&gt; mp; struct DSU { int fa[N]; void init(int sz) { for (int i = 0; i &lt;= sz; ++i) fa[i] = i; } int get(int s) { return s == fa[s] ? s : fa[s] = get(fa[s]); } int&amp; operator [] (int i) { return fa[get(i)]; } bool connect(int x, int y) { int fx = get(x), fy = get(y); if (fx == fy) return false; fa[fx] = fy; return true; } } dsu; #ifdef DEBUG inline void print(vector&lt;int&gt; &amp;v) { for (int i : v) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } #endif int main() { cin &gt;&gt; n &gt;&gt; m; dsu.init(n); for (int i = 1, a, b; i &lt;= m; ++i) { cin &gt;&gt; a &gt;&gt; b; e[a].push_back(b); e[b].push_back(a); mp.insert({{a, b}, 1}); mp.insert({{b, a}, 1}); } // rebuild map int mini = 1; for (int i = 2; i &lt;= n; ++i) { if (e[i].size() &lt; e[mini].size()) mini = i; } // del flag[mini] = 1; for (int i : e[mini]) { p.insert(i); flag[i] = 1; } for (int i = 1; i &lt;= n; ++i) { if (!flag[i]) del.push(i); } vector&lt;int&gt; tmp; while (del.size()) { int i = del.front(); del.pop(); tmp.clear(); for (int j : p) { if (mp.count({i, j})) continue; tmp.emplace_back(j); } for (int j : tmp) { flag[j] = 0; p.erase(j); del.push(j); } } #ifdef DEBUG print(p); #endif // build tree p.insert(mini); int cnt = 0, res = 0; for (int i : p) { for (int j : p) { if (i == j || mp.count({i, j})) continue; if (dsu.connect(i, j)) ++cnt; } } if (cnt &gt;= (int)p.size()-1) { cout &lt;&lt; 0 &lt;&lt; endl; return 0; } for (int i : p) { for (int j : p) { if (i == j || !mp.count({i, j})) continue; if (dsu.connect(i, j)) { ++res; if (++cnt &gt;= (int)p.size()-1) { cout &lt;&lt; res &lt;&lt; endl; return 0; } } } } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://kaizynx.github.io/tags/最小生成树/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1243C. Tile Painting","slug":"Codeforces1243C","date":"2019-11-11T11:55:00.000Z","updated":"2022-04-10T07:52:45.126Z","comments":true,"path":"2019/11/11/Codeforces1243C/","link":"","permalink":"http://kaizynx.github.io/2019/11/11/Codeforces1243C/","excerpt":"","text":"题面思路扩展欧几里得 $ax+by=c$ , $c$ 是 $\\gcd(a, b)$ 的倍数 那么两个因子为 $a, b$ 则能覆盖 $\\gcd(a,b)$ 倍数的地方 如果在 $n$ 范围内有 $ax == by$ 那么这个相交的块就要涂成一种颜色 也就是 $a, b$ 的块都是一种颜色 所以当且仅当 $n$ 分解质因数只有一个素数时,答案为这个素数 否则为 $1$ 代码#include &lt;bits/stdc++.h&gt; using namespace std; int cnt; long long n, p; int main() { cin &gt;&gt; n; if (n == 1) { cout &lt;&lt; 1 &lt;&lt; endl; return 0; } for (long long i = 2; i*i &lt;= n; ++i) { if (n%i) continue; p = i; if (++cnt &gt; 1) { cout &lt;&lt; 1 &lt;&lt; endl; return 0; } while (n%i == 0) n /= i; } if (n &gt; 1) ++cnt, p = n; if (cnt &gt; 1) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; p &lt;&lt; endl; return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://kaizynx.github.io/tags/扩展欧几里得/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"AtCoder - Swaps","slug":"AtCoder-nikkei2019_2C","date":"2019-11-10T11:15:00.000Z","updated":"2022-04-10T07:52:45.123Z","comments":true,"path":"2019/11/10/AtCoder-nikkei2019_2C/","link":"","permalink":"http://kaizynx.github.io/2019/11/10/AtCoder-nikkei2019_2C/","excerpt":"","text":"题面思路保持 $a, b$ 相对位置不变,把 $b$ 排序 用 选择排序 可以 $n-1$ 次操作把 $a$ 排为升序 显然这样的配对是最优的,如果这都不满足条件,那就真的不行了 再看题目要求 $n-2$ 次,那么就当少交换一次,仅有两个数位置不对 设位置不对的是 $a_i, a_j(i &lt; j)$ (排好的情况) 现在少交换了一次,变成 $a_j$ 对 $b_i$, $a_i$ 对 $b_j$ 因为 $a_i \\leq b_i, a_j \\leq b_j$ 所以 $a_i \\leq b_j$, 只需满足 $a_j \\leq b_i$ 所以最保险的方案是 $j == i+1$ 如果这能满足,那肯定可以 之后呢,一定不行了吗 不,如果排序不需要 $n-1$ 次也可 什么情况下排序不需要 $n-1$ 次? 由样例一得 某个数字排序前后位置没改变 (这么想其实还不大对) 正确思路是, 选择排序得时候, 对于$a_i$, 它现在位置为 $i$, 排序后为 $j$ 那么就要交换 $a_i, a_j$, 再把 $a_j$ 和目标位置交换 会发现这样得交换形成了一个环 设一个环的大小为 $m$, 则需要 $m-1$ 次交换 所以如果这样的交换环存在两个及以上,则满足 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5+7; int n, m; int bb[N], d[N&lt;&lt;1], to[N]; struct Node { int a, b, id; } p[N]; inline bool cmpa(const Node &amp;x, const Node &amp;y) { return x.a &lt; y.a; } inline bool cmpb(const Node &amp;x, const Node &amp;y) { return x.b &lt; y.b; } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; p[i].a, d[i] = p[i].a; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; p[i].b, d[n+i] = p[i].b; sort(d+1, d+n*2+1); m = unique(d+1, d+n*2+1)-d-1; for (int i = 1; i &lt;= n; ++i) { p[i].a = lower_bound(d+1, d+m+1, p[i].a)-d; p[i].b = lower_bound(d+1, d+m+1, p[i].b)-d; } sort(p+1, p+n+1, cmpb); for (int i = 1; i &lt;= n; ++i) { bb[i] = p[i].b; p[i].id = i; } sort(p+1, p+n+1, cmpa); for (int i = 1; i &lt;= n; ++i) { if (p[i].a &gt; bb[i]) { cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; } to[p[i].id] = i; } for (int i = 1; i &lt; n; ++i) { if (p[i+1].a &lt;= bb[i]) { cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; return 0; } } int sz = 0, now = 1; do { ++sz; now = to[now]; } while (now != 1); if (sz == n) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; return 0; }","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://kaizynx.github.io/tags/排序/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"检查「好数组」","slug":"LeetCode1250","date":"2019-11-10T11:00:00.000Z","updated":"2022-04-10T07:52:45.135Z","comments":true,"path":"2019/11/10/LeetCode1250/","link":"","permalink":"http://kaizynx.github.io/2019/11/10/LeetCode1250/","excerpt":"","text":"题面思路由扩展欧几里得可得 $ax+by=c$ 其中 $c$ 是 $\\gcd(a,b)$ 的倍数 要想得到 $1$ ,则要 $a, b$ 互质 $a, b$ 可以是数组中任意两个,也可以是任意个通过变换得到 或者说我们找到 $k_{p_1}\\times a_{p_1}+k_{p_2}\\times a_{p_2}+.. = z_1$ $k_{q_1}\\times a_{q_1}+k_{q_2}\\times a_{q_2}+.. = z_q$ 使得 $\\gcd(z_1, z_2) == 1$ 即可 假设数组为 $a_1, a_2,…a_n$ 其中 $a_i, a_j$ 能组成 $\\gcd(a_i, a_j)$ 的倍数的数 再有 $a_k, a_l$ 能组成 $\\gcd(a_k, a_l)$ 的倍数的数 其中 $i$ 可能等于 $j, k, l$ 等等 那么这四个数又可以组成 $\\gcd(\\gcd(a_i, a_j),\\gcd(a_k,a_l))$ 倍数的数 所以所有的数能组成 $\\gcd\\limits_{1 \\leq i \\leq n} a_i$ 的倍数的数 因为不断做 $\\gcd$ 只会使结果越来越小,也就是能组成的数的范围越来越大 最后判断所有数的最大公约数是否为 $1$ 即可 代码class Solution { public: bool isGoodArray(vector&lt;int&gt;&amp; nums) { int g = 0; for (int i : nums) g = __gcd(i, g); return g == 1; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://kaizynx.github.io/tags/扩展欧几里得/"}],"keywords":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}]},{"title":"AGC040B - Two Contests","slug":"AtCoder-AGC040B","date":"2019-11-05T12:00:00.000Z","updated":"2022-04-10T07:52:45.123Z","comments":true,"path":"2019/11/05/AtCoder-AGC040B/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/AtCoder-AGC040B/","excerpt":"","text":"题面思路设 $maxL = \\max\\limits_i^n l_i, minR = \\min\\limits_i^n r_i$ 那么分成两组的时候,答案为 $(minR1-maxL1)+(minR2-maxL2)$ 其中一定有 $minR1 == minR || minR2 == minR$, $maxL$ 相同 $maxL, minR$ 在同一组 那么无论加哪个到这一组,这一组的结果都不会改变,即求另一组最大值 易证 加入一个点,这组的结果只会不变或者缩小 所以另一组就是 剩下点的最大长度 $maxL, minR$ 不是同一组 那么有这么两组 $[maxL’, minR],[maxL, minR’]$ 对于第一组,要使左边界为 $maxL’$ 那么比 $maxL’$ 小的点都要加入第二组 可以得出此时的 $minR’$ ,因为再加入一个点, $minR’$ 只会变小或不变 不妨把剩下的点都加入第一组 代码#include &lt;bits/stdc++.h&gt; #define DEBUG using namespace std; const int N = 1e5+7; const int INF = 1e9; int n, res; struct Node { int l, r; friend bool operator &lt; (const Node &amp;x, const Node &amp;y) { return x.l &lt; y.l; } } a[N]; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i].l &gt;&gt; a[i].r; } sort(a+1, a+n+1); reverse(a+1, a+n+1); int rr = 1; for (int i = 1; i &lt;= n; ++i) { if (a[i].r &lt; a[rr].r) rr = i; } if (1 == rr) { for (int i = 2; i &lt;= n; ++i) { res = max(res, a[i].r-a[i].l+1); } res += a[1].r-a[1].l+1; cout &lt;&lt; res &lt;&lt; endl; return 0; } int minr = a[1].r; for (int i = 2; i &lt;= n; ++i) { if (i == rr) continue; res = max(res, max(0, a[rr].r-max(a[i].l, a[rr].l)+1)+max(0, minr-a[1].l+1)); res = max(res, max(0, a[rr].r-a[1].l+1)+a[i].r-a[i].l+1); minr = min(minr, a[i].r); } res = max(res, max(0, minr-a[1].l+1)+a[rr].r-a[rr].l+1); cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"AGC040A - ><","slug":"AtCoder-AGC040A","date":"2019-11-05T11:50:00.000Z","updated":"2022-04-10T07:52:45.123Z","comments":true,"path":"2019/11/05/AtCoder-AGC040A/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/AtCoder-AGC040A/","excerpt":"","text":"题面思路如果存在一个上升的序列 $a_i &lt; a_{i+1} &lt; … &lt; a_j$ 不妨令他们为 $0, 1, 2 …$ 反过来下降序列也相同 但最终结果要同时满足上面两种方法,故取 $\\max$ 代码#include &lt;bits/stdc++.h&gt; #define DEBUG using namespace std; const int N = 5e5+7; const int INF = 1e9; string str; int a[N]; int main() { cin &gt;&gt; str; int n = str.length()+1; long long sum = 0; for (int i = 0, cnt = 0; i &lt; n; ++i) { a[i] = max(a[i], cnt); if (i &lt; (int)str.length() &amp;&amp; str[i] == &#39;&lt;&#39;) { ++cnt; } else { cnt = 0; } } for (int i = str.length()-1, cnt = 0; i &gt;= -1; --i) { a[i+1] = max(a[i+1], cnt); if (i &gt;= 0 &amp;&amp; str[i] == &#39;&gt;&#39;) { ++cnt; } else { cnt = 0; } } for (int i = 0; i &lt; n; ++i) { sum += a[i]; } cout &lt;&lt; sum &lt;&lt; endl; return 0; }","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"CF1256F. Equalizing Two Strings","slug":"Codeforces1256F","date":"2019-11-05T11:40:00.000Z","updated":"2022-04-10T07:52:45.131Z","comments":true,"path":"2019/11/05/Codeforces1256F/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/Codeforces1256F/","excerpt":"","text":"题面思路进行长度为 2 的操作相当于交换相邻两个字符 首先,如果一个字符串有两个字符相同,先用两两交换使之相邻 那么这一字符串一直交换这两个相同的字符,就相当于不变 另一个字符串进行两两交换,则能变成任意排列,所以有限次操作总能相同 排除以上特殊情况后,剩下的最长长度为 26 (暴力???) 引理1:假设存在方法使两个字符串相同了,再进行无限次操作,只要两者选的区间相同,都相同 引理2:假设字符串 S1 能通过 n 次两两交换变成 字符串 S2,若 n 是 2 的倍数, 则满足题目要求 证明:对 S2 同一区间进行 2 的倍数次操作,不会改变 所以 那么我们不妨将两个都操作成升序序列,通过两两交换的方式,次数就是逆序对 如果两个字符串的次数差是 2 的倍数,就满足条件 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5+7; int q, n; int cnt[2][26], tot[2]; string s[2]; int main() { cin &gt;&gt; q; while (q--) { cin &gt;&gt; n; int flag = 0; memset(cnt, 0, sizeof cnt); for (int i = 0; i &lt; 2; ++i) { cin &gt;&gt; s[i]; for (int j = 0; j &lt; n; ++j) ++cnt[i][s[i][j]-&#39;a&#39;]; } flag = 1; for (int i = 0; i &lt; 26; ++i) { if (cnt[0][i] != cnt[1][i]) { flag = 0; break; } } if (!flag) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; } flag = 0; for (int i = 0; i &lt; 26; ++i) { if (cnt[0][i] &gt; 1 || cnt[1][i] &gt; 1) { flag = 1; break; } } if (flag) { cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; continue; } memset(cnt, 0, sizeof cnt); tot[0] = tot[1] = 0; for (int i = 0; i &lt; 2; ++i) { for (int j = 0; j &lt; n; ++j) { for (int k = s[i][j]-&#39;a&#39;+1; k &lt; 26; ++k) tot[i] += cnt[i][k]; ++cnt[i][s[i][j]-&#39;a&#39;]; } } cout &lt;&lt; (tot[0]%2 == tot[1]%2 ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排序","slug":"排序","permalink":"http://kaizynx.github.io/tags/排序/"},{"name":"逆序对","slug":"逆序对","permalink":"http://kaizynx.github.io/tags/逆序对/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1256E. Yet Another Division Into Teams","slug":"Codeforces1256E","date":"2019-11-05T11:35:00.000Z","updated":"2022-04-10T07:52:45.131Z","comments":true,"path":"2019/11/05/Codeforces1256E/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/Codeforces1256E/","excerpt":"","text":"题面思路首先显然要前排序,相邻的放一组 一组的人数是最少 3 人(题目要求), 最多 5 人,因为 6 人就可以分成两组 显然易证, 设有 $a_1, a_2 … a_n$ 这组的值是 $a_n-a_1$ 分成两组 $a_1, a_2 … a_i$ 和 $a_{i+1}, a_{i+2} … a_n$ 值为 $a_n-a-{i+1}+a_i-a_1$ 显然同样长度分组越多,值越小 然后就动规呗 $dp[i] = \\min\\limits_{i-5 \\leq j \\leq i-3} dp[j]+a[i].v-a[j+1].v$ 把 $[j+1, i]$ 分成一组 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 2e5+7; const int INF = 0x3f3f3f3f; int n; int t[N], dp[N], last[N]; struct Node { int v, id; friend bool operator &lt; (const Node &amp;x, const Node &amp;y) { return x.v &lt; y.v; } } a[N]; int main() { cin &gt;&gt; n; memset(dp, 0x3f, sizeof dp); for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i].v; a[i].id = i; } sort(a+1, a+n+1); dp[0] = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = max(0, i-5); j &lt;= i-3; ++j) { // dp[i] = min(dp[i], dp[j]+a[i].v-a[j+1].v); if (dp[i] &gt; dp[j]+a[i].v-a[j+1].v) { dp[i] = dp[j]+a[i].v-a[j+1].v; last[i] = j; } } } int tot = 0; for (int i = n; i; i = last[i]) { ++tot; for (int k = i; k &gt; last[i]; --k) { t[a[k].id] = tot; } } cout &lt;&lt; dp[n] &lt;&lt; &quot; &quot; &lt;&lt; tot &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) { cout &lt;&lt; (t[i] ? t[i] : 1) &lt;&lt; &quot; \\n&quot;[i==n]; } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1256D. Binary String Minimizing","slug":"Codeforces1256D","date":"2019-11-05T11:30:00.000Z","updated":"2022-04-10T07:52:45.130Z","comments":true,"path":"2019/11/05/Codeforces1256D/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/Codeforces1256D/","excerpt":"","text":"题面思路贪心策略,先把前面的 0 移到前面 (显然最优!!!不证了) 把某个 0 移到前面的代价是 这个 0 前面 1 的个数 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6+7; int q, n; long long k; string str; int main() { cin &gt;&gt; q; while (q--) { cin &gt;&gt; n &gt;&gt; k &gt;&gt; str; int j = 0; for (int i = 0, cnt = 0; i &lt; n; ++i) { if (str[i] == &#39;1&#39;) { ++cnt; } else { if (k &gt;= cnt) { k -= cnt; ++j; putchar(&#39;0&#39;); } else { for ( ; j &lt; i-k; ++j) putchar(&#39;1&#39;); putchar(&#39;0&#39;); for (j = i-k+1; j &lt;= i; ++j) putchar(&#39;1&#39;); for (j = i+1; j &lt; n; ++j) putchar(str[j]); break; } } } for ( ; j &lt; n; ++j) putchar(&#39;1&#39;); putchar(&#39;\\n&#39;); } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://kaizynx.github.io/tags/贪心/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1256C. Platforms Jumping","slug":"Codeforces1256C","date":"2019-11-05T11:20:00.000Z","updated":"2022-04-10T07:52:45.130Z","comments":true,"path":"2019/11/05/Codeforces1256C/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/Codeforces1256C/","excerpt":"","text":"题面思路易证:如果跳到某块任意长度木板,一定可以通过有限步数达到右端 不妨采取这样的贪心策略,每次跨河(没木板的地方)用最大的步数(d) 每次跳到木板的左端点,然后到右端点,再跳 d 做法如下 先设左右的木板并排在右端 如果跳一步到河里了,就把最左边的木板移到前面 懒得说了,上代码 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e3+7; int n, m, d; int c[N], res[N]; int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; d; int sum = 0; for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; c[i]; sum += c[i]; } int id = 1, p = d; for ( ; id &lt;= m &amp;&amp; p &lt; n-sum+1; ++id) { for (int j = 0; j &lt; c[id]; ++j) { res[p+j] = id; } sum -= c[id]; p += c[id]-1+d; } if (p &lt; n-sum+1) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0; } for (int i = m, j = n; i &gt;= id; --i) { for (int k = 0; k &lt; c[i]; ++k) { res[j--] = i; } } cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) { cout &lt;&lt; res[i] &lt;&lt; &quot; \\n&quot;[i==n]; } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"贪心","slug":"贪心","permalink":"http://kaizynx.github.io/tags/贪心/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1245F. Daniel and Spring Cleaning","slug":"Codeforces1245F","date":"2019-11-05T11:10:00.000Z","updated":"2022-04-10T07:52:45.128Z","comments":true,"path":"2019/11/05/Codeforces1245F/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/Codeforces1245F/","excerpt":"","text":"题面思路用位运算的目光来看 首先找到满足式子的条件 $a + b = a \\bigoplus b$ 0 0 1 1 0 1 0 1 + 0 1 1 10 ^ 0 1 1 00 可以证明当两个数的某一位都是 $1$ ,无法找到后一位的组合情况使之满足条件 于是每一位都有三个组合情况,没有限制的话就有 $3^n$ 种 于是我们加上限制条件 设函数 $calc(r,l)$ 为第一个数字 $\\leq r$ , 第二个数 $\\leq l$ 的情况数 易得答案就是 $calc(r,r)-2\\times(r, l-1)+calc(l-1, l-1)$ 设 $dp[i][j][k]$ 为最高位到第 $i$ 位为止的情况 $j$ 表示第一个数的情况 $0$ 表示这个数小于 $r$, $1$ 表示到这一位为止都等于 $r$ $k$ 表示第二个数的情况,同上 然后一共也就 $4\\times 4 = 16$ 种情况 代码#include &lt;bits/stdc++.h&gt; //#define DEBUG using namespace std; long long dp[32][2][2]; long long calc(int r, int l) { // a^b == a+b // a &lt;= r, b &lt;= l memset(dp, 0, sizeof dp); int i = 30; while (i &amp;&amp; !((r&gt;&gt;i)&amp;1)) --i; dp[i+1][1][1] = 1; for ( ; i &gt;= 0; --i) { if (((r&gt;&gt;i)&amp;1) &amp;&amp; ((l&gt;&gt;i)&amp;1)) { dp[i][0][0] = 3*dp[i+1][0][0]+2*dp[i+1][0][1]+2*dp[i+1][1][0]+1*dp[i+1][1][1]; dp[i][0][1] = 0*dp[i+1][0][0]+1*dp[i+1][0][1]+0*dp[i+1][1][0]+1*dp[i+1][1][1]; dp[i][1][0] = 0*dp[i+1][0][0]+0*dp[i+1][0][1]+1*dp[i+1][1][0]+1*dp[i+1][1][1]; dp[i][1][1] = 0*dp[i+1][0][0]+0*dp[i+1][0][1]+0*dp[i+1][1][0]+0*dp[i+1][1][1]; } else if (((r&gt;&gt;i)&amp;1) == 0 &amp;&amp; ((l&gt;&gt;i)&amp;1)) { dp[i][0][0] = 3*dp[i+1][0][0]+2*dp[i+1][0][1]+0*dp[i+1][1][0]+0*dp[i+1][1][1]; dp[i][0][1] = 0*dp[i+1][0][0]+1*dp[i+1][0][1]+0*dp[i+1][1][0]+0*dp[i+1][1][1]; dp[i][1][0] = 0*dp[i+1][0][0]+0*dp[i+1][0][1]+2*dp[i+1][1][0]+1*dp[i+1][1][1]; dp[i][1][1] = 0*dp[i+1][0][0]+0*dp[i+1][0][1]+0*dp[i+1][1][0]+1*dp[i+1][1][1]; } else if (((r&gt;&gt;i)&amp;1) &amp;&amp; ((l&gt;&gt;i)&amp;1) == 0) { dp[i][0][0] = 3*dp[i+1][0][0]+0*dp[i+1][0][1]+2*dp[i+1][1][0]+0*dp[i+1][1][1]; dp[i][0][1] = 0*dp[i+1][0][0]+2*dp[i+1][0][1]+0*dp[i+1][1][0]+1*dp[i+1][1][1]; dp[i][1][0] = 0*dp[i+1][0][0]+0*dp[i+1][0][1]+1*dp[i+1][1][0]+0*dp[i+1][1][1]; dp[i][1][1] = 0*dp[i+1][0][0]+0*dp[i+1][0][1]+0*dp[i+1][1][0]+1*dp[i+1][1][1]; } else { dp[i][0][0] = 3*dp[i+1][0][0]+0*dp[i+1][0][1]+0*dp[i+1][1][0]+0*dp[i+1][1][1]; dp[i][0][1] = 0*dp[i+1][0][0]+2*dp[i+1][0][1]+0*dp[i+1][1][0]+0*dp[i+1][1][1]; dp[i][1][0] = 0*dp[i+1][0][0]+0*dp[i+1][0][1]+2*dp[i+1][1][0]+0*dp[i+1][1][1]; dp[i][1][1] = 0*dp[i+1][0][0]+0*dp[i+1][0][1]+0*dp[i+1][1][0]+1*dp[i+1][1][1]; } #ifdef DEBUG for (int j = 0; j &lt; 2; ++j) { for (int k = 0; k &lt; 2; ++k) { printf(&quot;dp[%d][%d][%d]=%I64d &quot;, i, j, k, dp[i][j][k]); } } putchar(&#39;\\n&#39;); #endif } return dp[0][0][0]+dp[0][0][1]+dp[0][1][0]+dp[0][1][1]; } int main() { int t, l, r; cin &gt;&gt; t; while (t--) { cin &gt;&gt; l &gt;&gt; r; #ifdef DEBUG cout &lt;&lt; calc(r, r) &lt;&lt; &quot; &quot; &lt;&lt; calc(r, l-1) &lt;&lt; &quot; &quot; &lt;&lt; calc(l-1, l-1) &lt;&lt; endl; #endif if (!l &amp;&amp; !r) cout &lt;&lt; 1 &lt;&lt; endl; else if (!l) cout &lt;&lt; calc(r, r) &lt;&lt; endl; else cout &lt;&lt; (calc(r, r)-2*calc(r, l-1)+calc(l-1, l-1)) &lt;&lt; endl; } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"},{"name":"位运算","slug":"位运算","permalink":"http://kaizynx.github.io/tags/位运算/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1245A. Good ol' Numbers Coloring","slug":"Codeforces1245A","date":"2019-11-05T10:50:00.000Z","updated":"2022-04-10T07:52:45.127Z","comments":true,"path":"2019/11/05/Codeforces1245A/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/Codeforces1245A/","excerpt":"","text":"题面思路由扩展欧几里得可得 $ax+by=c$ 其中 $c \\% \\gcd(a,b) == 0$ 易得,如果 $\\gcd(a,b) == 1$ 那么就能把后面填满 由于 $x \\geq 0, y \\geq 0$, 所以前面有几个不能填 总之互素就是有限 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e2+7; int t, a, b; int main() { cin &gt;&gt; t; while (t--) { cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; (__gcd(a, b) == 1 ? &quot;Finite&quot; : &quot;Infinite&quot;) &lt;&lt; endl; } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://kaizynx.github.io/tags/扩展欧几里得/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1245C. Constanze's Machine","slug":"Codeforces1245C","date":"2019-11-05T10:45:00.000Z","updated":"2022-04-10T07:52:45.127Z","comments":true,"path":"2019/11/05/Codeforces1245C/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/Codeforces1245C/","excerpt":"","text":"题面思路思路应该很简单,找到连续的u(或n),求出这么多个u(n)能有几种变换 把所有连续段的种数乘起来,显然嘛 那么怎么求有几种变换 通过手动计算前几个发现是斐波那契(逃 大胆猜测,胡乱验证 设dp[n]表示长度为n的序列的变换种数 假如在一个连续的加上一个 1.这个不和任意一个合并 dp[n-1] 2.这个和前一个合并dp[n-2] 所以dp[n] = dp[n-1] + dp[n-2] 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5+7; const int MOD = 1e9+7; template &lt;int _MOD&gt; struct Mint { int v = 0; Mint() {} Mint(int _v) : v((_v%_MOD+_MOD)%_MOD) {} Mint(long long _v) : v(static_cast&lt;int&gt;((_v%_MOD+_MOD)%_MOD)) {} Mint operator = (const int _v) { this-&gt;v = _v; return *this; } Mint operator = (const long long _v) { this-&gt;v = static_cast&lt;int&gt;(_v%_MOD); return *this; } bool operator &lt; (const Mint &amp;b) const { return v &lt; b.v; } bool operator &gt; (const Mint &amp;b) const { return v &gt; b.v; } bool operator == (const Mint &amp;b) const { return v == b.v; } bool operator != (const Mint &amp;b) const { return v != b.v; } bool operator &lt;= (const Mint &amp;b) const { return v &lt; b.v || v == b.v; } bool operator &gt;= (const Mint &amp;b) const { return v &gt; b.v || v == b.v; } Mint operator + (const Mint &amp;b) { return Mint(v+b.v); } Mint operator - (const Mint &amp;b) { return Mint(v-b.v); } Mint operator * (const Mint &amp;b) { return Mint(1ll*v*b.v); } Mint operator / (const Mint &amp;b) { return Mint(b.inv()*v); } Mint operator += (const Mint &amp;b) { return *this = *this+b; } Mint operator -= (const Mint &amp;b) { return *this = *this-b; } Mint operator *= (const Mint &amp;b) { return *this = *this*b; } Mint operator /= (const Mint &amp;b) { return *this = *this/b; } Mint pow(int p) const { Mint res(1), x(*this); while (p) { if (p&amp;1) res = res*x; x *= x; p &gt;&gt;= 1; } return res; } Mint inv() const { return pow(_MOD-2); } friend istream&amp; operator &gt;&gt; (istream &amp;is, Mint &amp;mt) { return is &gt;&gt; mt.v; } friend ostream&amp; operator &lt;&lt; (ostream &amp;os, const Mint &amp;mt) { return os &lt;&lt; mt.v; } }; using mint = Mint&lt;MOD&gt;; string str; mint f[N]; mint res = 1; int main() { cin &gt;&gt; str; f[0] = 1; f[1] = 1; f[2] = 2; f[3] = 3; for (int i = 2; i &lt; N; ++i) { f[i] = f[i-1]+f[i-2]; } for (int i = 0; i &lt; (int)str.length(); ++i) { if (str[i] == &#39;m&#39; || str[i] == &#39;w&#39;) { res = 0; break; } if (str[i] != &#39;n&#39; &amp;&amp; str[i] != &#39;u&#39;) continue; char c = str[i]; int cnt = 1; while (i+1 &lt; (int)str.length() &amp;&amp; str[i+1] == c) { ++i; ++cnt; } res *= f[cnt]; } cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"斐波那契","slug":"斐波那契","permalink":"http://kaizynx.github.io/tags/斐波那契/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1245D. Shichikuji and Power Grid","slug":"Codeforces1245D","date":"2019-11-05T10:40:00.000Z","updated":"2022-04-10T07:52:45.128Z","comments":true,"path":"2019/11/05/Codeforces1245D/","link":"","permalink":"http://kaizynx.github.io/2019/11/05/Codeforces1245D/","excerpt":"","text":"题面思路设电站为节点 0 把在 i 建设电站当成链接 0 和 i 就是简单的最小生成树问题 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 2e3+7; struct Node { int x, y; } a[N]; struct Edge { int i, j; long long w; Edge(){} Edge(int _i, int _j, long long _w) : i(_i), j(_j), w(_w) {} friend bool operator &lt; (const Edge &amp;x, const Edge &amp;y) { return x.w &lt; y.w; } }; int n; int c[N], k[N], fa[N], choose[N]; vector&lt;Edge&gt; v, ans; inline int dis(int i, int j) { return abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y); } int getf(int x) { return fa[x] == x ? x : fa[x] = getf(fa[x]); } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i].x &gt;&gt; a[i].y; } for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; c[i]; v.push_back(Edge(0, i, c[i])); } for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; k[i]; for (int j = 1; j &lt; i; ++j) { v.push_back(Edge(i, j, 1ll*(k[i]+k[j])*dis(i, j))); } } sort(v.begin(), v.end()); for (int i = 0; i &lt;= n; ++i) fa[i] = i; long long res = 0; int cntc = 0, cnte = 0, cnt = 0; for (auto e : v) { int fi = getf(e.i), fj = getf(e.j); if (fi == fj) continue; fa[fi] = fj; res += e.w; if (e.i == 0) { choose[e.j] = 1; ++cntc; } else { ans.push_back(e); ++cnte; } if (++cnt &gt;= n) break; } cout &lt;&lt; res &lt;&lt; endl; cout &lt;&lt; cntc &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) { if (choose[i]) cout &lt;&lt; i &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; cnte &lt;&lt; endl; for (auto e : ans) { cout &lt;&lt; e.i &lt;&lt; &quot; &quot; &lt;&lt; e.j &lt;&lt; endl; } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://kaizynx.github.io/tags/最小生成树/"},{"name":"并查集","slug":"并查集","permalink":"http://kaizynx.github.io/tags/并查集/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1251C. Minimize The Integer","slug":"Codeforces1251C","date":"2019-10-29T06:35:00.000Z","updated":"2022-04-10T07:52:45.130Z","comments":true,"path":"2019/10/29/Codeforces1251C/","link":"","permalink":"http://kaizynx.github.io/2019/10/29/Codeforces1251C/","excerpt":"","text":"题面思路发现奇数之间相对位置不变 偶数之间相对位置也不变 以上易证 奇偶数之间可以随便变 比如有序列 1010-&gt;1001-&gt;0101-&gt;0011 如果一个偶数想换到一个奇数前面, 只要前面是奇数就可以一直向前 当碰到偶数停止,那么先让前面的偶数以相同方式前进 这个你想换的偶数就可以继续前进了 最后用归并思想把奇数堆偶数堆合并即可 代码 int t, n; int a[2][N], cnt[2]; char s[N]; int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%s&quot;, s); n = strlen(s); cnt[0] = cnt[1] = 0; for (int i = 0, cur; i &lt; n; ++i) { cur = s[i]-&#39;0&#39;; a[cur&amp;1][++cnt[cur&amp;1]] = cur; } int i = 1, j = 1; while (i &lt;= cnt[0] &amp;&amp; j &lt;= cnt[1]) { if (a[0][i] &lt; a[1][j]) printf(&quot;%d&quot;, a[0][i++]); else printf(&quot;%d&quot;, a[1][j++]); } while (i &lt;= cnt[0]) printf(&quot;%d&quot;, a[0][i++]); while (j &lt;= cnt[1]) printf(&quot;%d&quot;, a[1][j++]); putchar(&#39;\\n&#39;); } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排序","slug":"排序","permalink":"http://kaizynx.github.io/tags/排序/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1246B. Power Products","slug":"Codeforces1246B","date":"2019-10-29T06:25:00.000Z","updated":"2022-04-10T07:52:45.129Z","comments":true,"path":"2019/10/29/Codeforces1246B/","link":"","permalink":"http://kaizynx.github.io/2019/10/29/Codeforces1246B/","excerpt":"","text":"题面思路在质因数分解的情况下 $num = \\sum{a_i^{p_i}}$ 两数相乘能表示为 $x^k$ 则每个 $pi$ 的和是 $k$ 的倍数 不妨用 哈希 来寻找 以 $\\sum{a_i^{p_i\\%k}}$ 的形式存储 对应的就是 $a_i^{k-p_i\\%k}$ tip: vector可以做map键值 代码自己写的双哈希( $c$ 和 $mod$ 是常数) $hash = c^{a_i}\\times p_i \\% mod$ #include &lt;bits/stdc++.h&gt; // #define DEBUG using namespace std; const int N = 1e5+7; const int M = 1e4+7; const int C[2] = { 23, 31 }; const int MOD = 998244353; template &lt;int _MOD&gt; struct Mint { int v = 0; Mint() {} Mint(int _v) : v((_v%_MOD+_MOD)%_MOD) {} Mint(long long _v) : v(static_cast&lt;int&gt;((_v%_MOD+_MOD)%_MOD)) {} Mint operator = (const int _v) { this-&gt;v = _v; return *this; } Mint operator = (const long long _v) { this-&gt;v = static_cast&lt;int&gt;(_v%_MOD); return *this; } bool operator &lt; (const Mint &amp;b) const { return v &lt; b.v; } bool operator &gt; (const Mint &amp;b) const { return v &gt; b.v; } bool operator == (const Mint &amp;b) const { return v == b.v; } bool operator != (const Mint &amp;b) const { return v != b.v; } bool operator &lt;= (const Mint &amp;b) const { return v &lt; b.v || v == b.v; } bool operator &gt;= (const Mint &amp;b) const { return v &gt; b.v || v == b.v; } Mint operator + (const Mint &amp;b) { return Mint(v+b.v); } Mint operator - (const Mint &amp;b) { return Mint(v-b.v); } Mint operator * (const Mint &amp;b) { return Mint(1ll*v*b.v); } Mint operator / (const Mint &amp;b) { return Mint(b.inv()*v); } Mint operator += (const Mint &amp;b) { return *this = *this+b; } Mint operator -= (const Mint &amp;b) { return *this = *this-b; } Mint operator *= (const Mint &amp;b) { return *this = *this*b; } Mint operator /= (const Mint &amp;b) { return *this = *this/b; } Mint pow(int p) const { Mint res(1), x(*this); while (p) { if (p&amp;1) res = res*x; x *= x; p &gt;&gt;= 1; } return res; } Mint inv() const { return pow(_MOD-2); } friend istream&amp; operator &gt;&gt; (istream &amp;is, Mint &amp;mt) { return is &gt;&gt; mt.v; } friend ostream&amp; operator &lt;&lt; (ostream &amp;os, const Mint &amp;mt) { return os &lt;&lt; mt.v; } }; using mint = Mint&lt;MOD&gt;; int n, k, cnt; bool check[N]; int a[N], prime[M], fp[N]; mint my_hash[2][N], rev_hash[2][N]; long long res; map&lt;pair&lt;int, int&gt;, int&gt; mp; inline void init() { check[1] = true; for(int i = 2; i &lt; N; ++i) { if(!check[i]) { ++cnt; prime[cnt] = i; fp[i] = cnt; } for(int j = 1; j &lt;= cnt &amp;&amp; i*prime[j] &lt; N; ++j) { check[ i*prime[j] ] = true; if(i % prime[j] == 0) break; } } } inline mint qpow(mint a, int p) { mint res = 1; while (p) { if (p&amp;1) res *= a; a *= a; p &gt;&gt;= 1; } return res; } int main() { cin &gt;&gt; n &gt;&gt; k; init(); for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i]; // 分解质因数 for (int j = 1, pi; prime[j]*prime[j] &lt;= a[i]; ++j) { if (a[i]%prime[j]) continue; pi = 0; while (a[i]%prime[j] == 0) a[i] /= prime[j], ++pi; pi %= k; // a[i] = sum prime[j]^pi // hash = sum c^j*pi for (int h = 0; h &lt; 2; ++h) { my_hash[h][i] += qpow(C[h], j)*pi; rev_hash[h][i] += qpow(C[h], j)*((k-pi)%k); } } if (a[i] &gt; 1) { for (int h = 0, j = fp[a[i]], pi = 1; h &lt; 2; ++h) { my_hash[h][i] += qpow(C[h], j)*pi; rev_hash[h][i] += qpow(C[h], j)*((k-pi)%k); } } res += mp[{rev_hash[0][i].v, rev_hash[1][i].v}]; ++mp[{my_hash[0][i].v, my_hash[1][i].v}]; } cout &lt;&lt; res &lt;&lt; endl; return 0; } vector作为map键值 简单快捷,好用到哭了 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5+7; const int M = 1e4+7; int n, k, cnt; bool check[N]; int a[N], prime[M], fp[N]; long long res; map&lt;vector&lt;pair&lt;int, int&gt;&gt;, int&gt; mp; inline void init() { check[1] = true; for(int i = 2; i &lt; N; ++i) { if(!check[i]) { ++cnt; prime[cnt] = i; fp[i] = cnt; } for(int j = 1; j &lt;= cnt &amp;&amp; i*prime[j] &lt; N; ++j) { check[ i*prime[j] ] = true; if(i % prime[j] == 0) break; } } } int main() { cin &gt;&gt; n &gt;&gt; k; init(); for (int i = 1, a, pi; i &lt;= n; ++i) { cin &gt;&gt; a; vector&lt;pair&lt;int, int&gt;&gt; my_hash, rev_hash; for (int j = 1; prime[j]*prime[j] &lt;= a; ++j) { if (a%prime[j]) continue; pi = 0; while (a%prime[j] == 0) a /= prime[j], ++pi; pi %= k; // a[i] = sum prime[j]^pi if (pi) { my_hash.push_back({j, pi}); rev_hash.push_back({j, k-pi}); } } if (a &gt; 1) { my_hash.push_back({fp[a], 1}); rev_hash.push_back({fp[a], k-1}); } res += mp[rev_hash]; ++mp[my_hash]; } cout &lt;&lt; res &lt;&lt; endl; return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"质因数分解","slug":"质因数分解","permalink":"http://kaizynx.github.io/tags/质因数分解/"},{"name":"哈希","slug":"哈希","permalink":"http://kaizynx.github.io/tags/哈希/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"CF1246A. p-binary","slug":"Codeforces1246A","date":"2019-10-29T06:10:00.000Z","updated":"2022-04-10T07:52:45.129Z","comments":true,"path":"2019/10/29/Codeforces1246A/","link":"","permalink":"http://kaizynx.github.io/2019/10/29/Codeforces1246A/","excerpt":"","text":"题面思路如果去掉 $p$ 的影响, 就可以用二进制的目光看待 $n$ 最少的数量, $n$ 的二进制每个 $1$ 都用特定的组成 而一个高位的 $1$ 可以拆成两个低位的 $1$ 因此最多全部拆成 $2^0$ ,最多由 $n$ 个 因此范围其实很大… 分析可得答案不大,不妨枚举答案个数,此时考虑 $n-p*res$ 即可 代码当时没想开,暴力拆分了(逃 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5+7; int n, p; long long pow2[32]; inline pair&lt;long long, long long&gt; count(int a) { pair&lt;long long, long long&gt; res = { 0, 0 }; for (int i = 0; i &lt;= 30; ++i) { if ((a&gt;&gt;i)&amp;1) { ++res.first; res.second += pow2[i]; } } return res; } int main() { pow2[0] = 1; for (int i = 1; i &lt;= 30; ++i) pow2[i] = pow2[i-1]&lt;&lt;1; cin &gt;&gt; n &gt;&gt; p; // n-p*res &gt; 0 for (int x = 1; n-x*p &gt; 0; ++x) { pair&lt;long long, long long&gt; tmp = count(n-x*p); if (x &gt;= tmp.first &amp;&amp; x &lt;= tmp.second) { cout &lt;&lt; x &lt;&lt; endl; return 0; } } cout &lt;&lt; -1 &lt;&lt; endl; return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"位运算","slug":"位运算","permalink":"http://kaizynx.github.io/tags/位运算/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"ABC143E - Travel by Car","slug":"AtCoder-ABC143E","date":"2019-10-29T06:00:00.000Z","updated":"2022-04-10T07:52:45.121Z","comments":true,"path":"2019/10/29/AtCoder-ABC143E/","link":"","permalink":"http://kaizynx.github.io/2019/10/29/AtCoder-ABC143E/","excerpt":"","text":"题面有N个点M条带权边 加一次油最多走L路程,只能在节点加油 Q个询问,能不能从s到t,能输出最少加油几次,否则-1 数据范围Q &lt;= N &lt;= 300 思路显然求最短路 难点在于加油 转换问题成为 两个点之间距离 &gt; L 不能走 距离 &lt;= L 权值为 1 以这样的方式重建一张图求最短路就是答案 以上建议用 Floyd 实现 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 3e2+7; const int INT_INF = 0x3f3f3f3f; const long long LL_INF = 1e18; int n, m, l, q; int e[N][N], res[N][N]; long long dis[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; l; for (int i = 1, a, b, c; i &lt;= m; ++i) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; e[a][b] = e[b][a] = c; } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if (i == j) dis[i][j] = 0; else dis[i][j] = (e[i][j] ? e[i][j] : LL_INF); } } for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]); } } } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if (i == j) res[i][j] = 0; else res[i][j] = (dis[i][j] &lt;= l ? 0 : INT_INF); } } for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { res[i][j] = min(res[i][j], res[i][k]+res[k][j]+1); } } } int s, t; cin &gt;&gt; q; while (q--) { cin &gt;&gt; s &gt;&gt; t; cout &lt;&lt; (res[s][t] &gt;= INT_INF ? -1 : res[s][t]) &lt;&lt; endl; } return 0; }","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://kaizynx.github.io/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"http://kaizynx.github.io/tags/最短路/"},{"name":"Floyd","slug":"Floyd","permalink":"http://kaizynx.github.io/tags/Floyd/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"ABC143F - Distinct Numbers","slug":"AtCoder-ABC143F","date":"2019-10-29T05:50:00.000Z","updated":"2022-04-10T07:52:45.121Z","comments":true,"path":"2019/10/29/AtCoder-ABC143F/","link":"","permalink":"http://kaizynx.github.io/2019/10/29/AtCoder-ABC143F/","excerpt":"","text":"题面给 $N$ 堆卡片,每堆有 $A_i$ 个 选择一个 $K$ 每次从任意 $K$ 堆中各拿一张 问 $K=1,2…N$ 最多能拿几张 数据范围$1 \\leq N \\leq 3 \\times 10^5$ $1 \\leq A_i \\leq N$ 思路二分答案,判断 设最多可以拿 $mid$ 次 对于 $Ai \\geq mid$ 可以每次都拿 对于 $Ai &lt; mid$ 策略贪心易得 每次从最多的几堆取 因为不够取 $mid$ 次,所以肯定会取完并由其他堆顶替 当有一堆取完了,那么取完之前这堆有 $1$ 个,那么替补的里面最大的也是 $1$,所以保证最大效率取 即能取 $\\lfloor \\frac{sum}{K} \\rfloor$ 次 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 3e5+7; int n, m; int cnt[N], sum[N]; int main() { cin &gt;&gt; n; for (int i = 1, a; i &lt;= n; ++i) { cin &gt;&gt; a; ++cnt[a]; } sort(cnt+1, cnt+N); reverse(cnt+1, cnt+N); m = 1; while (cnt[m+1]) ++m; reverse(cnt+1, cnt+m+1); for (int i = 1; i &lt;= m; ++i) sum[i] = sum[i-1]+cnt[i]; for (int k = 1, l, r, mid; k &lt;= n; ++k) { if (k &gt; m) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } l = 0; r = n; while (l &lt; r) { mid = (l+r+1)&gt;&gt;1; int p = lower_bound(cnt+1, cnt+m+1, mid)-cnt-1; if (m-p &gt;= k || sum[p]/(k-m+p) &gt;= mid) l = mid; else r = mid-1; } cout &lt;&lt; l &lt;&lt; endl; } return 0; }","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://kaizynx.github.io/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"http://kaizynx.github.io/tags/贪心/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"循环码排列","slug":"LeetCode1238","date":"2019-10-29T05:30:00.000Z","updated":"2022-04-10T07:52:45.135Z","comments":true,"path":"2019/10/29/LeetCode1238/","link":"","permalink":"http://kaizynx.github.io/2019/10/29/LeetCode1238/","excerpt":"一道有趣得构造题","text":"一道有趣得构造题传送 题面给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,…,2^n-1) 的排列 p，并且满足： p[0] = start p[i] 和 p[i+1] 的二进制表示形式只有一位不同 p[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同 示例 1：输入：n = 2, start = 输出：[3,2,0,1] 解释：这个排列的二进制表示是 (11,10,00,01) 所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2] 示例 2：输出：n = 3, start = 2 输出：[2,6,7,5,4,0,1,3] 解释：这个排列的二进制表示是 (010,110,111,101,100,000,001,011) 提示：1 &lt;= n &lt;= 16 0 &lt;= start &lt; 2^n 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/circular-permutation-in-binary-representation著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解假设 start 是 0, 由样例二易得 000,001,011,010,110,111,101,100... 且首尾可相接 于是我神奇得发现,除去第一位,后面得就是前面反过来来一遍 0,1 00,01,11,10 当前面多了个1,后面一位是0,1反着来 110,111,101,100 同样,把首位的1去掉,就是上面一行反过来 就这么神奇得由样例看出了构造法,具体我也不知道怎么回事反正 代码class Solution { public: vector&lt;int&gt; circularPermutation(int n, int start) { vector&lt;int&gt; res, v; int p = 0; v.push_back(0); for (int i = 0; i &lt; n; ++i) { for (int j = 1; j &lt;= (1&lt;&lt;i); ++j) { int tmp = (1&lt;&lt;i)+v[(1&lt;&lt;i)-j]; v.push_back(tmp); if (start == tmp) p = v.size()-1; } } for (int i = 0; i &lt; v.size(); ++i) { res.push_back(v[(p+i)%v.size()]); } return res; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}],"tags":[{"name":"构造","slug":"构造","permalink":"http://kaizynx.github.io/tags/构造/"}],"keywords":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}]},{"title":"寒假总结","slug":"2019Winter","date":"2019-02-10T16:00:00.000Z","updated":"2022-04-10T07:52:45.117Z","comments":true,"path":"2019/02/11/2019Winter/","link":"","permalink":"http://kaizynx.github.io/2019/02/11/2019Winter/","excerpt":"","text":"首先哀叹这个仅有十余天的寒假(2018.02.01-2019.02.11) 怎么说也是高三以来最长的(以及可能是最后的)假期啦 过的还是比较充实吧…(写作业是不可能的,这辈子都不可能的) 好歹坚持每天(平均下来)看点书 《数学之美》 ——吴军《白鹿原》 ——陈忠实 这两本平均下来也有一天一章(自我安慰没有虚度时光) 机器学习的课程倒是拉下不少了… 还有每天坚持看一部电影(啦啦啦励志刷完豆瓣电影TOP250) 最后还是不忘肝OI TZOJ 北师大附中猪年快乐大奖赛 题目较水(不存在的),一些数学题神仙… 最后一题写不来(据说前三有奖金,退役了就别去抢了哈) 很多搜得到原题,题解抄不来(///) LeetCode 也就俩星期啊 明明觉得最后一题写出来了,感觉就是出BUG了(气)掉分 历史最高成就(排名还没更新) Atcoder 本来有两场的,一场ABC,当晚还有CodeForces(虽然不冲突)但是懒得打(段位太高不排名) 发挥emmmm,很快就把会写得写完了,后面思考人生…不过上分了 CodeForces 比赛真多,打了四场 第一次好似被攻击了,延迟+不计排名,心态崩了 本来自我感觉良好,写了四题,唉 不过蓝名了呢,可喜可贺","categories":[{"name":"OI","slug":"OI","permalink":"http://kaizynx.github.io/categories/OI/"}],"tags":[],"keywords":[{"name":"OI","slug":"OI","permalink":"http://kaizynx.github.io/categories/OI/"}]},{"title":"Java 学习笔记","slug":"Java-learning","date":"2019-02-02T14:22:22.000Z","updated":"2022-04-10T07:52:45.134Z","comments":true,"path":"2019/02/02/Java-learning/","link":"","permalink":"http://kaizynx.github.io/2019/02/02/Java-learning/","excerpt":"","text":"入门格式 public class DataTypesC { public static void main(String[] args) { System.out.println(); } } 注释 // sigle line comment /* multiple lines */ 数据类型 int boolean char // example int myNumber = 42; boolean isFun = true; char movieRating = &#39;A&#39;; 运算符号 + - * / % // Relational Operators &lt; // less than. &lt;= // less than or equal to. &gt; // greater than. &gt;= // greater than or equal to. // Equality Operators == // equal to. != // not equal to. // Boolean Operators &amp;&amp; // and || // or ! // not Conditionals and Control Flow条件和控制流？ public class Conditionals { public static void main(String[] args) { /* Conditionals and Control Flow */ // If Statement if ( ) { ; } else if ( ) { ; } else { ; } // Ternary Conditional // () ? : int a = 1 &lt; 2 ? 1 : 2; // Switch Statement switch ( ) { case 1 : ; break; case 2 : ; break; default: ; break; } // For Loop for (int counter = 0; counter &lt; 5; counter++) { ; } } } object-oriented programming (OOP) 面向对象编程 // Class class class_name { // Instance Variables int parameter; // constructor public class_name(int arg = 233) { parameter = arg; } // Method public void method() { ; } // The main Method public static void main(String[] args) { // instance class_name instance = new class_name(); // Using Method instance.method(); } } // Inheritance class another_class extends class_name { } Data Structures数据结构 // import java.util.*; import java.util.ArrayList; import java.util.HashMap; public class Temperatures { public static void main(String[] args) { // ArrayList ArrayList&lt;Integer&gt; myArray = new ArrayList&lt;Integer&gt;(); // ArrayList: Manipulation myArray.add(233); // ArrayList: Insertion myArray.add(0, 666); // insert 666 at [0] and others push back // ArrayList: Access myArray.get(0); // return 233 // size() myArray.size(); // For Loop for(int i = 0; i &lt; myArray.size(); ++i) ; // For Each Loop for(Integer i : myArray) ; // HashMap HashMap&lt;String, Integer&gt; myHash = new HashMap&lt;String, Integer&gt;(); // HashMap: Manipulation myHash.put(&quot;Index&quot;, 233); // HashMap: Access myHash.get(&quot;Index&quot;); // Iterating over a HashMap for(String index : myHash.keySet()) { System.out.println(myHash.get(index)); } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://kaizynx.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kaizynx.github.io/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://kaizynx.github.io/categories/Java/"}]},{"title":"最短超级串","slug":"LeetCode943","date":"2018-11-23T05:10:00.000Z","updated":"2022-04-10T07:52:45.136Z","comments":true,"path":"2018/11/23/LeetCode943/","link":"","permalink":"http://kaizynx.github.io/2018/11/23/LeetCode943/","excerpt":"","text":"传送门 题面给定一个字符串数组 A，找到以 A 中每个字符串作为子字符串的最短字符串。 我们可以假设 A 中没有字符串是 A 中另一个字符串的子字符串。 数据范围1 &lt;= A.length &lt;= 12 1 &lt;= A[i].length &lt;= 20 题解一开始想当然先预处理两两字符串之间的重叠部分 e[i][j] 表示 字符串i的后缀 与 字符串j的前缀 的最大重叠长度 找不到什么骚操作,暴力求解了 for(int i = 0; i &lt; A.size(); ++i) { for(int j = 0; j &lt; A.size(); ++j) { if(i == j) continue; int flag = 0; for(int si = 0; si &lt; A[i].length(); ++si) { int p = si, q = 0; while(p &lt; A[i].length() &amp;&amp; q &lt; A[j].length() &amp;&amp; A[i][p] == A[j][q]) p++, q++; if(p == A[i].length()) { flag = A[i].length()-si; break; } } e[i][j] = flag; } } 之后感觉问题的模型已经出来了 求最长路 于是我以 Dijiskra 为原型写了四五遍,最终 发现做不出来…唉,所以比赛就结束了 后来发现最短路的什么三角形法则根本无法适用于最长路 于是又尝试 Bellmand 就发现啊,这是个带0边还有正环的有向图 额,0边没影响,有向也没事,可是正环…不存在最长路… 最终提炼出来的模型是:带正环的图,每个点只能经过一次,求最长路,输出路径 怎么办,最短路算法都没辙,那就…暴力 毕竟数据这么小,想也不是N方算法跑出来的 想法1:枚举每种连接的方案,全排列 O(n!) void dfs(int cur, int last, vector&lt;string&gt; &amp;A, string now) { if(now.length() &gt; ans.length()) return; if(cur &gt;= A.size()) { if(now.length() &lt; ans.length()) ans = now; return; } for(int i = 0; i &lt; A.size(); ++i) { if(vis[i]) continue; vis[i] = 1; dfs(cur+1, i, A, now+A[i].substr(e[last][i])); vis[i] = 0; } } 妥妥T了 想法2: 状压DP O(N^2*2^N) 一直卡了一星期终于做出来… 定义状态 dp[i][s] s表示二进制下当前以及访问过的点,i表示当前状态下最后访问的点,存储的值表示当前最小长度 状态转移方程: dp[i][s] = min( dp[j][s^(1&lt;&lt;i)] + A[j].length() - e[j][i] ) 二进制的骚操作不多说了,其中j是s中访问过的某个点 初始化: dp[i][1&lt;&lt;i] = A[i].length(), 其余设为 INF(无穷大) 最终结果: max( dp[i][(1&lt;&lt;A.size())-1]) memset(dp, 0x3f, sizeof dp); memset(last, -1, sizeof last); for(int i = 0; i &lt; A.size(); ++i) dp[i][0] = 0, dp[i][1&lt;&lt;i] = A[i].length(); for(int i = 1; i &lt; (1&lt;&lt;A.size()); ++i) for(int now = 0; now &lt; A.size(); ++now) if(i&amp;(1&lt;&lt;now)) for(int pre = 0; pre &lt; A.size(); ++pre) if((i&amp;(1&lt;&lt;pre)) &amp;&amp; now != pre) { int tmp = dp[pre][i^(1&lt;&lt;now)]+A[now].length()-e[pre][now]; if(dp[now][i] &gt; tmp) { dp[now][i] = tmp; last[now][i] = pre; } } int resi = 0, nows = (1&lt;&lt;A.size())-1; for(int i = 1; i &lt; A.size(); ++i) if(dp[i][nows] &lt; dp[resi][nows]) resi = i; cout &lt;&lt; dp[resi][nows] &lt;&lt; endl; ////// 然后还有一个头疼的地方是输出路径 用 last[i][s] 记录一下前驱,就是记录 j 倒过来找,再翻回去,这样就求出了字符串的排列 vector&lt;int&gt; ress; while(resi != -1) { cout &lt;&lt; resi &lt;&lt; &quot; &quot;;// &lt;&lt; nows &lt;&lt; endl; /////// ress.push_back(resi); // 此处需注意 resi 和 nows 是否改变 nows ^= 1&lt;&lt;resi; resi = last[resi][nows|(1&lt;&lt;resi)]; } reverse(ress.begin(), ress.end()); 最后是拼起来,这个也容易 仔细观察两个字符串拼起来的就是 A[i]+A[j].substr(e[i][j]) 代码class Solution { public: static const int Maxn = 13; int e[Maxn][Maxn], dp[Maxn][1&lt;&lt;Maxn], last[Maxn][1&lt;&lt;Maxn]; string shortestSuperstring(vector&lt;string&gt;&amp; A) { for(int i = 0; i &lt; A.size(); ++i) { for(int j = 0; j &lt; A.size(); ++j) { if(i == j) continue; int flag = 0; for(int si = 0; si &lt; A[i].length(); ++si) { int p = si, q = 0; while(p &lt; A[i].length() &amp;&amp; q &lt; A[j].length() &amp;&amp; A[i][p] == A[j][q]) p++, q++; if(p == A[i].length()) { flag = A[i].length()-si; break; } } e[i][j] = flag; } } /*/debug for(int i = 0; i &lt; A.size(); ++i) { for(int j = 0; j &lt; A.size(); ++j) cout &lt;&lt; e[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; } //debug */ memset(dp, 0x3f, sizeof dp); memset(last, -1, sizeof last); for(int i = 0; i &lt; A.size(); ++i) dp[i][0] = 0, dp[i][1&lt;&lt;i] = A[i].length(); for(int i = 1; i &lt; (1&lt;&lt;A.size()); ++i) for(int now = 0; now &lt; A.size(); ++now) if(i&amp;(1&lt;&lt;now)) for(int pre = 0; pre &lt; A.size(); ++pre) if((i&amp;(1&lt;&lt;pre)) &amp;&amp; now != pre) { int tmp = dp[pre][i^(1&lt;&lt;now)]+A[now].length()-e[pre][now]; if(dp[now][i] &gt; tmp) { dp[now][i] = tmp; last[now][i] = pre; } } int resi = 0, nows = (1&lt;&lt;A.size())-1; vector&lt;int&gt; ress; string res; for(int i = 1; i &lt; A.size(); ++i) if(dp[i][nows] &lt; dp[resi][nows]) resi = i; cout &lt;&lt; dp[resi][nows] &lt;&lt; endl; ////// while(resi != -1) { cout &lt;&lt; resi &lt;&lt; &quot; &quot;;// &lt;&lt; nows &lt;&lt; endl; /////// ress.push_back(resi); nows ^= 1&lt;&lt;resi; resi = last[resi][nows|(1&lt;&lt;resi)]; } reverse(ress.begin(), ress.end()); res = A[ress[0]]; for(int i = 1; i &lt; ress.size(); ++i) res += A[ress[i]].substr(e[ress[i-1]][ress[i]]); return res; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"},{"name":"状压DP","slug":"状压DP","permalink":"http://kaizynx.github.io/tags/状压DP/"},{"name":"字符串","slug":"字符串","permalink":"http://kaizynx.github.io/tags/字符串/"}],"keywords":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}]},{"title":"父子","slug":"Luogu-P4981","date":"2018-11-16T06:10:00.000Z","updated":"2022-04-10T07:52:45.141Z","comments":true,"path":"2018/11/16/Luogu-P4981/","link":"","permalink":"http://kaizynx.github.io/2018/11/16/Luogu-P4981/","excerpt":"找规律,反正我不会数学推导","text":"找规律,反正我不会数学推导 Luogu P4981 父子题解地址 emmmm其实我只是找到了规律,并没有推出来 记录一下,这是道好题,嗯…","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"快速幂","slug":"快速幂","permalink":"http://kaizynx.github.io/tags/快速幂/"},{"name":"找规律","slug":"找规律","permalink":"http://kaizynx.github.io/tags/找规律/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"大循环","slug":"Luogu-T2066","date":"2018-11-16T06:00:00.000Z","updated":"2022-04-10T07:52:45.141Z","comments":true,"path":"2018/11/16/Luogu-T2066/","link":"","permalink":"http://kaizynx.github.io/2018/11/16/Luogu-T2066/","excerpt":"非常有趣的数学找规律题目","text":"非常有趣的数学找规律题目 Luogu T2066 大循环这题花了我好久啊 首先一眼看出有蹊跷 两眼看不出什么奇技淫巧 乖乖敲暴力 暴力源码↓ ans = f((int)(q%MOD))*work(1, n+1)%MOD; inline long long f(int x) { long long res = 0; for(int i = m; i &gt;= 0; --i) res = (res*x+a[i])%MOD; return res; } int work(int cur, int last) { if(b[cur][last]) return b[cur][last]; if(cur == k) return last-1; for(int i = 1; i &lt; last; ++i) (b[cur][last]+=work(cur+1, i))%=MOD; return b[cur][last]; } 10分…没事我只是先试试手 接着考虑记忆化 ans = f((int)(q%MOD))*b[2][n]%MOD; void work() { for(int i = 2; i &lt;= n-k+2; ++i) b[k][i] = (b[k][i-1]+i-1)%MOD; for(int i = k-1; i &gt; 1; --i) for(int j = k-i+2; j &lt;= n-i+2; ++j) // b[i] = j b[i][j] = (b[i][j-1]+b[i+1][j-1])%MOD; } 现在有40分了,剩下的RE了,超出空间限制 于是我摸索了一下转移方程 发现用二维就可以了,滚动数组!!! 继而发现其实一维的也可以啊 b[i][j] = b[i][j-1]+b[i+1][j-1] 假如一维的话, b[i][j] 就相当于 b[i][j-1] ans = f((int)(q%MOD))*b[n-k+1]%MOD; void work() { for(int i = 1; i &lt;= n; ++i) b[i] = i; for(int i = 2; i &lt;= k; ++i) for(int j = 1; j &lt;= n-i+1; ++j) (b[j] += b[j-1]) %= MOD; } 嗯,还是40分,不过这次从RE变成TLE了 其实聪明的小朋友应该看出状态转移的玄奇了(而蒟蒻我是打了份work()的表才打出来的) 你看b数组,某个位置等于左边加上左上角,翻一下就是,挤一挤,就是杨慧三角 也就是排列组合 #include &lt;bits/stdc++.h&gt; using namespace std; const int Maxn = 5e5+7; const int MOD = 1e9+7; int n, m, k; long long q, ans; int a[Maxn]; int mul[Maxn]; inline long long f(int x) { long long res = 0; for(int i = m; i &gt;= 0; --i) res = (res*x+a[i])%MOD; return res; } inline void init() { mul[1] = 1; for(int i = 2; i &lt;= n; ++i) mul[i] = (int)((1ll*mul[i-1]*i)%MOD); } void exgcd(int a, int b, int &amp;x, int &amp;y) { if(!b) { x = 1; y = 0; return; } exgcd(b, a%b, y, x); y -= a/b*x; } inline int mul_inverse(int b) { int x, y; exgcd(b, MOD, x, y); return (x%MOD+MOD)%MOD; } inline long long C(int p, int q) // C_p^q { if(p &lt; q) return 0; int inv1 = mul_inverse(mul[q]), inv2 = mul_inverse(mul[p-q]); return 1ll*mul[p]*inv1%MOD*inv2%MOD; } int main() { scanf(&quot;%d%d%d%lld&quot;, &amp;n, &amp;m, &amp;k, &amp;q); for(int i = 0; i &lt;= m; ++i) scanf(&quot;%d&quot;, a+i); init(); ans = f((int)(q%MOD))*C(n, k)%MOD; printf(&quot;%lld\\n&quot;, ans); return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://kaizynx.github.io/tags/乘法逆元/"},{"name":"找规律","slug":"找规律","permalink":"http://kaizynx.github.io/tags/找规律/"},{"name":"杨辉三角","slug":"杨辉三角","permalink":"http://kaizynx.github.io/tags/杨辉三角/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"生日礼物","slug":"Luogu-T2069","date":"2018-11-16T05:30:00.000Z","updated":"2022-04-10T07:52:45.142Z","comments":true,"path":"2018/11/16/Luogu-T2069/","link":"","permalink":"http://kaizynx.github.io/2018/11/16/Luogu-T2069/","excerpt":"我觉得还算简单的一道数学题吧","text":"我觉得还算简单的一道数学题吧 Luogu T2069 生日礼物题面$lcm(a, b) == n$ ,求$a, b$的对数 输入 n, 输出方案数 数据范围n &lt;= 10^16 思路考虑两个数的lcm 分解质因数的话 $a = p_1^{qa_1} \\times p_2^{qa_2} \\times … \\times p_m^{qa_m}$ $b = p_1^{qb_1} \\times p_2^{qb_2} \\times … \\times p_m^{qb_m}$ 假设 $c = lcm(a,b)$ $c = p_1^{qc_1} \\times p_2^{qc_2} \\times … \\times p_m^{qc_m}$ 那么有 $qc_i = max(qa_i, qb_i), i \\in [1, m]$ 那么就可以开始排列了 对于每一个可以分解出来的质数 $p_i$ $a,b$ 至少有一个的质数是 $qc_i$ 也就是 $qa_i == qc_i || qb_i == qc_i$ 假如两个都是 $qc_i$ 就只有一种情况 假如只有一个是 $qc_i$ ,那么另一个可以是 $[0, qc_i-1]$ 因为 $p_i^0 = 1$ ,就相当于这个数分解不出这样一个质数 结果大概是对于 $lcm(a,b)分解质因数$ 然后答案是 $\\prod\\limits_{i=1}^{m}qc_i*2+1$ 引申到大范围来说,如果某个质数$p$并不在分解出的范围内 那么对结果的影响也就是乘上一个 1, 所以也是正确的 核心思路如上 本题还有一些要注意的地方 质因数分解理想复杂度是 $O(\\sqrt{n})$ 事实上并非如此 如果 n 一开始就是一个大素数,就T了 因此应对的策略其实也很简单 一开始特判一下 还有就是如果 n 是几个大素数的乘积 那也比较麻烦,所以每分解一个质数再判断一下 ps: 即使用非常朴素的判断方法也快得一批 代码#include &lt;bits/stdc++.h&gt; using namespace std; long long n, ans = 1; inline bool is_prime(long long x) { if(x == 1) return false; for(long long i = 2; i*i &lt;= x; ++i) if(x%i == 0) return false; return true; } int main() { cin &gt;&gt; n; if(is_prime(n)) return puts(&quot;3&quot;)&amp;0; for(long long i = 2; i &lt;= n; ++i) { if(n%i == 0) { int cnt = 0; while(n%i == 0) { n /= i; cnt++; } ans *= cnt*2+1; if(is_prime(n)) { ans *= 3; break; } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"质因数分解","slug":"质因数分解","permalink":"http://kaizynx.github.io/tags/质因数分解/"},{"name":"素数","slug":"素数","permalink":"http://kaizynx.github.io/tags/素数/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"NOIP2018","slug":"NOIP2018","date":"2018-11-14T05:00:00.000Z","updated":"2022-04-10T07:52:45.148Z","comments":true,"path":"2018/11/14/NOIP2018/","link":"","permalink":"http://kaizynx.github.io/2018/11/14/NOIP2018/","excerpt":"瞎逼逼","text":"94f00afea32c0266ade37fdb656f69445c1dcc7e17f2a672d6207aa87ff92173f6726c63bc53cd4458582b3f5eb946c90d63d073c6c30da6362dc639f640e96ee7f8dfbbeea9dd996a4273402526d19389d8846b871bf1ae75e026e066f5424e1ce5fe0a58f0184b3a212255d7385508a87d033d1eb34f2fcb35ae5589d24f3f9ab58b5a6eebf4c368ceb2fb1a10f598e22dd036269fc02bc5af09821d8fae5c250705d1125d1731524df12fd92211ed67997afb854ee5562bbd9f52a6809d1e5ea9c58dd11754a9ace46cdf13c8186d2e97a5fb7bab3f616b06b71fa20b8b09a27a2773a4dcd7ca2fb550c5e34fa407179253d4f2e6ead65cb5d9e637f6b9f33abc4f3205437b9c35145633c288b6902f8164720a7b63d3d59af41cae17f8161ad220cf77e338e85a52923904e5b5af3142965f1a60266ec54daeb970db8bff223e71f36ac2de252591fd24d50e4e4e1eb25ce20f3f3786e04492a04f070ed3bdc3fd0f731db4ac3cb271d986cde15b99c7817e134e625418bfe3f5cd85503c69eab3654531329f80ae0abe1303f11063df72b0af5176b467cc25e29a72a9f2f0b12ba9c24e948c2ee8d9f92a79b36f92bee1ca01541f0ce3ce5f31e87b290f5c6184c667d81e0a6644ff6036e4d9073fc03970e12f27a60c313ee3d8435d9cdd979f62b2ff8b2bc337827c3ccc691d15aeb6a3920e998a2d0d2b6c92e0e00bbc385412d28076ccb8b5fad958c4903ffa6cc35e8b093464ce85db9c90f4c00b2b6051a876507b14344627e1308187903f93b26bcf896cbd2951ab554b67550b82cc933b01494f04a933675c8b0d215250ceb7b9759dac57544bc3fe73a2b1d7e99e1dc46bdd50cc87506516b4b89f4d0ae25dd5139b1bfcb23008405ad8a0322c5d2a00483733aa9bc54e718763da2c85c414aa00f1e1de192f24268db7fe09316b08bb98f2e8cf81968c7d597a636ee003f2f396e478cdd229b3988d6c33d45e9d9b75a14c5f8a7163f7e23e307052f43f2d36210aec09fe1999c0d28407aedbdbc030961365e0950f866e24e2d1942b3588e9e4eee3924a7eb3c3ad9ba9b63b1c3579f4947407f320cb4bb2a233d4d11a7a9893ec91e4fdbdb88b77cea68215edb852a251cea0ff7c0235247daec019c8b34fe5d2c806b3d367e2de5acf9db664e1a5519ae46802c9bd7e062909155b3b9334578a89338b04669345382797948ab4fee455dc226090039d753bcb0ca2585f53e4763c5163de6139005257b8c867043123802b1ea0e7151dd1275666150d2ff9a699fc58398d2dcd1a23791bd304f483975531c1befa639b85a6fbd6597bdd485860de4664b585764906f89ab673f6cfe5310854e6b3ac7a3dc5689e15d2ee113308eafd3534b64ec3ebbf11e9e03cc331e088d853277ba859866c1e99b56898bb3ef4d91d6de52eb6a7161f96b2afc1c107ea3112a3095c64f37168c6e5a04b5d7c8e83fc88b8194c335ece636c67bda01d165d138bb5cccd54e51b0e2ee3cd9723c0184ccd082041e3c02a2d3a75b86a2a14eb2244ffadb684268f735d7e1a502fcdc424e9284c769c4d05e5fc51dfc7699ea7354d6e59dec5b2603efa0691a79702321b27f3c43dc5fef79c904b34a982335edd81acbc31eb068dd4f10b60228f82e42e75c7c25a85432ffe3bf12b23d920e679b172696c9a22feae1968fdd3fbf1917e66b57ee710668aa825d965472e6c497afd3444cebf0de5efaa5d921cf0d164551ef205877f6a49f2bff6fd68f53040375361bb0fbc51645b6873caad5412892951495c9ffdb8a2bc98292a95d74969e6f7813d224600d6c2031e4aced537b9c02b07d98f4769995898ac2435a74d6527556ec06b076e431a528ff66e411b25366e4ff364ef54c2bbac1adb37c96cf2bc6a4d843f9f9537dbdf9f92c9deab5e9e6297d393f61de5addce7b3674ae09597e7d81bd7158891901e8780c815af8819c28b5772c0a89fe315438185d4c9ebd2a47850ac1ee51e3cc21b9209e7ae8a38ce3a42fe9804e3348387f9aa486581e257f390efd1d0c37d9504ef184a678ca5ae8c4a29c762c1802f4ee9ab7f36e18683d408d88b8ed7e303ef6c23c7f7f58650e7d5aa539c1f554f18ca8bab0b5463101fae35c0646101b9c9370eebe234008ee73ef47917c64d18acfb8464f3cde464cf71d606a302a8bfcfa55b01aebc80d1a4aa83ae93bd1ca6b2fa645ec065473580d75e25953cc937aa3a4748d9df00ab52d53ba48a1d3c58bf766207f4059a780c2501be7e4d46264bde13bb3c7f53211e3e5352705108bcbc93177ec96f4f86d4379769652ff3dcff56d7a3ec2fd097c9577d6fe547d75e3f825820a4a2157ecfd4651a072dad875ceba2571cfa60abbcd58c56d70280ca170b23834dfe4f28ca3f35b244565b388f26584714f7b48cf56e740612ecffdcba900be2bd57949b10dd5654474882925cdf4dfe8b0235d030407a39bd6417b5b32f98b55524f362252c462f0a525a0633cf9568bb453bb1fa25f515b5b922519d4b31c5dc71af92168ad0c0bb4a452b39c6cb98c5defd905a9ecb9a798365dadc0aee64f2b3dbb735d03ebde77efda26e56669e7e233758b8da6b6d80cf57b345c818908c100bca9cc4602e40a0e25dd79f46052a621e1dc98edbc646886623f7508874fa8c77a73def344cd41fb9695f21629c027b7f36aaf04f82179406739606ae09fc2135bdf0fd0f734fa79e250fe83d5bda28c2851af3bf7abaa3615951958b0235cf06aadf13d8deb8ae97c84b2cb433b8a8cfdae9f45a446abfad31e24fcb1dc58e6c7fd6c64ea6fb958f2e6a422c9ff85cbced70dc643f1e69a64cd547e3d148abc33ad53111e14eb4e85bdacc81600ece63188a727ad5520c9aae5c911b5f04d61ce4c21f71efb8b1508ccf393bdef7699f59f5ef0a30fdfd2c0c8755b012ab2173899af2c2f3f7a3562b082f54f8a48d048f771723e57c785d6c14098021edd61deae4f17bc6010ada31e30d3832317e7ed0ab693a507e3648f7b4bfca70fc99b918e9a9743f310301e413a093522f9a0b51687243a82aa06719bd9909baf76bb04362acaeda9704ac122c90855503a3c0fca0b908c9bd76f4fb17fe9353e4a2f77293c946651168faaace0e16bf1a34772e039d4b2b52587a2181eac7b4fe832676c837a5708f1d5cac7c98b6d3d0a3bbeb811a28470c475814586fe2de25d9bded557e473a9e036eec694ae0969b4dba284bae0e339d23672746ee88878c930a63dc6afcdd6ba3f397c7c47795f6b60fb94565528860abff4213db48a8d74d67e0a0e18865a7e68707c5b50f93e8ac9ad62780bab7693be18d133d34794d867e49531e38c0738422ddb9e611efec4a3a89cf887c4f1ca0c7f255550d15c8ec13e9d61884bd6ebc1fb09f95e7f9e58735e43a03fddab56c7dd292926002f0177019ff148269739f27c59c80fa4ba90f58b05cf6cf4a916e631d346ba5fc494261faa88d347280cc411ae18f1c8dd7691449920ee0129c239d2927dbe2eef0de89c6c523e5de4d395c358abce09a9b6c4145ddef85577a9af6ee55a61256268451e9c2f027b2c66601e890a0e0253a9ed231a38b28636d061eb69112b97b87501fc32c976205356458cac9b4d014d943809f4653ac1d2460bfaca1f39317e19729aef9f08c39977e9b34a5a9d6f97b5438eba4372e2bd733a595cdf6c252a4bd49a34f9a14f78032f4a1d8d65084e4ecd6c0aca375a287aa425b29f80a75e57b884311ee7153dbb25fc521a37eb8720297f123aed9bdf9d58a8566cdaee49751c9c17fb109376ec04b3b54bbb3442604ae318ea477685cf21319a19f8ff254245f0fd3941ac50c48b7ef380074bb78642fdb30dcd08bbee10925c3146b5b0142f9caf23cf0babff3fac3e345005882215ebc0a3138167beef1e55bb612154723e53e99a4f8b0379db33a5eaf0b4a85149f1a22683a0b7347f0a6dff0d86734d860c7e744c344b28066892eb40324b3e1831a83fe9d978b76c98c73f1b61fd69e9bbf541f6916d23a7b759dcf4dbf750c582a16f90700d35f2520b7bbf38bb3053d81b990f20941252b1df148272e7be6dbfae0a54f0e97560ef9caa64e919f056c718de9eacb59a9d18ec583bb25f256dc57cc3d383728d33dd3ca331a57546237baaf1e667858799d660c82a00cb00590f1fc4d24dee62e521c90573fdb7b5405a8d01a6e3f8687453c8ee3943b80d68f838377b44760b5d6013cffc040495e75f4914249eb4b51a300e9c0d3e3a4f59fb00a3002750b2c660e1d1ebccf7957cc62d3d1725bc19cffd550654ea5e43c5d13cf53d2ba68fcf3953d433f2928da820116252ac6141f5205111ad4a201754ed2220724d60d19b9610ca7a31db1f17d95741bdad607abcd6d3f92daaad51f18c6dafd535de2db6bb53c753c72250cfbd1890ffb844c9dba69a77bd1564e0e7ab38ce9262cbb56d27155ba9426e03560b6d57a4c874daab7342c82ceaa3e9b14cbeddca20846c462a08b4842ba49b8a8c3aaac432557fb2870f2376a0281bc7f347c40be98c1759e46c1b4f64a0bbc1f22b9746dedb9fb5f8a7255f8342cb1f18a6e0bac0064b217565c26f545b94c5c17121ebd21749f348286f1bee9253511c83f4defefe5a1c9c253895dab406143d086892ff79e9bc606f187a4bc0005975f290b4e829f84f7c1fa37d6727a09215430c5108b0e87f637f2791aebd29077dda78fd46c12ac03cad3bc2b1624df0b0e437c29a9e160f19290f7a315c6a959ac17a534a1f21108e4e90934c5ef68439821128e2ccbcc0b5de8a71b73c3766417bca9aeb18de935a3c40d2f4e51828e5e799d56b74599e11169f90bf53e05c815d13b856e5602728f8dfd6bdeb40e6a4bae7aec41972a7b9efb1eabb28991042fea62f48e0ed79c04d5ac87a8f9e8d1e041ac4b6c4a0bf30a8f4d72253a60190ff9e9bc0c10ce30bbdf6c7cf740cccd9c9c7c05356c9f4db9430070825e6da318f7dc1a0363883dca54a5de10060a83bee6f61104fa7fff6693eeb662f6f1beab425c6421ef6040112dc031bab9419181091ebef6f4c514af7ede80075c36575b42c778730ccce977f1bf0006f8a10557b870c29dcd3f255e817475249f402f2ad67d1c13633d2c6385a916b68c790c88286411647380fd555f67a6445ddc73416bea64a89c30614fe8010a661221d86a99c83145cd61d14b44e86482ae05fae946f053562f3c150526eecfb6227ba3550e0ceb01c95784212f370988d825faa9da0a2325fea59e1895413594da385cbb71c7e8da61525b490e7c9a9901a2f1d766104838fa700d7cbef30549a8b2d17b171b497bd9d9ee2002490e4b44d614a089ba73641f2b0fca0a9f0ac496f3130337e0d28904d14a37accba369194c5856ade1963b39b0caa965fe2df5f22d80a8dcd1403b191b0dafaba6f65b898eea613e3da5f00f2aaa999c923fbbdbf47ab64fb30bb19904e895f7133e8da3bd5a71a7e9320c312215390b02d6d47d9f87f240e6b31eccd9e1df56ee3bddcfc3efd02b8ba3adcd63a3280c966c4332ee516daaa8a946bff4db10d5da403a33c8c3f4d2d9226d45ff486a3c9f122c123b723db355e29863f0c02a26e4637dea09391ea477f7d13a3a0714557ff1a13663d59adaa5d09f792f23fa413fc14a6db4d2e57d46c995747f295a8d3da30aed0caf9adbc64d86f67772f2f84b869ee7ccd792ca675d72e20faff3462be9c95198a2ba7de3fee6aba70a5e2cfc24540e0b2bf4d8b2915edd1bb0bf46af11f89191fb37cba0c5fc81efbbf14435e18abd002080b383fa86d9bf4b6f086c00394ec0fbe530186254b3b37b1cbb424f1444d9ff3bd367b952896b47fde1f37ab80a173278c17ef6e8d06f3f4f566af6c4976649a3b9d78cacadaa90b8e8dcfe247368d2236a7ef633ee674f0c15bdcda5fd4dbf1e6182d23392635c296dadea70229f85905de487eea594c93c4ec2c900f36df7706244218da8ff41e96975fc30b22fedffb32c6de0c2007033445e213d119c11cc7d5f8fc8b7640834f7a17b60ba4b55243ca156b7cd0c51f731e97b16e347aa93d0dc48d4de373dad9de472dfc4ca6a62197d98842accbd7b47692d9febb79b0d58e96d3b3baeb6a58564db368d9fa92f14c63c44bffb575aafd07e61e77a8779482b629244a10f12d54e801b971e7248903c7eefdc05ee57c4e973d64baedcd764c3b195f98acfce6cdc641a358c16b80dbe80b3a10e9cbea843e64298989770496f1c1783434da8bc868ac7fe85802674eb8e359e4086f42c5015eb6e254ecdb01ba9e957844088e129971612cd3ba4a6f396f0c567e2379be216a8777cf05eb8d45be871417d13fee7fb05c841e90971130a4ba6ba36cc5517179d9199493446b89f1f3961eea9f5774053f79d27843a8e086003776a1ff8c24be6739b393f77b6c92c494aa4860a306e80418190296d1d021409e80686067bc04afaa9c833bf135cefa3a79ad7340738664d81f24a1a0ad1a5e11647cf95738cedd64d833bc7758a70cc3c6d4aff37ea3e0e85d7f9a4d295ca4cea787b3f03ca3417b54ad4805af449731d8fec2da580987a35a3ab9af4b64fbae8ae9db90a4acfbe7f6892b9f03f87870686e32c4ecbdcb6f505c863e4a0d60de223db7ab286e9bc39850a67659488e171d3b151417baeb35581d0c1b9b9827e3a1c08ccfa28a6dd8d90e200f03375f86f74f6860d414c8edd388552cf52e2757262cb73436a29351d612240b9cebf2e0f52b3c26d3cfc9c5bf84264735d3ed23b8df0420ea0216305f6baa2124f5a8378d5eda0e817947bf351766ebd859f3b1a813a530f0bacae7f3085083c529cc42c79651255615d491d1373e99a2e0fe5edd68a7e0348f1c27b5b935d726de32c5c7260584b2a16dae956dd86723164a510b26be753eb13578f294f35e0088ea0667659e72dd391b61d51224a385ae7befe2733d57a610f7450a4b040599d8c6b05501671a5e7e51c607af48a9a2a05cdd5705c8a39b8bd72c8a1a1b1c3119b2b9e67c649e2f0570879df5816088ee854ecc4b3e2a07a0db5edc633df89391712aa32d6630daf9a3126ffe3319e2120b88b2757eed4874b77380c0c3ec5a0e2d27c36c9879858045b94d26b1e5653b32501d7e5472331ed44b38cfdb0b44b1570683e1de6f4f4852456f939d4f06a44b15d7f15b81a497b1e94973191a3fc18a6dd9a2946339efdb19fe54d96946b665fa7a35fec76fbcfd85c903a5535485602f0b0bae3103519b7d6c3a453b853b30606e47e64f32810964b7e0bea3abddceb789fa222706a96e4ae9ff507d51a3a08aeb2a84442a7bd37c20492724109cfc58a43db73806d959a03dc7f7071821e9c628316f492e6366356ea8342b1c062cafb815fc4838fc0448ac0905c397c70b83c3da4ee7565b0ca38cd490cf9a098781399cab3f1a9ea9500bcd2f71fd45485c64c9912cfec2c583d4eb0dac37c283a7b648c5b25d927bcdb5a3357563cb9b1635362e541d41e61081d92472173acace5442e2493ed82be179343e1c21be89c19a1d21ad96603454994a296c8eca5a0289bb13f158690782bf65c0118653b1f54eb96266c7cd3c7fc57c1d0a24320e3ea65f750fb78c86f4fbb728a3bc477e0d432980401ea5d07c1681571703cf8473c24f9cd67de19883202ae18d43ecd840047b72e7b3ffe3938068d7af25dfef0d93016b83f2bfede600b7f9da15ea9cb224f4f8ec899f008dc8576fee4fa0e06c51fadf6a05435372638615e274d9981b08eb38bd27b227b1243821ba8040356143bf4d15ce22d4de690521c690e0b356811737a5f80b051b1442f9f7613974c414ad1c118ed4fc4a5302da9e39551f6cff3511d946e3c2756421cd3959614117594211db828f0594f313b7cadd6dd22e4d6a1a55132fab275e385f3e616f929dc515c723b86fb860460a38e9098ce60871a4812b451bbae3c99736d2c347504190af876aa413bcc6fb3b30e2f49a7124abfb137f1de51a6a8386153d49b8416263ab05b24a5496e855d4022ae15bad77b6df107f2df54f97d7c0c3e862b85c9cda7053f424bf1b93e8bcfb345c0fa1a10024920a96fc1aca60da72df2e96d9f3846135bb2b092abee94b625b23fcd6380dbe57dbbbd901565b862b928bb93a659a01e32fe0445812fdc4f3b61b0ba631c511a818338794054ae3cc427e0bd66b0df95b4436ee2dcc122bb08ad922b18b86a33663209c22fb19d76f213197da0d0e51b228edededdf7018d1ec49a5ec2ecf524d4f3ad236fae154c47d58c8039ca4e7bd44955b214cc2c59b8caa33fc7b0c91e485d58ac3185c2a6b26be66920175790d9a4debd983a9014bf9f196db998216531d6fc7abab8f7015348afe592a706a7ba1c1d55e96cab77baacc2b53d046f0a39c2877fec43bf2cc4c7d7c5d2d59b973ec17c607560b71d899732733d6803286726c731c5d647015f55f4163fba6b29113739af26e99543a128fbc3a80b4e440b111ab71b6453097f85495839e47b1a7a0739fdc309e5933728198cb3905410eaa35e6b1112f9fff14c9f83eb6a9bdd18133e0f0e760d1bbd88e6376b82dedf012eabdd41bd248c3c0fc4e8c26bfdf113fd409ffd56b901def0244bc1b61a853cffd5051b8800f75bbccc5ce87331e43bbab82125f7b6ed87a4a31235d9ad8fd2e73c7d46bf0fe2cd9eaaa8d3078ddc06448c10d3308f1ff0c900b41b9463af99af6c66ec75d8ef0aac4abd4574011d9bc09ca8aa4da40f8e36825ac58a31ff141737a205faf65166ddbd8e62c02909309abc7ce0aaa64f8a417e4515cf5b04100e81d4c4a26798878916aedbff6a3f9ef5897702e8115b73540dbc086338bd5ea387578b5f8250a78b2904c5a8d9693d3102b911df485be6eab270255d7821fb4ad8490c7062faad1141fbd580459d21760372780c5e86c1af0e24dbe59904ffd6f482b39c5278c3e6af409256dd4d3006e6bfcef697a3ec168629370427d6b1f4b83b1ab1051daf751fbbef61f63dfac44b2748c0084b58cac47d97ce0c8fdd65e0e286df81dc936f7ee7419f95facede4b9c7cc75b813944a06bc47a7a02a16360372e576f6eee9967bff103d8394c793a5984fa4c09bc4c7230d5f44ab54008a40986e945638cb9bc80686830f1bc1b54297552db033f2e93a408361d3ac9a2f42ef568b3a9d312a3aee293db6f75b683f09f74b97fa230c9ed04dc6d910c4f4859e1eaa26f848f28f533ac5c9702a013886fe1660523239b04b69839681d8bf553d94691f6d075fe62ab76d99822c243d952194fb1794fb85c32626f4b884a7b44518df92d4d2a420084b9518398f3d2d328924b903e1ba40f6900a40b7c7d7b893054e3a07f193291bfebedad9b9ab910113dd08e0e6564b14868964afc2a04258fe2b0bb6918afa402cc662efefe83afa76ab2f748427fcc7d741baae5eb6ad64180ddf966eac7dbefed6643b8ea537fc1558926d1ec72ea224c8978e5a7dea2ee36f67940826e01a5066288cfdb9be91c28b3eb8e8846232ecc28be4ead431b180573d6b681a6adcb6c231c5f75b347cffce31563942fc50017d013508f88fe36c21331e1e8a8133a4b9975c652581289e89d523d535f2e320031f6eafb1a6077b886c0a7e166d1ed0c1d0348372e6af82dca79153e0b81462748ed6e5b7c717f04205557ac0b79d67213924afa84aad8279a29e48627fe8e91cb75190c935e46523a788a9cc2634c3bc36a5d3cc6ebc675f29077c721285504d5888d47967140fdb817183340a2d153019dd77f072f64f0990ca2686c96f41144e9ee5717376508ff01a4207acaeb075cf2e3cb072b97de54bdff440340e8dc341c9c31503bde9006e63d100950c3bac1270d94cec1605e08570802126b8387771a2a5238e6cb8e0668f657890c636f51318e1597c6deeb336173b86c82b7c6be5170088bf9f4b1bf9457bf13ea2a7afb7b4399a2dfd3e8d5a2daeba9f08e3cfd225b0fc6cf4ea076d8318b753c38f8c1e8d488e76ccf31dbaf196621dd214edc4ea48ee5444485df5b07ddec9b7921f984df02223f45ca6d2a88ab9c2fb808f7cb6474fe28b3156658e0f51f1b5a76907400fe8da8ace33474ffc2ffbc51b9c6e804203347d6fcbf307fe7497636fd988bddd5765080f1490cdfff7453ff7434f40f03d5389c275bd86aa8195f04322b8d9e1a2ff9d0772f3795cf4dab2777d41c78b07f18346ebca18d10be08f16d2e3346ad9b34481bcfa78024517a47388eed5e9f3201475ac338002b6cace44ff08aa25feb47baca5690fa1bab4a6cc0d6089459abe219de13c485ae652ccb9306a27bc9f2aeeec97e3b8f53abdaeb873bf6b9fd03414cab93374d1d056fde7551f3e27334a031c62d9fc114c3b42ae55f9dbe88ea0fcf4d2852fe737947fe606da994ab7629bb03ed22a69cdfe96a7867e9a254cd3c122cbca073253434490a6d13780e61ec569e48f934572a9bc004f406d03fc89463d7ab5fdec927d303493bb0b7c4bbfd4477257ab08fcc21f5c7efb248395a936f7223a2f36fa234b805ce34d0764e37e964274147962af7be2e4493e0da75982e23b65f754fc1a305c50f2bf1ac59a0f5bb377f91971792625e07b3c5afd2d8124d0869618ec6b0f56ccbdf96bcac58b35778c0a2483220f9a5c872e62ebac2b8be165e420b109f3f2a3d2934013d3303793caebea79da92dcbc73483dcf22fd1e576ecf2fc94a9019e75f3e0a6288db6c80d52ef3c133b27b1df7d57b637602d32a54463055390ca4072c3893699c5a9cc4c54d4081d0bf4bbf05f85caf6dec77da758b2141f0703c04a0ab6bcc725f52b71858532b50427184ee732f6589cb24352eb2f32d9bb35d56eed549a92994679c8e7755bfee53ac5315d043eca3c065be1db0bcee863e9b6ddd3496a404605ff48ffe92b36a8b88c216647c1ffad24bb84e3b0975f1c1c5c097e29cfec65f5631730fee99c96acbc7d59947db583380f649778122d4e4195c01a6ca16b5656645abba499099693540505db26f56d3c054ad8abd46f3674fa715c3aa4b1d8acba27b044a602b166c88362f91ba7ce5fc00123080f6b15c11ebc7210e7e74f918e6738ff31f92f005a5ff752e05f72a09975838539254d5469b3d35c9c4f42163509d5a42f4f33cf352428a2a35ea6dd52501876b630a3e06fd9cf4eb869316c25261337c073602a3db6d60695e06777cd2774e388dcfdab0a7a6ed46057d83260882f05893042af7efaf5698dfa19f3130d9fcd7d2cdb15ea19643857a6f4353d61129ddad64f1a0770fdc984184a54debc6564fe70359d32070d8c9786bcd16497cfde6b7a73aede89e519f9466a019e5f1db055392f8decade218679ab264b4e3c0dce9a42454b2b0322e9ca7c0a72070536fea43d1b47269eea051fbf1e4729f49659fb0379f2680faf01f9e9fe82b6333f273edbcf8d9aa5c821d6a7e3f2dc3b97b377d35db8bfb821e5d6be1b08c55343559b9335022d3bee85b920cc9e63ddd97e13aa13647ea5822a0464a0f2b6839937e86447a81b261c12b9bc66656abb850aa8331668d5d0baebf3e1fc78e0d8a1c721a09853043976c0c59ffdc69c8454d2d05e01e6320b23e9cf319b6c1f08e0fab0d5725ac4be1085c744f7be378bce0fd8e7e23135ba4b9f550110819121e8c751c26d406b871c45c08afd59a12e890197352b1bdf723e3cefbb4a39dd78540b7092effa42bce31e423044d9135914a1ca8fde738007a334fa9e7ead9bbbd7ed89d3976a5b98ac74210428697b603efdba3cfc981681de60cf69fb1f12a458ab1ca1634bb444fee3c4ea8ccf88504453d03c0c2b4faf2e61b7af1b30880ad09dfa9ca6f8afa0ff5c70ea09a1b90c7d3b32b680ea27b73e3e6e611824d0c6f72af448b8829ecde4b36bb88fa2eb16e532e9adb2cf2eaf7bc2ab7eef75b1beb35bcb7c0ad679e07b170f09ba7082d92f8d34b403b4081b0f09fafd236e187e30d36fa347d51433463287e19b47c5b78c4cbe545d8f4535ef76ecdc14ac4c1b0baa5a3a88d1b0f21f3c89a23e0ee5dd474a5d6f91d0efbe7efd789bc32f68c8e890364a97b6715ee03f5821bc134d04177f83f66647d356e78f0e5a8cd127aee7c9de8147e0db6bc98a62fc3f2036873642e0995277fb421060a3da8b124db66ab6fca734c9764c0521643928d2499d80d7e1378c32e04ec63b90ea05d6dd802865bd1d68c1e035d8046a13cbb7f2b67ffca59bfd545d03d27020b2d2c1690b7ed97304bee986f634cfce6d9003efce3a1876ed34490e184c9c6adf41664a1506c99fc35d4ec142d10762f93b19f20072ba7aaf698c975085c4e5696359686e36ac8ceca070a04ad0ce68a4987f1405c071ddbc25a0498a325c234fddd1a106902f00a82a4ea220ac7194718f4229e9f4cb836cd6d04293a8a44408b7f8fae289f311ac2af905ded98dade62b61453bb0febe226e721667109f2201bb2f05e1f11d17f80e4dffabb63c231d541ca1a187f162f382661132b51516ba7159f7ac607162ee2f2e8c2479b9242df14ccb65951cf9a400a582a685a3a3b27823495dbf6fa1c3bf70f3d4a50873f078bc69a81c78fcf8e56c31ec0f60bd039ae37151191b185f176b64655bc1c3336ad2a0162c6850d50a68e82100c3d6a9e35bdf6ba6a941231cf1283dbb1ef65058e1726ccfc90da3c5ac73cb7a109467b8f0a45696df57ed83b99eb433e1615efeb7a67dbcd50f965b5d1a46ed90b4a0dc177eba9126f3420c9199c31a12cb1b3a5d5db9616b7c0f5f88fa86c64aad64cc1d7bc9cb34f8b49bc96f9526cf4617ad89d3576df6a7a03e87ee8a36ad4ecc591e2696ed9208a1ec4a939bdd3585aacf3357d6bd0195e61ce776177f9c55ac50e418655fb574c3a8c23ce7c1a3ce1e452d10d0291ff0f62903a76ee5b8a31b9879f9168d0bac662dc4a43dd45343788ef0f34755207f7ec32bc24319e0da2f0acaaf28b2336dff1a8c3bb8b7449f13b5f2c31697ed5ce68bff86f1176f2b7248984760be8345578685385335d710654639fc9717882d705a9d7205c861cd1ff5619308863ffa83f3ea17cbcc876c3c25f25532178131feb2df1fa4d314cd603bb0fb8db5e9a843d2d1bd12a7f3a9125a9c08f4f11f8fcac9066726f24cd1b0599eed114f50d42b46492855d941571e170b654e849c8ebfea993d8ade9328c4dc1b4c4097a743aa13ba21397f607da0897994c0573a00fbd9c246537203de61928e668153c4d4b2c02630080fea4345efb7b6bc0f243fda12ccb0138353c171484f5345c07bf9a90e3b520c1c904d735d88789cf7c9754b450e95bebc992f083d1cf12a84dadcd6f1b69055ed1f875a2917e335baedfd30355690e9cd4f7fe7ae557e93bd90d84ffe35a22650fe37e33b7be676a52120b15ff7a43ab5f55379d12a01dbca9287013cc72158ad02f18c5d3a5b4cb9da66101e801dda9346109b983574a6e083f3e66d9ab220b02a682b372fb9f75bdc14ce2808ec6580abe9bd61211fd396c9e69fdb79d85084f54d400446c4f3e25c771bdeb5d8c1c8456c5650d7f0d6950f656668f489d3f411e90928c472707262b99bbff8497946eba70a3094dd5b292c745c27de8b768fe57a5ed22a0c0f94328bbfd1b88d03718b0f1b4d8c8f9dd643bcbd73092908c2ab65fba88434c4c31a967e4eac9a66b798e8215c99ffd48ba39d65d4d17dd60a91a47dc22c422c35c6032e9b789a3ab10c7da735cfa3da3113e9cd6f049de80d51a6619b2e9c4a96e27aff56f3f4896692654c4bb88369dcc3375acabc84a605d6d09a6dc7a212f39036bb557481fdeec22117063633d057adad3e89758fb558b8c5b23b78c99f48eea07c3e3eabfde262c544d98cd9282ba3381263623356e46af7bd5499eb9c9ac16961151d6bedb07e91473ba7fc36116e09292881fc562220a0bb40dc93894832a59025f2a671cee2790b2ae4a5acee292c2789eaa13a9a491cf353918d574eb506d0a5720655bf0eb027102aaa8382bc82b9e4c62cc2e43f8eefeeed3afcc552cf9d1808203f5c3180170d8e28d04f0cd1d4b89d725382225e9543dd2a4702622c1c64e960585f27374c3d59f4e4c43f226192344a2a59eaaaaa9c3045f4b0d74a0285df57d30fe9eba9da6b2655be09ddbb1e86f346b0297ee32bd1dfe9ce7b31b8e62911593a077f19b085a70744af4c2dd64ee4241c986b260c6685aa3bc6e70aeb940cd8cf84cebc0e4539003ede8812339778b70f81e4a0833d11f40e564cca58d2a5de2402086e5e85dfb7f54ac2dc0a53bd1b76a55e95ac9209891867e8bb130a6e56e1e28c129ee13722d479923cadacf89ca543f16458eed2e7e09223c2c2608f303a8757b58758556946d66d58fa6923c8398e49a998e9b90fcbcac554145846909dd941c1c797c294bb7d534aebe4b4625c91c78034ffbffb7062ce717f82d3daf3aec08b485b846e06f21383b03b31e623782b4410c7adf1c82bf5518e3219670dc17d732b00ca870a4ca0f0026c3e1fd387989c26c9c1c74b585f4669cce547c040f536515088228c5f96b25abd9ae9838e07640f34500b9f1721f1caa1fca657934381b26889b15cb8002552ce62fe7939079372dfd9a80d0e92818dc2f2829493dba256a58e14f82d723b0a39293ac610c19d856f78a147edf2650c0103e513c5bf0fd1968f1ecb71250303d8420ec66b98f6b9314dc205ee6151848a6abb667ad25b624510d3df6fcc4f6f096c4367dd84de4f687130369bfd0bf0727a92592774ee36eec47e727ede35f7d72cf8d2a7edba3d089c371036f32b106a2fc25c830a11fe0d3cde565ed2cd6c1d777ac8187dfc815a7bf6ed52989516e4c8d1422fe0d35a00df932bea8517a40791580d990909583484a52cfc52e350f17701ce4c5842eb7da306c2d6be431bdcb5b51aa914595b17d9771742b2fa22d007eca4a7efb0fcfc670e790bc2b33276369dcc5f963b17543dbddb81abc5458705ec6f7508250ed4ff1cc3ef4e79503cc4fc36f10bcafdebe17aae16d1464521d02ee23eabd6e88e56307dee6723d2db4edef96fdbe3ac86a36f1f829b0aced4b6e9b531b34ff692bf9046645da4debfabf6a12d48a9cf5f2aafc59dbc9d07fc1ae1b9e0a1578cb3bc8e3003dacb5ea841b6c9f971ed5b916cd5494c2e45ec506374a3134ac569f53f9c9c376ecc43a2c3755ad80d1918bc00c64d59c56c386fa23b63cc98761c0a4fd1b33aad9b5a1e8f2a1923790f9be3dfd1ed84971b4296e8d0f9976f0455ffb7fd01d67a530b9972b0ea669037a4c203c8175ee6da120e39439e3d3b9a28628f543bcf3fd6f5f7dc91531c816ea1e39b0e8a4e9dd6ccffd5b0ba72aeea249391799b4ac1bdef1efc05723ea45e3fad5e160f5d5d5a57dda9bc6392a815d9ffbbf77b4490f5527a11a2a337eb1f3d17735215557afc75922cbd07fecc7c0c5030d93eb44e1ef102017386c584862e1446cc7b7c5b80508a2582ff7d92449234908285ae386c0f3563a3d70c0504167b75df79d02d12b507840b299d60aaaf2d199ee6f6c8256b0efeaf3b48dfe971e443e1934e2e04d1ce23e057030247725638fcfee2d09d816292d203e52d39fe2fb08466b82956a41c3ea93776889bef9692e7719c618685538e3d499d9d366801e89c957e9134cb0d13146385b709922cf400b50c7617b7b7b930d75506ff837a81d713c7c61f95818f82497a97fd0ee1e0c68149c2107e8ccede6cd37daa18b204fc6d61ce0864bf675114d5f7d2534fd32a7ccaf8db5fb0cf151509c3f3cdcbcec32d44f843a3905d5ba672d8c36c36b0ce194ca2c403c3409d4219183360f75f61fe4bb8a1536836bb4e9d3aec77148ed67fd6b6e37cdbf9aab3c884e1ee9664dc441c3d46bb557139e870a7594d68684a2a080f4e0bfd4ec721b7733c7f4d541ea5edb558c3a4e3af9bd082173665649680748176ad76a6d3c32f4dd4a884449bb703e803341d88b39faead654158cf38cee2f100439e25b27765edf58de311e411ab43ef2043700e3cfd72be4c21abea056b1d1a65f0f563e60c5ac648e8c670929b6daa3dd101eb835994d36ebe126a852fcb5390422fedac4d4cac5cf0732eddd0184139547eae778620ff640fa17cee1b734e06df87564387e6d6cd786905ef7aabf0765351909feb009fe5f11348f43a7454aa5c125de66f32819850517ffeec48ca78f1164135df02a033d095dfca848b4c01c3191f13918ca5a66d77ebbee5a097c762180ea00f622d7a907809f51e2abd4b73299c0e6c0bdb055164e803ff8190757b2b6df4446e80531d752892b6ddb814da58504dde5b594dc2c0666028771fe60e1477e2ddb59d7077e9ccc269ca389187237366ad5e2e2e8e3167674e59b60cfa6a80aecad70d14569049ad9e64343d94a902e4007f32b63ec6d0d1064e02802b52215de9b66fe0d0dc78778390b791c2c7fc935c96a742b9d99cbd46c20bebff357fa1934085404b465fe49073ff4958bc89d09a0db4b061029c81372a980e166518a0cd09a88b7e06aaa4989abfcc83f69e87d2ab89c28d4a786a2ba3b042c96805cc8badb462f0f032d16d780853ea0abd6797cb29d82b09f60db6039ea51d807d12d8afd1531c23f622a3d97b268ab67baef70f6c03add1d9fdfb0814805c26540b51c6b83bb76515881aceb49313f4f0334d12a8d85ad1765b567965e18c37d58fe922cdf975cb7697e4f3b2c143fbfb7770ad6eb80beb69e9b52e64522fdd19dfb2f863c17530503cfafc1766be65e68cf128719633add7e76a0bdf0c2ab52cdfa84132bd4d6f2d93bff7ea79c0ed5579ba51221fa919c24190ac6085baf46a5ec6cb268fbbbd45284fbb21ed5070d1fdf144729107ba5b60dce26aba4793653b2bc8419850609ba34d99ccf95d629740c9a8e51f74bdc3216eb725f5c49b92234b81c0bf4a0b65f33591fe7f6c3f8228f1478e2d1e513b2b94b1908127b4d3e4ac35d34551834845c8f7b1e2922e4f1f52639da71259979cbd6a8ab8c64c8c693bb3d2780737791fdd8b40a8c2b4a5cdee30832682d1a45091427671442474f3ae4db4ed98518466dc396ef751006afd8bb83934a748ab0db7e73022fc5df4231281be7407f4181d387a0c7be968a157306525982cc86fcd793d376c94b06ceae7f0bd4c66f7324fc237308e94aab30e1cd2897485e680abc12df62cbe820d6929316e64c9f2e80c375127c3102c2ba403d8983adb4ae7e5113560326cab7ac9ce2fc75302730a61e251bad377eb60b027b417735c8e628cb9ac99aae4cd5711e9aa87de21cf982e58a94582cbe62c4f27ec722be2a5eb442be3d1569a605eda4caca71bd61df8acca2f2d1eac55ed4903fe5ac9e2a110c71827370d312ddf898e7ae9d95686f07b61f1394c28d258a5f17625b36508688f9980d5b805b92f9b203950867eeccaf30669e4e11d5f1e78c39cfc43da8692713dd083d9de1faee22e9aa3e0981f8b89f4f0b68b907af9829ac8496ec1873afc3366defe74e4470405c2bd7c1a3ab07a2369b59e4a0c7d6887d15b19d2c69db32619244b70d332cbc7e80d654d603076105f29ec019332537887dc47e2c992e6190959a5d6c10093f1e18bd1803501926b3376d22811584070f38f6ae5396c9b39d5d1940121d9359f97f671c459f239ed474f12ebee20b8c99e27e1e8ea69d262d2c9541047f477bedc70d904c33b430dfed0895b294051b7b80dc90ebf711cdee03e8aeb6c8b707652632fb4061681baf1a5f0dd7e74ae53a8d6973bf3e3d7e9aab7f85c3b60fec50231d2fb1ed15d9bd3a79292997185feecdaa9734e50de9d51a932dfae5cb73c92d90c6da4c9be49ae9b6bab115ef2bebeccaaeed287c8e3a6619f09cb3d11f524311ff8610f533cd2ae0931dae14c8b93544cbf3a791ad8477ae391cb1c9a94ac197c7fb7535596b8558988d2231fed6f70ae128e1ab3ee7db6f58e973194e8a09975de7cced6b74f5dcefc4c9003b3c3974e3dd55ee8dedd8140a957da0cf4d59e77c95f5faf88ff7c16df2c918c4ea9b33982f0efa1a121533d85fbd04326423fe7fd867310930517c3d6d17efa81a985c55c3f2e6f8ad212aa81de7f5989abc45ff83c029c93fe657c322e2e839aed45efcc69646fb528a1ed1906a8808081d97cae759d871f8fa89ac6ab1157c7cbcede5bdb285f7f32273bc5b398ed261e67501bdf554d3dd5fe452345614eba5276c13ebb744cf9b48a02882d3d8551081fe62a4a95440160841ba11979ae1d41dc15a59ab4ff39eacf9b631f7bbd39759fea4fe5dd66e70144753800e8862d2ec3c4194157a1bf1747d27a260d50c397d0cbad8d8875fca2798103b4999448aea2ced4e9083ae957764a75423dc3150066c92784ad87b969ff33147300ce27f802d7a69b26d3b42e676d5a2fb264696ba0f6364364d2100080c842c4ac3fcf97d8da19801fb233f61bc770db99bbc7626df83356499a82061f3e63b914cbde99b5da61a8d44b54f415ceb6b77ccec59a54b5b59bf7c257d981a4fb1163c315d11caae1f9428a0e363e7d9aff2c0b3a48e73b4f4e0a180631a1f4a34a5c37733f61f8ef0711516d54602497f64cfea6d4b2f5d79fb8549610f280f4dad4a84e388aa82e8b33e32c8e01ca46b583f73ee579a9d2d2bf758978219b38d8c20b84471b8fe571e39d34414eb905e69ac08aee88729ac27674676bd5ac047ba0076c2812a094716a9a505347fc6eead103cb15b7804060d57abec92f9c61fc9d704563e04e7971c9d2e67d2b7291bc64dc391b9fc7bd06cd4524d59046a50030b70533e9dd4e19730f1f874d9d49813a0f5c29612d9b3604ddbe34b1452c45836e83cbfabae702e8d117237084e2e4339428737da32dbd42969373dcfefe82cc493b3a6b141c2aa72c5703382dff92760178130d0687355c8e3482cfbab4d511cf54d9ddb4d3d3ee763348a776f39969d3a6439373517dbc8b9930978ac766080ae8366b67ea02e643f486558bf3e9e6e90b10def4a4de87f546d636cf643ac15ba38c5e4d1f2938b0d3f46aa9d3b41f3795a927520b5e952b7d1766e73b1c0aeda94096ca69b6900206098720def373971c3e50df04a1569123ec0263438e6726d4c7fc693815e5f57c511c10d38ac731a5e8c7c0e67e96f410d7b4b5599ad55b6367a02b4f7f52d135fa9b3d24a1645155a756c67f7c4e53ed7461c52a95a2b68dae7dfac8186d6ae5c13a30eb2446c709c5b0cc3a0aeddb5846cf54b909c12b33ff84ed6f3056992cb6ca18a420f532b11c42f679b8196d96384a91ebdf95cb0c58cd16dafd10792ba7d489d932235f8439dae3f1e9f1c65e988bedf94118b015da851681f6fa916b63f752a9d452c10da200b2e4661c3c01ca392175a92c3f878384ea91f261147380ced04bc3d39c5cfeb88a3b138808280cd2dfe8f72368794dba970f6a29d374026c4d50758d9051e18dff6ea06f4008799b459f1a0fe254bb8c63d3f9dcb1fd796eed6701e5d58013456d9ba00ac1e825c492419a33ce91e370634f44c918fcc4afb70b4ba3999644813e011701ba60b7470b7e555313968c84425f3bcd37870b64894537d35f11b44908db26fa0577f9a80601a4f4003a693be6304e73ef64e12b05d913170e42aa13347e5f5f3cb5db4a50f20178f55850f13b62b3c4bef3a23c8486332aa27f8708bcff7c3363cfbd97e87ab6b165ade7b4f46b3aecfb4f8a4f17230458d10d87f25c19a18dc97c3aaad07d0bbe8bd82b9974ca3363109e1ba5b5d896a6507e67511ad32ec412d4a76015587d3382e90fb0612f5f30e1cb5c48a304c0190f9195530fc62600afaa24acf99ec72d831508ffed3a69c69b920fd02ab426b295e7cbe73c210e97b362009d6f483427d18c6c8d5b854ea8b29fbb0369c8c838a4fff68bfa71526229154e52ac3b4046174bc442781f3f533c9918ae1583f60043a1c3cf7cc4b9eb9abb79c0a896c9534cf2da7723f3d36de26938e19177ff5c83b1cb51b22b4d2568083ec1c789a7b457582c971b3212db2c11dd96a0bc1df4ba024a81104fb7dc60600c800e127fe2cdb7326a41c9ddb943812114f37e860ef9029e89afac85117a7df58a20b45a8502e19b94988b58250bdecc5044e205b2e8cbb7cceb7acfebf7ee92f5141c19d36f984d08450b8deed385682c413f3e6251a421469537bae3633923ca54240313154d0c14b59eeb3e9c222ccc53e4fdccdf276ae11bd131e4c163109f865c0d2eb541d63b4806e6512c68354fa05bfa820fe09958503a33849cd9433d3005f6d055714f44418d613d1347d10c473ad04f38ec261600c2138a74627f59ac0089b72f6a85edcea4c5414bd487d8dba4e45c0fc8001f1d7104523ad033d2d28688f63714cb2eb660d054364dace97d4d3ec03244442dd8df96ec73fcd8bcd2948a3d5b62ac82b928651852830b631d3c483a725d2db7a3b800123f4f1848061b99b61303f98a96f1ff7ee105181e51aaf07303aa6863df81d6ff47fa34d56b2b3e2494618cf16e84584413db5abea7b509e0a3fb171f38af92c2bc58e64d1b6c12b3148499e506e3f8df36ad0579add57e258db7fdf52f5d3b5a519c00003d8344c9b1461a2a78f4d0af41a36fa6ff242bfb729efcaa5ba408667e67969e5cd74d65b413f3f5394885efc51d77649edca95616967d811c03ce9563ba5b16326efeceec4fb554c8b91b7df1cf6ba152903c8d6fa247c2cb5b96fc47415faba28104c9abd6281fd8846840ed9321bf0d2bc249a62b7b4bdf021b5673296cfbba46525b92939c276126ff0741a4e0b9f03073e00772931d6112b19c365ac3c1e71d95b439f288e56dd2ec4eee01df9d2597e32230db53ac69717325208049d370c4494b7bef2377aff985e8290541c817c77446b8211920445ad8ead6042811b10ff1a9a3b52edd189d1a87663c6cf29300d1184f6a4227c8582f55467f72fbc86715731fd6d67b1d44807373c5d4892eedaea14af57bec10f26f25ff8a47e352722ea7e6fd56fd7ff772a99148650f8477296b160a4fca3b2d3dc0e0b871ee486ae6524221aad59c8b6b249202bbc675704d4061b69170e90232498ae493851778d67cbcae1a7e45fb5574057806bca15e8e1f9be43a9ae840b37c60b9f7e479a8365199c25ec4f829d8f11ae023cf814ef03e204bc3222b33d3f79137e3f7d60441f632b72aa2d6151e848405d34534ee3cb3db0a1a51bbec04f5e1093f52c40ed4d99d926742b3e52f4b49e51c317af13fb0c48fa6fd01fc6c1cb403939d2e86aa731616bf29e66d168d81b1b24ee910099cba3d72a4fe05bd2c9b4ec9aff3336b9f4442581f75bb9bf00653de8d432e6eaf729f39d4c65e88424b265126b1d81ac6cb170e2d0418f8819a43504c7667d546a17685f911c36a6b5e4576f5971ec1c602d14eb166f8ffcf0edaf4d60a4ac13c04c2a2b2425d821e280813dce9eb22bb4c9d26ccda43d6714f8b238d60744ba280a2d3c1a98bd7e1ed6e349c1db65df560aad540bfbfb0b2b17f9d1c40a2868c0f77d786fed195cb307cd006d0e957cfef0419c4354e2a52786e69e6ba4a2eda2497740136c79c00ecc2285dec7855e2e8883c38c062a09872c598542a91c9a4816a068dfc476b0d6dd42ec60b1ba0494be9e37261e3ef48ddf64820672b22b4a5071e43d30c4d6e9aa44ddfd35bfa3be89da3a7e1ce55b997a026467afff2266a6437aa0fc85314df9822929c9e7da1d057eecac6f672749088fcf1f92f6505c4c2d5042309df1d2337cad0a8b4f9103b4cc3e666fed47af74fb5fa8dd4cc628face53a71acfdb62824d443e8704b383de86fbd5e808a9240009c4f9fe89438d957e328b431943e197ff7fbb95d45c29507412cc62fc262c7f9aa53c585710753c1bc88eb8ac0bb43aa4e98b7c79bc0df7559c6b58683dcb1a7b01838a29f61fa86f5bca89b8495c0bb1d8690ca93315d504e3076ef9288646528ce2eaca6e8501353d80eff4a78597941a7a2f53ccbfc96b7e5f8b75bedc552d716941f9941408b7acd24625f28ab4a2309a5996006d6676f31d0437b305bebeeaf6d0711449cf02e25aa3a3df668dedbe2557a3159d9efb00763a2e998f8c6f96a708195fd8a57943ae69631a0ade7ab291c1980f7a3a8b0fab6819c2a0a9b4b0528b2cab00d9cc73c31b4e4764970834b5219d36ad45fd42712b971c1546f4834b2123b1845579fd14708dd203f6e17711edde8b30126c0f1c4a62bd72e85de8dcdb33b6e4866740c6b57a59ec6491c41e8af09bb4e52687866ba0577678dbff39666dfbca7d09c44bbc52c98b240cc971f59c752786e483940c859e33daac0f6b605141ab5c2983647b4de67d51921075b3c6c1f6b606207b2a02bbb2b4fb399c4b625284f43cc2a841ff56634ba40ff084b35e731e6ac33a5cc3dfd3dbecd8affd9ad2d757269629d773881d808d9e1a451dca3436a655157e6ed978c1f3cf0eab79ac0a067522c1d482288ed71863d0a4d1fbfbf2562d98349021939a3952a0eec45918bd00a8bc4afef4419d1f2d307889c02b2852714ddfb8f3369673fade832d5029083bfa130868caf12c945a7deba811a5d6eccb19f5997ab4ba42650bd77a5a31e18978cd045b9526df9a4283755e753ab9a8dc85857542eb782c9a4c17598a2c2241d9ef72f41fb9329a38e3a7f4728ae736f7e7e956dd9fe77235bc80b4acbefc315dab957a84e12d4a088d134bcc8e36a96e0eef6662280bda43d5dfdf220c8209e744c85c560a4006bd6de2a418a2086d9e96547613f377f9f3078c915d70eecca28ad2eef1467cc0633202b09869906f9a9ad9bf670a170bbe800b4cd61661de6796bb462aed97a6d4d24bd737ddf3a8af0a9f5a70f1a239e20ceb63b59b57641c9837dcfaf126742fd30211a2aec5899c186317c629fd3b66af010cba5ef85367d95ed808dd0ae4a99990ae297f918f52252cb5c4facaf638b5891cff9691007cb2209cc0db4caa1dc0dd4bc448514493d55f42674227f5e94ad4814ebd8a069cd337d59bc0b7873bc18a259fc4cdabf2e99a394ffcd6652d5add5a6d6a743391c91535fd998ae4438a924846a2319c8df31d998c303fe11f759c40d8c7672251cc0ef5b4973929a02d5e0cf97f035cad7abb2cbe1f01c4e0de5eae991764664c828a8a22e215458ab55960a10e2216fd5926a6a7e1197f940703d31fa8f8def98641ca368f56737790a40b14d04f137fffb9fea451e272b7cc7638738c9ba451aa4af3d962485d5e8b46d807235078e78f9fdc2ae5562e7356a3785a1f1e269108828fe41928d1634b3facd85ab753c68ba91d78a1848b3b129508250572ef77add064cdf04a1df5e294aaafc8dbc141bee53a9f32f69405902bb7a0c51d17a6fc29ade8586760f9b2f3c319daf8da2ba5acef1cd6f6399e19a05cf42a71ed6229e766b985e5e3d0e08b0f87cd207b131ce9f49d5a6b30d2112d7644f288eb5bbd262782526559916b6b28f925161044b41a3222739fdd79324171813f22d1c8cf3bdd8a51f8a256938b66d366c3e4eb3f9acc0e747fe23bcde457182b7207b95d5f2fd19f447c1bf2845f86a4ac1af3d687c8669ed76be8c27d610e08d15a8d4e94a8c7cba15cbda69f17d19ea8285ea729e651ca7e0bf6fe09c6fb3d0b52752035abaf95eca31d5e99679d7e060492d0b8aab9719ae3c2cbf06d520e1536af018306853be0d2f8179e2852a496e250779fbb02fc355dd2d5addf8e9432208060ff8e4e75adea20a2bd73e0a1e36432d3faa1d11dc629580a6dd0f9e067588b89f2daee19cacf1759ad4eca3d7a4506a462f442317aecb8f86d136053ae13f9749f972d5cd1f14083d763778f0f9670c321bad356214d86fc1566ab8abe3171f34a47d1cef9dcb723cd35f25ffa1c24255cc73ec0fb7aec0a747e70700b4e8e55f59f46e63eb725795fe012dcf86d337495b7bd8295a0e46852fac860e644261cc4744b634f8351d9e6941b700d73060952c214535ded7159c28ae411d4fc9525894b9155562ed94ae84d35859cd42ff94c133e943183a584e5dd254ea16880b86c132fe7589a9134571fe592e9ed2822a8216bde0879ba496d28dda8c1184bb7450e31b2caa133b98f0520fced1f45d1691ea2e389075b86a39e1f1dda60ace106802cab432e48ad69a86127722667182a124025fc063e7368104cdde4b6e7e83772ad9dc786ddcf9d94c90c39d7fbf80b106a1cda1a3aa295a4f94e2854fe1820ced9f2350fb4b24de04a25da29748b8c35266a2f0b6a99f29dcb351930b0f47e08df1b774032bf958ed194173d675a3e793ccdd3847142a405cf1ccc0af9e45d0a11dc4a72d143875b53ca0899b3241884462ad48730d22c0b1bbdc044e74286e1cea09f57a33bcb5e4c7e4a373c7444734ae4556bf0804cdb4a990458629f845686ed452bd4c1b1a8b87d2374d55b0bd072254b9f9eb38affaf15f5086f5f2c628c9447044ce0037540b56333e286d7d00c75c084684292bb087012714447d9be3212575e98edd5fce90ba46fcff2b6ec6523696c5df9136e65d5a8696feccff2f2a76b487e6c756a692306bb231d931e81332f44ed5e66161f49b8fa52a92f0329ab948294c00a88cb2124b03618142da40cb347ef72cd6bd9657fa6feb05168510cb377975f04707956ed6b66424819065c5d67f8812e71e39cf4b30a6d96e6a9469941059740c61796c919d25f1ac49c5e508f1d5d3db750783f38e95e6ce39d848d93381b8b1549d944212bf8ee19cd1c8a1cedd140923df4524e9713df3a6e2a3639a2b9817014d059c98e34f3d45f0f8de1bdce821ab23350da3368a564920d7df5bce3c6825829c565be8ac48bc1ef33bfd33e282fce50939239fa3bbe374e1bf6dcaa7109b1351df135f21a1e9285cdcecfc255003accfd447c8f7a510c3a804fea1911afa64bd107440326ba1393ac45aee478a082ee9fefebeaa68c334f74e06646587e060b75c1bf75efd1f74768ee2c5cb0ddf1d4e044f584fe68f53144ac80dd31b53ba77a42e002b8858348a23969d1dbc735721f6512ff930149861d6258feeb1db896b17436039616acfcd9e9bf33d0b493a5fe7983cf1b91079e4166f19df81e8c9bd21c6fae6578dc2a64eaee71e1d7f713a611f7dfba768a40b6d02bc343e6915aa797bf13ddfc639a56f1b1b2843370b7c7850a1d9f648e27882be03f3d8c3dab9fed963b537573dc23537f8cd5d193dfed96a10eedeac39fcebfe4aec9c2fa722b3484651dd27422a95125145ff57b5bf7fff92b113926b33e98995b0f02594ddaef59d8934b2231af12e3065f900377936b8a06131b754f41f16c07ccfd7e9381e46c4383eac7a9582c9dafaf5374cd265642f9e7b21b9b15886277fc76d46980410d952ca3bfbda7be28a8f0f8962e75f10ea083d7db172791f15028b6514db44c99ced366a51944d201d030250435787957d891c34cc8b4d70abc67990908703931fc51f163e9fed69b0bce66c7aca0aae4c0d29aded1c8d37a4ea7fbacaaf01f12424fea13d4eca2d8558418b6c3afaae8db6e3cabe7cb59b8b68447730e5dd727227d7ab147d7c69a47334835680334e12c6c0cc377536799cec3cf5e75d37831c28445425c50d70f82366325ac69e73a9a2611e417565e5ac6b7a2eb951ab5ccb5889d24be256910083ce091f294d788c68fd75903cf9f179977a399944cad8539e34c199bbe7ac42ebe3a753b5f6b2faba6fbfbc08dbdbd4df12234455bd3e9a909ce725b9b2a6543a2f6e3069dc5c1ec727d11e8e0022ed8e2888b6633eb96bd331bc43fc164db3f93259b1a302bcb329244ecdb172d460e8fbedfe78e9f09e40e584b78051cd8184be64af87618b1d892e044a1d996414ee03f6ccd4df467349f4555c542d11b86d40076403eb6e4aa7d44214136b5e000f4c1fd8a50bd69d9ea32791254f57d14c65461dbfa4f0e9fdb871bdec1164b5221ce5d01b9be7ff893bc4e068761bfc7952ae4c83b6b065dec93ed89222d18d79febb69a46a10de01e9453da58e5dede774ec921ec94496149fff1f3014a21ddcfc00a74a57b910a8226a40f658d9e92803fe3a110f68653d8a328a1c8d1171593ab3047f168cdb0a2df1eaa17b070c3b6b03e1e9399dc63ee9dff1eff545a8663539aa5a97eea68761ad0ab560c4373342af6a29fa9f676825140d336e63da6ca3bb175033b3f2676614721848a2f74827e07ca4b288f1f797c37c4e7a0508e427f1b1ca2e40ab8f10e3d7534d60e7465bc40d1fde5d3aed6c92ab97353e8d2799b2b5f2695d7afd8458382d1737dab8a82df8ea82e0df50a859720c36cc731c5776337671350ed9021bbf2e94baf1e0c03ec61c6ed34f2ede4f58dc8765cd7bbad230cb49ee763191eb01ead74d05b3c8826d6b2f6a8cf2b23b953aa8cb093e034e82f7aa30816ee58b9523d13ac21b78ef11ef3260d19c5cdaafb98b760da6fdba44e87bef93c3474e1dc30c0d120611940cb7d92ef07552f9a1d665dc96b9780fe9bf4ec25bf6b49344dd7c17585f88157a0ffcc0d9cfd0f37b53b15f5db8eadeadb76f0bab72d3a2347d077ab06ec85cee09837d79107f2aea5ec59cee88ee657f77505a5de58e8b8e48d2618e0fee1c36f18ed186f93d8cdcb334a711c9848c0f1e43e68f05f7158aa7b6776b742b122c706ad58f122eab078b9ed549bf6edfe8e80ed09a44685a7f250e2fa9c265530324f657780bc24e34e1fa5a9b127b0eea697c7bab88c74bb3ae8f7e22ab72606f67a20f477b105c8a1b79e1e1530202044143d0e8856ae1eab341a449e63b2c216e78653b347f6c8ca0671ae5c4cb63efbc30bf56db87c9f9eca722c7180da26199957b84dd0847627806e96e645738ce31e0e65fe1da945c02e0aa6728bd7511eeb4bfe9669ef3003a2e3a7efa6d223c1a55ed94d0f1c17a88334a60353e0393f97562202f28a45f2695727fea4ae049961c8cafcf71b6790b5cfaf6f513868dfa88e410a9808f08779964dd2c4c53a835b05322f9aace3c11bc638bf020e017ca24d5af8c6d934e619f583671633f5d13920da828c28c266e02e41f70ddeb0bb101d636132ce90a947a84748c686fa0bb67247b2f0ff3b3f6b217a9db9b65f75e83065f6be36cc8492e526b7f9b85af1769f3f9e6ad1e34a4b9ece48f22126f532b0282d3e46e37af079ed02ec6f6b36eab8ec6b720c10663c76452f7ec0de6a0fd805ac40c44a3badc9833ef3e26c0372a4da3a76b911e581e8c0bac3595c252b31d84ed89840f6ca9f03c339f88b4ffb55588a5a2f6350a2371fe89315f29683378b7a4a4fd604237c8845cf2885c4b8e140c92377de56b989ec135df850e19de636b34be2525cce331931dfc1ecd42bc98c4756631ded40d50fc424a5459207ce03c8178d4f08b2e5c2548ac3cd318f101e79c40108559dd871cfd6624661c6e5399df5a70311fd7adee1c84cdfde2d58bb0eb6c75ab1e3b5fc8944f230400fe1bd62ceecc2f4c00d16c979f01289a360fa96ab3df63f75e8ba587fbcea309aec795c3445052695626d66a9ca0386d34fa06243ce4ead7e6a0f25b4ff251631822052a3b24742405c2752e0643943bd0beb5483d09e03e6a01a4b264c7ba9d04c79dbbdccb1836f23103bb8d6da0fd9af8e1c2fed4a42e62477d4e90b3df51a66415f899dd1df35b1b0811c580c7849d2d7cdb1d80f538f34d59e8aec079da5e873e7a179caa9f76f01b5fc21e2af144acf304efe37828eac48830796d8807f4021d704f1bf98ac9b95b03c2be3fcb5c18ccfaf63e313c7a54afb43f9d94f9312448696df3f0c04c9955074a4e05e1903ae91dfcb0c0f475a1873640734378e09a73bea6d12c6ff90a3dd7e2afb9f1fa9f24d76c89673bf3e2a1624db85cc30f25a86297a6bd16d6d937c43ef43c99b8b09fb081b058d758e824b7849e86542fda87aa316bec3758e87db7541e60e69975f8a84e5c27e8ece86731ec283158eff4b7587f632a661e7b456de78b710d45a51ad5393885ab6eefcd70c31a77adc1f75dd78a9f134efb1a7b88fa33a3df4ca718ea3755084ef8da349dce6111b52e1ec3c79b602d0dbac971cc372d09d1023af78a4fed05dc2131ab5b10e73fa7139c1ed5f2fc5193d5b827da242bff3e627138b1004dd0d94ce7564fb7fc9bc9ad46f06f0938fc40865b3e5210405f66b51d5f933b1985ed8ea668422c2c23bf0058d2d520ec8108052171e67402837b9f9b256bd8ced706870f371ab86309a13ee5c88f5c6d4dd1543f8962582219023a1f90e7d3618633d70034880fb9eb8085efbb180197142a0827f3b72f8a570ea42bf5971962f40e27593606606f83a319d8edc5a3e543b54fbb7c17e114e2108bfaaf409da716b1e7a359c4cb06ba3a80237a3d770ea6cc3d6ec85e7e9546bb05c1171af38a8dc02bee03f7de70d0e60e11f47edf971eb106601336cc32aa0bc44c238efb6ca1f9d5ea12001d95a6dcf0b4075dfa55952a26e28566099576dba56191f1808203a81b864baec23d0efde3a61e55274853a18f5d6a59cae456a1977d35e76d5669a3e2c7091e284c6853c4bad54c3e7e0094b69f3502807a5ecdecbace753a8cc6f94a9491ecef05b3d52e23de3a3c5f136d3af849fb258f6508c61c3eaf209a81912ea45a5348e6218dac33dd88d29fb7794cbea3fb81e82592bfae7c60f881e5e2fa9345bf07ad5642134367cfb1f62f5615ad2dfbc5e9ec1fd5da9ace61bddea62b32691cd4e3d947a921102297d61c21631b5322d93a909afb10d0d162bb139d8c03ed23a89d5d8077be47c857d47cd21ccfc6e2987f3623e4492d322e9ec3cc87d1e99d8a5f40a3088715070ae4ad2010a0929ad539fa9cca4c536d17a1770856cab2d91898543b6f36f40b42526d72f4d6f987b5cbc01ef1aa1ab418f819415207b772f6846d0210aae396ddfa18345311224697474658cd94de3c2bb60dd3438e35c49d8c7d2604912fe97ab4010340e016219f393a07b549b6dfad29bb28a655f42a3165f83681394e4a4aea639491fceaede438bb99e70425e1f6bb9dcb295b0eff6eb9869e0c63d17714bea22b647cf09f88871f363673e554cf9c1b2f0c318fbb2fc4fc78e230ce0f8ab9106bde00c7aa02bb4b6c682c17f13331f1154d3b33163465472f8efff44654d9182392e9663906fbea098227b9f8188ab7396b397f0f5ba31cb75a866c70bcf45efde6b3c9a84ce8d654ba5248028725380cbcf15657591c0a89f411ecb7700a9e079e53339b108454c1aa7af08c2c1fe831953a4cf84983928a268e9c7d50865cea1defcd3cf9f2efe77a7a1c3d58aaf58a6966f3f58a82f7c0ecb35854b6ed650e7073fbba9cde289a1c1c7380cf78f47100ba0023df4eafb6947c0466192a835017c5d3d67f4ff28547e897550f58feaa952447601ba5cd9eaea5d8f48748f3886010c8ac5cc7b620de3c92f826b7fc570119885e0371169a634e1473f9b0d9f094d8e67e9062c185c9e11ebef408c62cf874e0cad0edd8e971c28c37a0fc0d7662202f12046cac27ddc9e001359607bd7c401ad0fa45da72315482b2ef8c8d16a2547c8125b18b7433ff936b986c55446945cd4ecb8a291c594d0a6b89073d7ee56ac73b8b8e022a800161636cd44b14252fa00050ca52bdd7d716a78e64134d5847246a0bde2138383897cc5e0facdad877ceb8cd124038fdedfa207207e30878f4774794124d5eb61d54aa8272192bfdad7b30f313522f1b8cac0987a491757f1be96b261da15514171a01f8de5cb720eaf6a570c2cc13af5eeeba390faaf0cf93a5b4eed82cf8ef887b0cb9cb440d94dc4084c1542a68cd6d6c9a8a0ec5d0ef7b3d70c47248c0d3d99e719690402418fa70eb38a8cc00bae1a80a570db5f2f0e29443095b8227c519a13f88e4182fff24f46d80d32cd0aebd4a601550fbbab6e8216aff4f713e760ea68c8b3087caf83b5c39c6a2950d69fd42d63f0f51d5a1f6eee96f312b5faae67042710fae792160fdb0458b8a3eeca9c492b28f912071afe8e762be8768e77568fcab30356098667d4bdb553a56bcd2fde447d14a0788360f3883553f769baf9ebd4b859509044800eca5017f6a77d35e73b6571449529aef1b67966050dbe97a9b84d167ca24fce87a0484999a88ec4db4f7da1da4f16119b4b3bc3120c6cebfb5bf4f050a5e523cb4770986e958cd60ff43a5a617f188791424b33c5de3f80899552a9d74dc63ae2c866474b1de0472313467642302bde6708f04f8b4474cbe4ed89db97298e2ddc9a2e6d476e7eb5fcbe04e64e1720aacce54b4b827030165541f54ad7c786a940435bfeab27fbf707d22c57d16b434f40904446991b4f9aa32799ccffa319d475e01ffaa611a78c8674a164d066eb4ece878e298b821987628dc4916da2517bb99e0f5f5fdb035d4d0f29e46d3d11eed3c5e672c896e08c52a6dd9473b4392b57c80fe0049fd5a3ab1785ab650a002c934c4e8bb60f8da4f879f21d07f689dd430e4900d0563750ed43ccc01552cc89de7f192826a84c41b75ca9a042640153fbea3c885ae6ed35e4ea0955a29da287cc381649913003b11589e37739dcba01ebf839d5736270835c4d80efa301b8fd1f539458f998ceb7622a7b5e20c90d552016500d02b20db335d3e8bc8d79de9d18acb0f43382c2009d6473c62c6c8463bc47ae6ce2495c533f5814e6c9a05e1250cc12d04c9307d83a8f980c5924e81d4a9a6f17847cfbbaf9759deda5f3e8c82dee451e5a272dea94c36fdb448f1172d002983b92a348b731dee71353d3db015248eda91805da95f7454a3461604c1bec1b3d0eb2c39b3a8162146c024467f9fcb9136326eb7063166e6a586c7e1d2bf34d268fb64255b445b7398645e620b6410efabbb684c5bece73aa2378ed129f190b21357239727afb6ef8caeced1cb7af6806974225758891ab0a0a122f644cfa04621416aeb126d729424f8cb114a718550dd76275e5291cbbde9a0d150c5eb69ae843ad756ec43b753c756d2578c019754937a04d4fbd59db8437f65dd63a340f6191e63701ed2abbca95483fcfc609e045d6a330fb82ec7dff443bfbb05bdd236e103bacfd928d0a5b4bb2bcba39cf08fc5ed228159d24d4a98ff1f7cdbf8e4496ac3af9a2077593e4de048b9dd625344e6da095d37e58ae592a7024d23a9f79e9d7fe8729775d19486d46b2101126e6d1e7309d338eab2c3b56f6ee10b983d1bddab02fb26f12f286fc06974b6f34de47cf94cd00e193caed681f5a3452595a21a6d75802ddb25cf64768418465471c2de13f29a12065debed26c8119ca16ab423458d95d47a2afd58575289a308cf8137edd24ae35fc40818708408d3fb15f11894669e90885aa37b50126acc2430514ac1c9eb15350371d11054e4b55891ed1d91e07c215cbadb56cdcdb007d5173c2e95072953fa89d088704423a0086bfaff3147730b1c047b7a998447d7442e279f6c1163b87b0c19ad1a617fcec2a0a653306f66126ecdba5dae5d7d2d2bf04308915d8b948bd367ba85b4c752ceee496e5e55cd55be215dadbdf821b449f8ad528ac9c0867aea105522e999916d94458e81aab2b251f1d41306cb5b49e10048e414cb0c4db24f7f597b6538b3e7ee55d3f0d46ebc4ac3181906259afea737dcdf18f119d4cc9209f9e7aca87cfe3ca368e52a3cbf043c9bbadd6827c4f60b097a0a34c01e19afaa3f1cfbab8f19d9228758e5e37a0f15ba20d30e0173d9a67711a4c8e9279afce4fb0a554c6c797e92e9cd8be89c17244d2679d6682f3314519b5be1f177d8866e26696512e05b111e1b290b1f097d3292a515451109cc9ac84fdec7d04032361cf68dad51aaba000cf5b3d3ab2a4f9f0089f04da7b2f7407b7de6fd62db3220811d29e17e38b06510210148e4a2292bfdc08cbc2abdef68ecc575abf61a9698f7e11e3530597672dd3d744f94126660d366027f6925849deb506a2ed86a479b4ef36f1183fd85d35e6cc965e8d5bd71635d8638221a3c5f08c6edc306bd76af1107f1170e01411d25ef8298b508fd5c5161f42977302531bd87df5192c02899065411c5a5398c7fb6a35938ac5ecfb786e55df4ae37c4a64691b2a125c523413280707877e70c8e1bf23d2a1bb89367e0107f474f123b29fa568ae4f6f7a10843bb2da8159f05edbf0d332dd9c07c416dd68ff3d5614b94860cca37c7897589d5c9702205b573fb0f325226bc904dc5c8c7484b125a5e23ec26cb4825738cf8aa4026575d33b8f511139c09bf430ac70197f259354ae048284348404105c34967292b2e29e0c1d6c49cffb1101584c2c9f87699b73378a826a5f3a75f9b74fd717be2266b8ff9622aa8c081ebc7f0f97a97b29edb9e2afd87dca771c50c60ef5ec16298f96065c59c8893095215868c929ad09eb3347d59abb98c085a929bb1bee6d84facae6c3e4b2f27d81e9b4e125ed4ee12a7e4a23da05f9b4ac458f40897257eb7ba92aa7772ce797c17cd60cb4003a47f13661dc531816f05b39008370d54dedb35ed3d9ee546171b920d2163d5fef2813d988312467e9c577b58c98f6e9990b295f761f4a4837cce9428b6379864e26dff12561d2ebf3fef8d81c940087835db236b095591692eb74019b27925503d4885e96dc5169c45a0f64620030ae10f0ee3aff5e3d16ba125e325aecc95221b5d7cef82245b9dec4e95893de3c1f30581db217e3b47783ba0882b91b1d549b6dcb8b703c315b2585b04b8d13acf5fc0e968755af08817660c7989f5181fa0453b74cfd8ee33aa41ade08c847673b0750e61bae61a79f8dda5c862ae9f481acb4b95dbe56d76d1407cb2a1b5065358ae4129fa6b33c806a6390117f20c514c0ec8a666dd9b1602620db6deb01275d069b90ec5f04b8f88c935c4f2c6848ce5db17e96dc8f9b15025d82f86ff2cb141ab57d992f9ffdf0a63634317cee7d03c36168249b9764c32e29955b892185802fff8819a0bf2fa51d79ee46370074fd6c25021402f4dc4c792c1e00a4374924b309373438f0568dd308f826c5a5d514636b90bdeaaad41678a73fd8adc30f17b40169c5e9a282991bfe5c91a06ef0aa69419e7b132a4c3c95eeefebd9c5f67842c898db466a6e6381c1e5360ff2b4dd27ac74562db0d7210fc02883b8ab1ceb736bf5c4e6f5e6d5b7b6e8f4076cc12ec6a1ea233c153d0cfe7df67d9b240b0f535a27e0d45aba1a4c4b7e73552ca1c215f7aa48581351066aecd9d11363a4686cb1662a78b375d2284cc629f23289667417f204c3032ea4e147810f15efafdd55ee49e3d1833cfb4b88909bd303aaa52a2054bd92ec347083c4d040a4286070d133fb99d2f2bb8813c36d6b61082ff14b4939ad4e4045735ee49447b3bf41194098b23fedd46fced8cea02fbc9bb5ee37ab0cfdaeff486c470f1a1a55c8e7cb9c4e9c49f76c985af2e8032b9fd2e41b9476f2e92ed6fbb987e47ba0710f63d42d162ba7329192949fb96b448a7195446930e7e9022da394aa4478abc2e84becd3e0ba7fed5625e1400d10d48dac7bc88f42bdbf6c335482f7481caee76fd444a315d2d9cececfb8df0627e2986692fa67cc5c37a38584718cbaae251d90172de0647d00fdbf1a5515a8ffa9651c29a6a2ea1899058f12aeabea01e65519a8db28173bfe326ad1f02b0b86b728a70ad41ca2a56739e1191c28f478d1f313527f65a7bbe14720700d7b7f904d85c56d70689e702633fed16654c653ecaad5261afb021b0788040d655d0150b7972624e97e6146bbe35c34c0c067e963184dbd5510c05f73e27e6bfe748def15eea0a189c402513396df19a62274e887ae52635d05087ece7b30c9300df104733101403e4e666df2a80653dcf6556ab331a84c087d587bbea43b010ed4e4a74500f88f970157d0dd79c3666bace1fbdf91aa98f44a30488b5b4943e98b893c17997520aa6baaa7b58d7ec4e6fe1363dc9fb80110b2f9b1037697d075d2312d13ca351873bdddd4754e0bf3a2e121504d0b1edf33561a52dd9f93e6efcb7790955fd86dc8aafa32b001a6b8a0ccc05eac6e95ca28d9126694161bc795593973e0a59793e215588ae5c68454cff33db1a2f847034d0d2092c1891a5d1c968fcf1c2d4ec739d10f2cd257b5021f840afaea3316ef5cbdef55ae1472518785c60599c9410da5535d4224f2c77413cc7baddf703911978c36aa97376ee0d22a732f9fbe512820ac2f69c242d258dd6e4ab0b89b24a61c6bf245c9aabec3445e371636371f02c249a5453b66628a443e454b29e12cb17bfa15fa76beb550f01eeead3fbade547babe02047eab457386b5c56034598e2610cee4dcb17a768ae15740b299d4cdf867c55e8eb1dd0c56f877f70b88f6bd72f158520f834f7ccb9d46c277a8eef51cc865f86aa93d3f57c4413e12ac68e0c8027e72ba75d30e9e75c5443a3a2218e0a2377bacf3a7d0eab944572e4c4fb217c4cf1b7a622738c8815cb796cede8bc152f6fdc7a25030f3d42674b71a880d04c18a023cde13ff6a0565cff4553405f88917e78957b2040c671f9de533355eae5827311ee256d2ad60c357a41d5148636900828ae399e8741ff1bcb4b287b9c1887082ab30f27cd65311161506eb7be722ca42537b9fd71f1089156fa82f32344c266e79d70b63927729a585bb7274488c7b04c6eb29506b1634459b07c6222f12820f8b5f0bc47859cc64bf841de76463f0ff16eb604f96e8bdec00a533e5f34e3e17abbbe3e15c6c25485532e102e0a942af8e404bf33fa56cb0d6467a8e17d44d086f75209074c713a3fddb6210a318ccbbf99400e7ffc0306d7c9350d19462ba7404dee6b6e27942dc1d4017ca54020b78548c3e29bb5db3ecf8981e4a50a277c357f95766cb77ef6f1127494e5916ac40f986d99a6d67f379908c11af351323d8e08d48c19c2cf2e0e380bec0b065ba030acea070c49d3ee56ef9a831b3cf0273e0ee7734ff88f90ab4b8684db190af777e3eb27d3271dfcb3da384589ea6e1b30718c5b52d4370dce63251538c291f73784f058ddc480694feda8bca45050c1b8feb9cbacb5afee3c84c98a983a3cd36e6347390caaa28d6a5fd86cb5cc204029970ed6f3d26f869dbb9dbbdb8a18d2d7cbad579132ecfbd8f3ba9ca00596f89e1e0b63b0cf71ef461e993ff8516c0d5c557db96c51bdc8aeff580e6c943a39b022879ea0916885538a4ec90426db2dbf19dfac4d12ada01a33b16333beaa642c736f88054f0205e451f34cd24f2e4660364f702ecb47b0353144855b4a2580f2c1db61e9eeef90d196f7d2a8008390aed357355fdd25c5da794824bc869684a4455544fa6c6b67b52ce526800bb8bcf15bcbb010597a1de3c72feacc538c47c78d9fda8d6f44655a2671f6a0ee9c7c8d6944b8a88c1ba1c5772a4aa933eebc25e144a39a94fceeb7074b14e9436c36e564eb08594c701463bb71641b97a452313463f42d718b4a34dba525bf22958d73d216409dfe628aee31bcec42afbbc771d484db675760bb46be6cdf2ddb6909ce2c003cbc334aacf1edc790108ab3289420a46c0bef4913dfd3d3549f3d18b94fdffa8a18bb3ed53b012bf34bf6e0ff738dd6cfa6913b4770538789ae31bdee4e5cafb0cae431e08a3bf353bf70a31da8f3cc759ccc116b7e0713191a8c07360c90ad96042aee0d1a3c366c482530ee9d6a44f7fc1ba2ad13cc6b5c8b1195e268d197c603ec32d917cbbf0dca94ec5468977c6dcf314b6446727329f6ab69a80c291c1094e7aeb45d39354ad65b27096d3a89f766d8faafc4c74cc0d820a4d787f5a6df29c0278be33c9a417eeeb4a63d89cdbe338a329ec4ca5dcfb55c60e589af7dd39c83082334b9ead79db978edf889ef3a265383bcefcaa7554f336ff9548fc1da130a211f741a8dd4117779c9ef68a7c903bbd21e11030349722a0b946663b91ab3f8ea419a55b9cc293625d39ae87c45a96d6d3025023f571779428631234a87adb26bf21ac16954b9cad9e970b9a0e77582ab397d31690ea08ee4b9c241f3e53f68ad1b3c3fc3e19e2104cf618aea8e7adcf946d0212c2d43ad6f01b5f481acd539e734e2a67956da1447cb1f13b63ad8f40cd1b843251018d07b475ecb2e024ecb79fb2c0a735daf5dcbdde0ccec008d4a63ba3b7e62d1014733f9e936c6ed603408a718f2af8a1108ce1e18b228101e895a837b68839d3995448a256dc0b4f5783328c7a5c0c289c8be2d44239138798635f2359d7f38167475b8e21e7b61116d2001fa4cc0f054eb4912088949260b2542103a882e36a091ca1a8e9a03149ae4713771d652eb7ae45e86a023fc9b2a10ddebf764e1c24b805e623fee6dbd46ef59bed7245df0a765dac6c0cf40c04a08edd3f7780a0f51d114a6364042dc278f2ee36af7ebcd7563fa619311092a03c96f62dcc3037ba0b8f05ef7460376f0987a9ecac87f4947c96090645f3c62f5c8ee6816a835faf5861659b7cda1b38aeb1234eaf7a8eaef1ebfcca11902ee02d9e35249c0ca7d74987b0645167aa288681af1736303a115a8d573e18708c08a4f5f05dadcd62f716713c5dce87e3d1f9b3460f89ea78c039aec97ec387c9480e1d0c5fd62af1b94e0ead77775277c2a4ee0b956a4445ff02d230e53fc25326fd8c35d169f009f51281ed0667a34b819d493f2a890a4dfc70f97b622cf96091e28163357e9253f524799339d5c232d9e6f5188e3d7639f1078e2f4dff6dc88bee266d62b9fa2e73cb6813a1388dece8a9851ef07a0c31b397583a951a366ef392829bab3a6658337b87a9e3a4164ee5e7d9e7a9a2a0c92718a8db6711193fde553798679ea57e26dba572c2dc3b586516682d92f0f5fc1a6ff50b5587bc1cae0617985ae382412c98352a808b08c11b1fd84361ae8c109daed45197efc5174395020e4139a3ca1edccba659ecd1cb0a06dbfa0ca21ba288c677328aeeee1f73cb23036393f1bc94c69cb88ebb584f2377927d2f19144f8dd790428c4e9b3195b00ace407d8c9afef8d6d415c025ca18ed1eb77c96d54d3a872214135c53504349cc02f168a4bc5114bd0b35ea72fcce181faf637fe38717a0f5945ebba8b137b2818e6509d9af3b42feac5a104bb8041b91b1af45999d1ced5741600af83237731c466494f7e02dbb625c4835b500549866b47bafe2bab4d0d5225f1027a8776e2db9c398329b595ba9ff3695a66a7d3bb16d468d91607041eec9239d99a896dc88b2e01f6ce2f72b0c26db619ddd74f1a5f88628eb06cf14ccc9057c957f4df0e676743029f3e91863219121d78f9cf1f627650272d1c71722397dd54449f230bbe60699e56c10fc8f504e6d5c1827bb3c105723c1997bfc885c64dbcc99ac7cbc58b2283248325ce1fc5d4a961033b327a89624b6bdb5a5ad7083f0d0dda0a6a775c7848194ec8996b787a9267b1be5b143b1c651a40e0d5a7dc53019e4d0c91b597a02cb150a803fe233f91c2b6a13c6ae5a39b887328c8837004c1ae288cfbb794e2a65eb091058f210cbb5c91cfa52c2592aa444286e4c29fdaf2df9d14631baf9dc798f5ea8d023f541c1556feff18752c079012d896267727ed1dc03ff66cdf2817a5e3608bb9875cf94b7f1e9cc5b709279d4fd8374d2d08a3398e1b147f601f228d138013110bd10048079e74aaf6068e80c48cfb0c7bad488bd6c72537f464c78c73553ec8055f8e15cfe401e0617c891f0d12a702fd4b56b3b0efe2dbeb9e550db6bf6b12c32d58f0a2e5eca664bf40d1d06e5b6f36a9b0a1bee217f1dd3c3a98df8b97dccf68df8b5cf53b14913754662bae7061a484034ecedcb8a7c4eabcdb3cdb7031cccb4c228bdcbe1562a3d777a657e3ffc3da62f9d403b3c9b80d88af07c16675921c2d625ab340bb865cc3615c48aa59cc95b933d4019f8d60a38dfbd13be954bbc9a4b67107637e057903df967fee95d4be919877423e0e334d663b00c6fa3980b963a728732e9957a4268d0914d29d22b3b8ec8ecd9d57f2b8fa15a9387c3d12e7efcb6bb4100addfcc1dc173b6315537d6067a1752b1b7e60753803eb7b5c0038952539ed09a1b45a7467d65ddb7193630ab1fd290d74856465759f1b48e3bbb8e4e7fa0ed34f67025b0e8dfca3335f63318b7728233382aa9d384934308225f57b298994d4a7007e1043a11cf52b1f799f57dfbed03b0226f4281921ea9d62eeaa9b7ec01b0ff2964ad9b21cd02482fa079925bdd6404f72c985ef4ab5191ca83166ce465612a97465220a0f299318a9790c8a8e8cc3027bcf513dabb16216ce6ba4bbd197b13d0483c3e121ac027faac6554743a3e88b8b9603bf8744b1832be4c884efdb45bf28280b0b8eff10ad367885fb02ecfd56948043a39d186303279fb22c98da40b12d0b1741c29bebbbae66aaf5fe37ccd0209f12ee22e320f6b5e13b93b410e4a3fde1b1dde9cf37bbdb32944f3dedfe2f4036f3b9481358c0cf8cfd2222d0b1f5c0a0102710fb522563a44d3b73bc7d9606ab2df176ea3195d4086db15060405d07f7374def0c0eb774ac529cf53f7d98badf7868e39783a5cfdde40e35d7428ae4500306ba4ae653d92bfe9355a6ecad88f6fe39b086b66e0920cdf0e670faafb7e598a94d631de4f72ff36c3c77975e2120b27a96c842de4ca0719a77cd7fabd296f37ea211f3f5a1e89039759ba86a2e31dd702a5244c45d117173a4347e41dd150486a2c58ab4a0d117c98efffc036f48db6cc6a16437e801a5824bb9db8d22d098a36c9c49fae5c96647a24dd0aa4d573ed465ed18d278f546ea4ac9b1f005a8964c77951db9473b0e6751e50642b86ba32110d8fc4aad4443eb646e0451c484c101cd9ca083d8c08a663d482da05850f7b528523841e7b2b9e32940e32a24a17052bf219e18026a725b76345fc33f002c6eb9bf760641b41198b229d00ec18a15d9f1327c327f5ea4d4289ad6cc343d98986527d503b7d2c8ca253d15dcc75c4820e282b1249d02fd46e0f6f412c7e7c3ecda74c7c61f60de86fdfe92d231e4f8856feb2eddeb298efe653abd70dbc90633c6868477ce61e440afb0dc270bab6cecc1d53531dbe14b56335874c6d6ee7cfb507b9cbfeb09249cbdc490d81f2f33ef0b70ca8d18af1d785b284fd8cacba8b6452b80aab580f63e5d9438bc9843accbcb84a1652b8cd1df17f730b0f69c08940f920fa210dfd79f7c34a0f2433c7be3d039a6ecd22a5f58f26c9ebe139ea49a0e02cacc414365ace20324f3bb308fdfb1ca55b055c777498cf5676de6a85432d74fae9d044b0e5b11a7750cbeb4624b37fc78f8e51eccbe8a319f3e9178ce86950b82a7fd176ba536d3c000279eb5424ac1334293eb679119588cd83f51909399de23c1da495a439d2aae85b69ebd2afc5603409fc60ab698a82efa3b0ca969e2cd95ccabd05c7f7ebdd1ba36e8ee07d4e3caa41dd1af9d9d6f1cb4d81e6563fc801b60ceca2d6d1cd1e5e7fff49e14ac4de3bff0815a86ad12f2aa68fc39e63b4d645f365283183c1f13503edd096a5dbac21c75ef7c07ae3e17f2af5f7e00cff055a7911758b98a57572fc2c247fb2d0d5ee2b4710c469775654cb67b935ccb76c9bbcd6e726170ef449182d28e4263adcea9ed9a92c189baa0bc25b64be904e17d30afd9bcc4e24239312975310d67ca97f308131078813263ec6e8aba9b2d45e1301b09b167730ba42623e9f9bb98135ed1e64bbbefb2b1aa9a9ed742fb0109db05b23ce6236a519fc993cd041826119b016366edceb4be4f86c434ddff46fd60669a05bd8d558ef57bab10d021a9daccb30e45d1b253edeadc738bf782268314fd749dd0cab78ab64932ce926f69b935d13f4769e1bcae43bc223b90acbc0989213628e2b5722de97039fdc5beae65fbbcc67176e37447f1e9a16ff0801a57aa7750129564cb509e49e854053ab3d30673ce3ee519dc7cafbf98642041741ea982b247e4fbf27582f31ef419b808f217aa3b706c953cf35fe965df13e37af6391828078e0b7736db810f47ba42d9aa7693da4f0d7c6f5fc9e6d932906795b770aadaf315c7c2671c37e0202e7529bd0cfd54b6cb66cab23b28d893880ab42295087769af4dcce581b429ea0aa496c771b251960e454bf0d938ce026f0163860321bcb8a1bd5e7904fad2066514aff1c3bd179b94d35307da713548bf20b1a5a2d973fe32a69535a363ebf3b6d01bb3c39adbb5720db5b8c3abecdb6538313822464e4a0f53bab4ea50fdd5da60656daee525b58add5a34bde9a699456b676f59c1e579a21d39520f92c2a99b9eeb8ddc0c8474d3ce564bccb00a630bb59da498c1698edad70dca9e77953d75b652ea33152eb57ec0f783fd01e8ee43d03b2799314ba2a533bdce1665682436168f94cc649aef4dd62b872e22b2116914f561f382d466d956f3f0b9946188d1a8e4dbe2c16d14d3c8e0c32680026acffe8b6181fb3247496ecbd2c215ffeb991af04617f075207779dc2ccb258992abeadbe131195511e34971668baa1dd075f263255fb2cc395e8b9c854dbe414afeb614e16f2243984912b6fc3e2f3650ae96d46b46067d0747988e6ac4445f759f9835f1953107597c06c824c2b9c6ed4f5199ecd36c94e14e2317d81e5ef50b5a98eebec9a5485bc922ddbadbca40d4db7ff9a15968c8cc3a5a3f55fe2f3bf4cfd7c773c33738070b4f1f1407b2cb6c6267115921b43e919e2de44cf77bcedb6d35ad646d644cac5425589fba96d1d9bb16f162c192a999fb82e5c6c8ea52bfb5898b5354edfaaa5ac011912bafb633ed5c23cbffadfd9c7cec1fc6768f9f7792de1927dd88572642c50926037647f8403906f66ad6e18a0973348b874d2c769b625028e80ce393e1520f9d955a085dd5ed2069cbf5c00c049c7950188bff788037ba0acdc34fc65e2088ddcf9e96f8eb2720b3f7d2624ab758aa396d30dc19e4a4dbcda724e280458ef65784e3781d812d5af25f8aef063c9e5e62576b8dd39fbad0ad1a491678c7c37079e339d88c520532c5cb24d582a1f686f9fbe23136f9b600d43c7574584731d865018c182d151a85f9fef02c4821fa7f9183f99559262b8303198a98591f3ec3478c2e65b383bbc15292195ab2bf976825fc268bce54e9ef28519c8f1acaf5c65373020e904e264f928b6fb22001f5abe4ce2261a563129357ffed58c4f3fb34a57846ac096d401b5c9a6a307cb511ae495dadcda25ad71c6b162620224701b484d034b869290f10cc4b7e686f9248d69c9000536051240fe99b3b973403740e0a56b7d19df3d4c11d0dd9e969074c20122b85bb24cd5a1b08764b5110c17f7cf789498961a3ef250d2806449cb614cf647d7a44ca443c5a8b12757d5b9021d0b92c71003f7ce7e09b7b2c8cce0f5758621fe0a0039490393c06ba68eca0f568e89a2e1fb9363247f4b0838f6f4e60f9e32cf9e4998f7d8784e79f3431395fb60b307251f6fc765e0bf5b557d5448e3c1be293669fe35d31b5d7b6b774bbfd922fca7856bd734b51ffc6cafcd93a318e757ea761d9ef8ec4d9eac0c61627ae11e08ffc73b6204cd47870d6cdd27b77f1e55d8fc5449575aefb63821825884a4475a6b3bd21b7700ee79a12ba74064e712e9f2eb3158cb54466e95428036fb6088150f8f2b0c310d2314149479d4f4031b8a761090575eff7b939dcdff5288b831b5bed00c70fa1e0d64e3a697a07b098f487b6c413e8f7462f00162e0b653d0608c7fd19dbeb1b3f79e106dc3fad5bc2ef8820d944e6a30a4f2656c92fb45f9c2eaa5a38c755afb1f0ed0e68a306bcfcc490bd1dbaaae2ce0b60033a7dafdb8ade78af156f018dd9b75288d80d5335a99e74cea588a8809042a43b5a9f256b5981f55e171783aca65ca3450eb81191487f88a84904db2d1022b4d1638008006a546d1ac8eff764c9a2bea5dce9b42aa8374e4ff5c5a67765099e38224df738e204c43e295398d6a7997c94538570d3145014443cfe421e782205abb795566b2e76a6767d14996127399b0c5ae34ddd429110efcbd20e1106bcb68151f4415e8ef26945b1c4bc74c7b83d63fc675895d0562bc116cf1852538ce87f809e38064d81113c1d00758dc31f3c9ec552d2595619b39a31939803d0aadb7b978acfb28eb6ad6317324ef17d4e9c8ade6812b4c0250f2c1af3e9a007b2ef0deb7ea7c34824d8be3ff421dd6a0a2d3d4494ffdbf4e8e1ebb300cff7571e76eedf52feb6da329023a2a0c6fc3bce628af6f1566401e98cad337585f7756547364488b5b04f1ee102814a62af47c491d63b6f34eff69c8819bbdd68f52474bc268c5e5e1f28f355221b452f43ca65994e74ae2587b306142e70b16fa950ec69ce911818f9f1e7a795309fea071bdd7178984e6628a456f6deb2f6974af3f14c7ac099461ebe9a13092be77c7de96af2c4aa32cd3888f1807c8161b6618aa7df986fd4eb2c7aee5b3a39eeb455b5de15092d99e7c22ab47b05cb2afb9a45bd69b22b2160ee1cc00b85b55b0bb0a61271f28cc845cf4e28c191f67853fb2539ab310013a5a4b34bca30b7158b926e2287023e531ccd837bcedfe0dc748baf6b323b6e5e482a04446c613c783991368eea4c3b8985d4f5e40e5035f987ff8107347937e9c51c26f1443ecb12225cd1cfb823e6ac5cda43cdf2d339158ab59f500f61858c96d0de26553b3d5a2dd4b41d24589c14857c0e8bcd9d4b530d1427729fd0ea0f2b918a0733599e7bae188310c4cbd8ed18baebbb73e3bad531d6ddefd631993720c2588b4110c941cafccd1eb4577e7110a76ac44da5b17eaf5648f8a282f0ee485a27f03021241216aa321cb549684e048d2ee8b978f74e46b7ff228fecaefb9fce8b35f2d5466f32dd41bca08454d9c1e9692d58bfb8bbf1483364440e9648540bc83919a85f18fc9d16bf3b6f4b7e0010696eab8ca921260da9a667ca74c5ef713bf46e5e33f82d443961cdfffe889087cb9ceb965b3ba1f9e4debf110afdf13b8944d6b58837d27e279d2a3e644d45f9e65dd9cc76edd2ffced1e3f60e61df4bb233acfd02f72fc01d12a9a417a626c3e297b243641c18e60fcdc4f83ce2a1b748c2d12791fa91130eb4628b8db381eb15519214bb45f5fe4ef4dbbb79aa84a40af01aa3515880a59ca3539e0a5b2e08884495f8265b0a98e9dfb1ac5aa7e52da779b5ef5c115e3fd49ae14d8e6683b02d7eb97f5c4d6281a34c3dbd32d76c9c12d0f853458ecaa1ff0eef4404ab6fad2ace6405100d07131fa157158eca01bc554c9c24c98ebda9cb0c64bd6eaaec067df0f7e2b44de493154234acf977ac89f2160a608d933d927156495853a2fb3cc7db7e9ca8567ec3a7da029d8da74fc1225137c80687ce2718de0672f7e9cfcc471cb860703082a2f420d03e8dc79599b27e1a716dfe5ec855e1012e29c85568973f1b0e23a7231217ca37b6efc6b55e27b86563fd2c988ac76fada2b1bac1cee4654cf3d46e9ae536159c0f087efd59ddc84e0012cad0e22eb502f929cef38ec2e11cb2d9ac64ebd46ac5acb9bd471e3953692011ae7d16eff6dc5677a9323df7f7a3fd0c869ad0ce6f3d41a62eb2897131db97958440d9799e142fb1cb9474f949d6c60c64a510e8df6ffe41c1c5eedff2adbd33a47125d48d2b0025e60a619488b76f9a549f67dd6f63026df6463613f10c709d20490ae9b53923b37f7bcb406312d80dd3bb8399028ad363108c14fe70062078f816abd2e49c67ee44ddd422d6dadb9e1abb0545d6e998452aa94eef3d85986be1c3df42e8e5b7b59f5d7922846fad0178675454cf11fa557abaa13834e8b7513edfdf618da44f43abbcb059fc6f9ab97e22daeb5753cc113d17a17ccc140d8cd0f5e9c26c42ecd69e528bc2317e4e75a1c1618aa259682e22288da9ae9e36bc796d6a54fbc7d461ba37b491be66864c11ea2e540bb30dd2988a670dd3c755c6d9f40f9928ee7fb53cdbe68db172222ee8f51ced60b87935ca2fc91b74705f1aa901e78cd987036aa9cae3f280c5e3aaacfc06427c4b79ee9831e9af95b757f58ba247d40ffbb73478390540902513af223ce0efdade7ddecc205fbd84532a5516b68595eb5eb1cbd08faa2e8f0598e0c69c7de6ce9d08605b3b3589c6529625120ad2fae5eedb3ab3d144fc6e4312d918bd309e2e9db79a612055f9214853312e68aac79b5617c7bd7a8dd5c18845d5950af52145ba9956ed29243877314cdb9dc2da6442c20bc379d3da6d9a78b99a887a5bc9f052f0808fe262fbd8f9723078adcf24d1147d4cf2cead2904851b232f869bd8cd3e3355fad4e03c0326c2136cde71d3603a842caa63e75d3c20bf7c4e183fa939aadcd88e7677e43bf79bccefa77c68ad88570fbd5187e6bbdc00177e77ea48c9b259c1e0afbabbad11b2b7d2fc05fd98fc0fd11df52c178ad801e1f1d303c0bf09abfdbfaa755d5ff6e59bf69bcae031d3c124b416b9e9a3a3c5b882980351cc85788518996f84dce3093d5574ead55c0b8612aa3cd88edb9fe7f2251f1a871ab080c6312ddfb4fdfa7d91ba244881544b69c42fc734ccc4b656571e71b3f2f8436ee30923521305707419d134fce9aa5c508d815272898bdb45190a985bff0580855d8b0f4922c7d1eeb6b958b16d10903b93b67cee28362f3f90a432dc3d9fd82447367ddc6fe211e3ebdf15967abd778c5989ffc47abda6653f74133ed7025acd8ede528d88a5b3a52c33d9ed781ee167f03821bf709029b4f549bed24aeb853de004cfc7bbba9aab2bbe04ce490d147ef0fcc140b7704380b594904fd636303c1d252b628c6111c4b31af035759a8a33f531465613514f8b74ad38c973121a5740fef5ec12e0565718379b9a508c83128d328b20713b1e42e56fbe8313ebff8a0b8c17f5594764c420a485e836c467cdc1644438ed7af13f7c5cbd56b9e1e9d60ec26bcae069c86636b9b5e0491d50c50fd8c545a0cf3d95527f1c8287efae6582ad5115ba9dd442105058278f290677fac54cd5739d3fe6bd2945d657a6328d2793ae39abff05cb2c31a92fe71a156de3c5e4f2eb7c70828a209e84a08f2641f244c97f699299cfe3978f1677c19e35c348df9dbb1868d1d267463d65733c414804df4b19faad524a989a81d9a17c47f69a1b1338accdd1412732e4ea73c419d30519d2697134d1a00fa30f89210668aa9c2c09c42c8bf9b9273c36e39d3bb7706154c7fd2d63cf6cea272d836e273977874e627a139c1e5fcda21142ae79ee4794c8554c9f42908c112bd48c7015af4136094224d4916e57fa8ed466c4853eb6ce5133688883f8654212f554f519106acf2bd5c38843f5511bc3447d39fc89f7241b32d8a30c929247357375dbee0919648e4d3e819721bd18aca629cbed9008fbd9a9fcc8c0124430a750df35a252c67a30425c925d1a9bb0e75a1521dcb5d2e5fc3b01ad3da43bfe740c37aaa9a2c2bcd89a9b15fb3283458942d3706b93151fc93cd7975dccd103984cc4d4cd084ad48661ff19c9a32fa7675df3b99bc9aeb911a0de2bedd203b9ef35b1e44f89101b78a6d568ea2c84324a6bd04fc568d5cfeb34fd3678fbd3a895b886839a5121704332139585fa1e01956a24fd83b4873622a9f75d0ceb04fafaa098b01a54c8e34d9c8832986b7896d06788699246e88f3149b870463d661123335de1c256611a43013296f16c33f9dd49cdc55cc1175593c265bc7c4dd4b8d177ba7e479cfd723f2f2750da91edfc7b96f87aad1d0091ef568872a562e39fd4d1641446acb9cd113df1d9c424c0ee48d3f08011c274409e576cfd9c7407c21a7713f692eca24b2840e9300409e5ccb00442a0332800689e04cf073149125e4c4979bc8c1553c64acb4b3208d5ec903451562c5f9f0fa548a752510b7ea7c7410315c6a950be30480be645fa7266f7c2009e4b1798845430f61777d9ce5288ddc33593928dfa8bf99b205e8b72cb742cffedc7ecef365ac7c0937b188a0bee8103e56c675478d1af98b24df896516b7d1aa5d45e892a392a7e689b2c33bd3c9445bbf3b909d5ca42a17dbe18c57bf3e92dc39dabc199f014a4caa6c1720100ba963eaf832177e511ac3a33ace10d66b68e5902d233eff65ba14da2778d6d4f8697660cea743ebcdfe68b971166f960dae0c62c1846f1b62a0ac3e68d3d20c736c74be16f1b3271d9cc8708fda69d6c110d40442848ddd2e7cf431ebb175bae7d5ca374ab0382b5cc7243e5a015dfd2ffe47d7ae418756fe719dcb813494187c9ecb44e183747289028e00cd30ade2d43939c8e7f96c98756bd5cb1787d9e3ac26ee76848935012e86c162e22c9aae1ba697a642a1d3c864410be4b26722c4fe8945f1aaa535ad3ba4bd740a3cb1ecc65b69653a38fdf5808f999ba383a0e8df9376f4bd616198d7a4708170140733c18b53eba638f2ab2a1facf7b3d7c62ec0f8dcd0926775ee190a2fe53f18dd931c4ab2d112d82ba18c4d93f1685e2d75f6f0d205c79a7a789408359da76b0f0616e7bd1cd2785f2610c586b37198f22189407deaa58b142271f089d78a2f85f724ff56c770e734781582f77382662888965f746e1b2665fe3c7f4f8b91e7f9c44e76a1017156b46c20af1826c11ae98d54b9cf623d905673d211a0b44a0215b46e68e52bdef399f173294beb5447274468d853aedb69065ac5afdb57c4cc0104a5bc2cf3755c9b107ec4839bf2ccb4b068b6f7668b7f16d4bd2a041b7cc62422bb46f8df713c58f80130e4f0de7e9e9ee253e16fbdb1e9d87a34a85b3f9301643cc7dcc13439ad573b2da2d73ff6dd41aa997540552e4af945c1b3ad9ba39082a55e1a51bf57c1604709c993bf36c3468d1e0d4ad177ac4cbc7527fbde8c371a6dc20a43401b0a6543b1128c8c451a44f5a02159ae3874c50295e1c4e4981740be09af758a5d3ebfdb9bdec9f62cccd5ef0e5b6c13069b1263f5c800f1ef336430e1d126b4eaf163156c5d0531bda64d73bcfb0b62e550e5ed0d94cfdaac2ecd3f8a3885b41acb09f4e3c0ed3300f16f687c7dc318f13c1e642da625b9a4d0bda576200fb72ad66e48fb657672b8c23cf5cf3d42c9b955089b8fddd1ee363dae984432cec662e1d41c41c12f287564262f55ce5fd4d139f80820b029738acfb5f371700b4a88b0d3a0942488600e844f170c4757dad1a2cd64bcd17cadd008eb9e55052879ddf207c7494573ef7d47b6298fe68aa9461c17d3cf40375a79021d6b648c70bee71127cc1240f4e0c918545ba610ff8eb30ea7586caa67e0acedeecb8b2907d9d5ca2b4e5cee2195137f6060b86547b3d401bdd4b23b802e6598f97b620a55e3285a9a46533e594e5cba6829470980fbd126072606efa681be5b6c023a7f5244146c57c83b4dc5252a0cfc4114729b6d5545b312c289a3e4e46f2beead6add5ebcbe6d12e053a3f976579dff54e82a0c228de4566000343a27767f1a873e104ac8f3efeb543cc7b1e6a5bdee1fc6d44d60900c9c6f8604d1d9cd18a683c9f0a5ab7c026d28f371782f2807b931ca9a1ae5cec0b41aba6d8f370560a9dc4d92ac12661784b37e7c540c281a8441927adbcdc23cf3b9b5c3cac67ce4e88a2bde8c59cafe8d513fb61bd099260322cc8b2c22fd521a6dec21800829013984470ee6e5c72eeb8aa8efff37f531259fcebc38f426a20f78e9472c2ade4cfe59bfd02d5f22feb9341474d652f2b16c836aee4a069637d97290f7b8dba147438926d34a10a86d655b0473fca178f78b067a321e9097bd89f277fd733187bbf895822825590901e3825be62271e15f3099447ee4eda5ab65297e07ea096c60700e6358961d185cefcb0105937a4e4052e3c3f8cf4dfb7785f5d0b03689d5b37e56ae25a2fb25379e468eb895294bde5adbcd3f61e93d4feb4de0c4bc20a0dc6a62d49d22888a62b8ce34352 封印!","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://kaizynx.github.io/categories/NOIP/"}],"tags":[],"keywords":[{"name":"NOIP","slug":"NOIP","permalink":"http://kaizynx.github.io/categories/NOIP/"}]},{"title":"ACM模板","slug":"template","date":"2018-11-03T23:00:00.000Z","updated":"2022-04-10T07:52:45.155Z","comments":true,"path":"2018/11/04/template/","link":"","permalink":"http://kaizynx.github.io/2018/11/04/template/","excerpt":"前言 代码 while (true) ++++++ ++++++ ++++++ RP;","text":"前言 代码 while (true) ++++++ ++++++ ++++++ RP; 杂项快读快写 代码 template &lt;typename T&gt; inline void read(T &amp;x) { int c; T tag = 1; while(!isdigit((c=getchar()))) if(c == '-') tag = -1; x = c-'0'; while(isdigit((c=getchar()))) x = (x&lt;&lt;1)+(x&lt;&lt;3) + c-'0'; x *= tag; } template &lt;typename T&gt; void write(T x) { if(x &lt; 0) x = -x, putchar('-'); if(x &gt; 9) write(x/10); putchar(x%10+'0'); } 代码 ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); 巨佬模板 代码 struct Scanner { FILE* fp = nullptr; char line[(1 &lt;&lt; 15) + 1]; size_t st = 0, ed = 0; void reread() { memmove(line, line + st, ed - st); ed -= st; st = 0; ed += fread(line + ed, 1, (1 &lt;&lt; 15) - ed, fp); line[ed] = '\\0'; } bool succ() { while (true) { if (st == ed) { reread(); if (st == ed) return false; } while (st != ed &amp;&amp; isspace(line[st])) st++; if (st != ed) break; } if (ed - st &lt;= 50) reread(); return true; } template &lt;class T, enable_if_t&lt;is_same&lt;T, string&gt;::value, int&gt; = 0&gt; bool read_single(T&amp; ref) { if (!succ()) return false; while (true) { size_t sz = 0; while (st + sz &lt; ed &amp;&amp; !isspace(line[st + sz])) sz++; ref.append(line + st, sz); st += sz; if (!sz || st != ed) break; reread(); } return true; } template &lt;class T, enable_if_t&lt;is_integral&lt;T&gt;::value, int&gt; = 0&gt; bool read_single(T&amp; ref) { if (!succ()) return false; bool neg = false; if (line[st] == '-') { neg = true; st++; } ref = T(0); while (isdigit(line[st])) { ref = 10 * ref + (line[st++] - '0'); } if (neg) ref = -ref; return true; } template &lt;class T&gt; bool read_single(V&lt;T&gt;&amp; ref) { for (auto&amp; d : ref) { if (!read_single(d)) return false; } return true; } void read() {} template &lt;class H, class... T&gt; void read(H&amp; h, T&amp;... t) { bool f = read_single(h); assert(f); read(t...); } Scanner(FILE* _fp) : fp(_fp) {} }; struct Printer { public: template &lt;bool F = false&gt; void write() {} template &lt;bool F = false, class H, class... T&gt; void write(const H&amp; h, const T&amp;... t) { if (F) write_single(' '); write_single(h); write&lt;true&gt;(t...); } template &lt;class... T&gt; void writeln(const T&amp;... t) { write(t...); write_single('\\n'); } Printer(FILE* _fp) : fp(_fp) {} ~Printer() { flush(); } private: static constexpr size_t SIZE = 1 &lt;&lt; 15; FILE* fp; char line[SIZE], small[50]; size_t pos = 0; void flush() { fwrite(line, 1, pos, fp); pos = 0; } void write_single(const char&amp; val) { if (pos == SIZE) flush(); line[pos++] = val; } template &lt;class T, enable_if_t&lt;is_integral&lt;T&gt;::value, int&gt; = 0&gt; void write_single(T val) { if (pos &gt; (1 &lt;&lt; 15) - 50) flush(); if (val == 0) { write_single('0'); return; } if (val &lt; 0) { write_single('-'); val = -val; // todo min } size_t len = 0; while (val) { small[len++] = char('0' + (val % 10)); val /= 10; } for (size_t i = 0; i &lt; len; i++) { line[pos + i] = small[len - 1 - i]; } pos += len; } void write_single(const string&amp; s) { for (char c : s) write_single(c); } void write_single(const char* s) { size_t len = strlen(s); for (size_t i = 0; i &lt; len; i++) write_single(s[i]); } template &lt;class T&gt; void write_single(const V&lt;T&gt;&amp; val) { auto n = val.size(); for (size_t i = 0; i &lt; n; i++) { if (i) write_single(' '); write_single(val[i]); } } }; Scanner sc = Scanner(stdin); Printer pr = Printer(stdout); 玄学优化|卡常吸氧,吸臭氧 代码 #pragma GCC optimize(\"Ofast,no-stack-protector\") #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\") 正则表达式 代码 char str[]; scanf(\"%3s\", str); // 读取长度为n的字符串 scanf(\"%[abc]\", str); // 读取a,b,c,读到之外的立即停止 scanf(\"%[a-z0-9]\", str); // 同上,读取小写字母和数字 scanf(\"%*[a-z]%s\", str); // 过滤掉小写字母读取 scanf(\"%[^a-z]\", str); // 读取小写字符外字符,^表示非 scanf(\"%*c\"); //清理输入缓冲区中第一个字符，也就是上次遗留下的\\n scanf(\"%[^\\n]%*c\",str); // 相当于gets(str), %*c的作用是吸收\\n 随机数 代码 #include &lt;random&gt; // 范围 unsigned int mt19937 rnd(time(NULL)); mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count()); cout &lt;&lt; rnd() &lt;&lt; endl; std::random_device rd; //获取随机数种子 std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd() std::uniform_int_distribution&lt;&gt; dis(0, 9); std::cout &lt;&lt; dis(gen) &lt;&lt; endl; inline ull xorshift128(){ static U SX=335634763,SY=873658265,SZ=192849106,SW=746126501; U t=SX^(SX&lt;&lt;11); SX=SY; SY=SZ; SZ=SW; return SW=SW^(SW&gt;&gt;19)^t^(t&gt;&gt;8); } inline ull myrand(){return (xorshift128()&lt;&lt;32)^xorshift128();} 哈希双哈希,好多哈希,题目链接 代码 struct HashNumber { static const int HN = 2; int a[HN], mod[HN] = {25165843, 50331653}; HashNumber() { memset(a, 0, sizeof a); } template &lt;typename U&gt; HashNumber(const U &amp;x) { for (int i = 0; i &lt; HN; ++i) a[i] = x%mod[i]; } friend bool operator ==(const HashNumber &amp;lhs, const HashNumber &amp;rhs) { for (int i = 0; i &lt; HN; ++i) if (lhs.a[i] != rhs.a[i]) return false; return true; } friend bool operator !=(const HashNumber &amp;lhs, const HashNumber &amp;rhs) { return !(lhs == rhs); } HashNumber&amp; operator +=(const HashNumber &amp;hs) { for (int i = 0; i &lt; HN; ++i) (a[i] += hs.a[i]) %= mod[i]; return *this; } HashNumber&amp; operator *=(const HashNumber &amp;hs) { for (int i = 0; i &lt; HN; ++i) a[i] = (1ll*a[i]*hs.a[i])%mod[i]; return *this; } friend HashNumber operator +(const HashNumber &amp;lhs, const HashNumber &amp;rhs) { HashNumber res = lhs; return res += rhs; } friend HashNumber operator *(const HashNumber &amp;lhs, const HashNumber &amp;rhs) { HashNumber res = lhs; return res *= rhs; } }; 计算log2 代码 #define log(x) (31-__builtin_clz(x)) // #define log(x) (63-__builtin_clzll(x)) // lg2[i] = lg2(i) +1 for(int i = 1; i &lt;= n; ++i) lg2[i] = lg2[i&gt;&gt;1]+1; // lg2[i] = (int)log2(i) for(int i = 2; i &lt;= n; ++i) lg2[i] = lg2[i&gt;&gt;1]+1; 快速开根号|牛顿迭代法 代码 double sqrt(const double &amp;a) { double x = a, y = .0; while (abs(x-y) &gt; err) { y = x; x = .5*(x+a/x); } return x; } i/k == j 的 k 的个数 代码 for (int i = 1; i &lt;= n; ++i) { for (int j = 1, l, r; j &lt;= n; ++j) { l = max(1, i/(j+1)); while (l-1 &gt;= 1 &amp;&amp; i/(l-1) == j) --l; while (i/l &gt; j) ++l; r = i/j; while (r+1 &lt;= i &amp;&amp; i/(r+1) == j) ++r; while (i/r &lt; j) --r; if (r-l+1 != i/j-i/(j+1)) { cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl; } } } 三分法示例为凹函数 代码 while (l &lt; r) { int mid = (l+r)&gt;&gt;1; if (f(mid) &lt; f(mid+1)) r = mid; else l = mid+1; } while(r-l&gt;5){ int ml=(l+l+r)/3; int mr=(l+r+r)/3; if(f(ml)&lt;f(mr))r=mr; else l=ml; } for (int i = l; i &lt;= r; ++i) res = min(res, f(i)); while (r-l &gt; eps) { double ml = l+(r-l)/3, mr = r-(r-l)/3; if (f(ml) &lt; f(mr)) r = mr; else l = ml; } 三维偏序|CDQ分治 代码 void cdq(int l, int r) { if (l &gt;= r) return; int mid = (l+r)&gt;&gt;1, i = l, j = mid+1; cdq(l, mid); cdq(mid+1, r); for (int k = l; k &lt;= r; ++k) { if (j &gt; r || (i &lt;= mid &amp;&amp; a[i].y &lt;= a[j].y)) { tree.add(a[i].z, a[i].w); b[k] = a[i++]; } else { a[j].f += tree.query(a[j].z); b[k] = a[j++]; } } for (int k = l; k &lt;= mid; ++k) tree.add(a[k].z, -a[k].w); for (int k = l; k &lt;= r; ++k) a[k] = b[k]; } 四维偏序CDQ套CDQ 第一维在第一层CDQ合并时标记左右区间 合并后第二维有序,进入第二层CDQ 此时按照正常CDQ合并第三维,用数据结构统计第四维 只有标记左区间的加入数据结构,标记右边区间的更新答案 代码 void cdq(int l, int r) { cdq(l, mid); cdq(mid+1, r); } void CDQ(int l, int r) { CDQ(l, mid); CDQ(mid+1, r); // ... cdq(l, r); } 某区间操作问题每次操作可以使一个区间+1(或-1),使得序列为0的操作次数下界 $\\frac{\\sum\\limits_{i=1}^{n+1}\\lvert a_i-a_{i-1} \\rvert}{2}$ 分数规划分数规划用来求一个分式的极值。 形象一点就是，给出 $a_i$ 和 $b_i$，求一组 $w_i\\in{0,1}$，最小化或最大化 $$ \\displaystyle\\frac{\\sum\\limits_{i=1}^na_i\\times w_i}{\\sum\\limits_{i=1}^nb_i\\times w_i} $$ 每种物品有两个权值 $a$ 和 $b$，选出若干个物品使得 $\\displaystyle\\frac{\\sum a}{\\sum b}$ 最小/最大。 例如代价为 平均值 或 乘积开个数次根(取ln) 分数规划问题的通用方法是二分。 假设我们要求最大值。二分一个答案 $mid$，然后推式子（为了方便少写了上下界）： $$\\displaystyle\\begin{aligned}&amp;\\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i}&gt;mid\\\\Longrightarrow&amp;\\sum a_i\\times w_i-mid\\times \\sum b_i\\cdot w_i&gt;0\\\\Longrightarrow&amp;\\sum w_i\\times(a_i-mid\\times b_i)&gt;0 \\end{aligned}$$ 那么只要求出不等号左边的式子的最大值就行了。如果最大值比 $0$ 要大，说明 $mid$ 是可行的，否则不可行。 计算几何向量 坐标 直线 圆 (结构体) 代码 struct Point { typedef double T; T x, y; int id; Point(){} Point(const T &amp;_x, const T &amp;_y, const int &amp;_i = 0) : x(_x), y(_y), id(_i) {} friend Point operator + (const Point &amp;p1, const Point &amp;p2) { return Point(p1.x+p2.x, p1.y+p2.y, p1.id); } friend Point operator - (const Point &amp;p1, const Point &amp;p2) { return Point(p1.x-p2.x, p1.y-p2.y, p1.id); } friend Point operator - (const Point &amp;p) { return Point(-p.x, -p.y, p.id); } // a*b b在a的顺负逆正 friend T operator * (const Point &amp;p1, const Point &amp;p2) { return p1.x*p2.y-p1.y*p2.x; } template &lt;typename TT&gt; friend Point operator / (const Point &amp;p, const TT &amp;k) { return Point(p.x/k, p.y/k, p.id); } template &lt;typename TT&gt; friend Point operator * (const Point &amp;p, const TT &amp;k) { return Point(p.x*k, p.y*k, p.id); } Point operator += (const Point &amp;p) { return *this = *this+p; } Point operator -= (const Point &amp;p) { return *this = *this+p; } template &lt;typename TT&gt; Point operator *= (const TT &amp;k) { return *this = *this*k; } template &lt;typename TT&gt; Point operator /= (const TT &amp;k) { return *this = *this/k; } friend bool operator &lt; (const Point &amp;p1, const Point &amp;p2) { return make_pair(p1.x, p1.y) &lt; make_pair(p2.x, p2.y); } friend bool operator &gt; (const Point &amp;p1, const Point &amp;p2) { return make_pair(p1.x, p1.y) &gt; make_pair(p2.x, p2.y); } friend bool operator == (const Point &amp;p1, const Point &amp;p2) { return p1.x == p2.x &amp;&amp; p1.y == p2.y; } friend bool operator != (const Point &amp;p1, const Point &amp;p2) { return p1.x != p2.x || p1.y != p2.y; } friend istream&amp; operator &gt;&gt; (istream &amp;is, Point &amp;p) { return is &gt;&gt; p.x &gt;&gt; p.y; } friend ostream&amp; operator &lt;&lt; (ostream &amp;os, Point &amp;p) { return os &lt;&lt; p.x &lt;&lt; \" \" &lt;&lt; p.y &lt;&lt; \" \" &lt;&lt; p.id &lt;&lt; endl; } double length() { return sqrt(1.0*x*x+1.0*y*y); } friend double dis(const Point &amp;p1, const Point &amp;p2) { return (p2-p1).length(); } double dis(const Point &amp;p) { return (p-*this).length(); } friend T dot(const Point &amp;p1, const Point &amp;p2) { return p1.x*p2.x+p1.y*p2.y; } T dot(const Point &amp;p) { return x*p.x+y*p.y; } friend Point rotate_90_c(const Point &amp;p) { return Point(p.y, -p.x, p.id); } Point rotate_90_c() { return Point(y, -x, id); } friend double atan(const Point &amp;p) { return atan2(p.y, p.x); } }; template &lt;typename T = double&gt; struct Vec { // 三维向量 T x, y, z; Vec(const T &amp;_x = 0, const T &amp;_y = 0, const T &amp;_z = 0) : x(_x), y(_y), z(_z) {} double len() { return sqrt(1.0*x*x+1.0*y*y+1.0*z*z); } friend Vec operator +(const Vec &amp;v1, const Vec &amp;v2) { return Vec(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z); } friend Vec operator -(const Vec &amp;v1, const Vec &amp;v2) { return Vec(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z); } friend Vec operator *(const T &amp;k, const Vec &amp;v) { return Vec(k*v.x, k*v.y, k*v.z); } friend Vec operator *(const Vec &amp;v, const T &amp;k) { return k*v; } friend Vec operator *(const Vec &amp;v1, const Vec &amp;v2) { return Vec( v1.y*v2.z-v1.z*v2.y, v1.z*v2.x-v1.x*v2.z, v1.x*v2.y-v1.y*v2.x ); } friend T dot(const Vec &amp;v1, const Vec &amp;v2) { return v1.x*v2.x+v1.y*v2.y+v1.z*v2.z; } T dot(const Vec &amp;v) { return dot(*this, v); } Vec&amp; operator +=(const Vec &amp;v) { return *this = *this+v; } Vec&amp; operator -=(const Vec &amp;v) { return *this = *this-v; } Vec&amp; operator *=(const T &amp;k) { return *this = *this*k; } Vec&amp; operator *=(const Vec &amp;v) { return *this = *this*v; } friend istream&amp; operator &gt;&gt;(istream &amp;is, Vec &amp;v) { return is &gt;&gt; v.x &gt;&gt; v.y &gt;&gt; v.z; } }; inline bool polar_angle1(const Point &amp;p1, const Point &amp;p2) { double d1 = atan(p1), d2 = atan(p2); return d1 == d2 ? p1 &lt; p2 : d1 &lt; d2; } inline bool polar_angle2(const Point &amp;p1, const Point &amp;p2) { auto tmp = p1*p2; return tmp == 0 ? p1 &lt; p2 : tmp &gt; 0; } inline long long S(const Point &amp;p1, const Point &amp;p2, const Point &amp;p3) { return abs(p1.x*p2.y+p1.y*p3.x+p2.x*p3.y-p1.x*p3.y-p1.y*p2.x-p2.y*p3.x); } struct Line { Point p1, p2; Line(){} Line(const Point &amp;_p1, const Point &amp;_p2) : p1(_p1), p2(_p2) {} friend bool cross(const Line &amp;l1, const Line &amp;l2) { #define SJ1(x) max(l1.p1.x, l1.p2.x) &lt; min(l2.p1.x, l2.p2.x) || \\ max(l2.p1.x, l2.p2.x) &lt; min(l1.p1.x, l1.p2.x) if (SJ1(x) || SJ1(y)) return false; #undef SJ1 #define SJ2(a, b, c, d) ((a-b)*(a-c))*((a-b)*(a-d)) &lt;= 0 return SJ2(l1.p1, l1.p2, l2.p1, l2.p2) &amp;&amp; SJ2(l2.p1, l2.p2, l1.p1, l1.p2); #undef SJ2 } friend bool on_line(const Line &amp;l, const Point &amp;p) { return abs((l.p1-l.p2)*(l.p1-p)) &lt; eps; } friend Point cross_point(const Line &amp;l1, const Line &amp;l2) { Point v1 = l1.p2-l1.p1, v2 = l2.p2-l2.p1; if (abs(v1*v2) &lt; eps) return Point(0, 0); // no cross_point double t = (l2.p1-l1.p1)*v2/(v1*v2); return l1.p1+v1*t; } }; struct Circular { Point o; double r; Circular(){} Circular(const Point &amp;_o, const double &amp;_r) : o(_o), r(_r) {} template &lt;typename T&gt; Circular(const T &amp;_x, const T &amp;_y, const double &amp;_r) : o(Point(_x, _y)), r(_r) {} friend bool in_cir(const Circular &amp;c, const Point &amp;p) { return dis(c.o, p) &lt;= c.r; } bool in_cir(const Point &amp;p) { return dis(o, p) &lt;= r; } }; inline Circular get_cir(const Point &amp;p1, const Point &amp;p2, const Point &amp;p3) { Circular res; res.o = cross_point(Line((p1+p2)/2, (p1+p2)/2+(p2-p1).rotate_90_c()), Line((p1+p3)/2, (p1+p3)/2+(p3-p1).rotate_90_c())); res.r = dis(res.o, p1); return res; } 二维凸包 代码 int n; int stk[N], used[N], tp; Point p[N]; inline void Andrew() { memset(used, 0, sizeof used); sort(p+1, p+n+1); tp = 0; stk[++tp] = 1; for (int i = 2; i &lt;= n; ++i) { while (tp &gt;= 2 &amp;&amp; (p[stk[tp]]-p[stk[tp-1]])*(p[i]-p[stk[tp]]) &lt;= 0) used[stk[tp--]] = 0; used[i] = 1; stk[++tp] = i; } int tmp = tp; for (int i = n-1; i; --i) { if (used[i]) continue; while (tp &gt;= tmp &amp;&amp; (p[stk[tp]]-p[stk[tp-1]])*(p[i]-p[stk[tp]]) &lt;= 0) used[stk[tp--]] = 0; used[i] = 1; stk[++tp] = i; } } 平面最近点对 代码 Point a[N]; int n, ansa, ansb; double mindist; inline bool cmp_y(const Point &amp;p1, const Point &amp;p2) { return p1.y &lt; p2.y; } void upd_ans(const Point &amp;p1, const Point &amp;p2) { double dist = dis(p1, p2); if (dist &lt; mindist) mindist = dist, ansa = p1.id, ansb = p2.id; } void rec(int l, int r) { if (r-l &lt;= 3) { for (int i = l; i &lt; r; ++i) for (int j = i+1; j &lt;= r; ++j) upd_ans(a[i], a[j]); sort(a+l, a+r+1, cmp_y); return; } static Point t[N]; int m = (l+r)&gt;&gt;1, midx = a[m].x; rec(l, m); rec(m+1, r); merge(a+l, a+m+1, a+m+1, a+r+1, t, cmp_y); copy(t, t+r-l+1, a+l); int tsz = 0; for (int i = l; i &lt;= r; ++i) if (abs(a[i].x-midx) &lt;= mindist) { for (int j = tsz; j &amp;&amp; a[i].y-t[j].y &lt; mindist; --j) upd_ans(a[i], t[j]); t[++tsz] = a[i]; } } inline void mindist_pair() { sort(a+1, a+n+1); mindist = INF; rec(1, n); } 最小圆覆盖|随即增量法 代码 inline Circular RIA() { Circular cir; random_shuffle(a+1, a+n+1); for (int i = 1; i &lt;= n; ++i) { if (cir.in_cir(a[i])) continue; cir = Circular(a[i], 0); for (int j = 1; j &lt; i; ++j) { if (cir.in_cir(a[j])) continue; cir = Circular((a[i]+a[j])/2, dis(a[i], a[j])/2); for (int k = 1; k &lt; j; ++k) { if (cir.in_cir(a[k])) continue; cir = get_cir(a[i], a[j], a[k]); } } } return cir; } 数据结构堆 代码 struct Heap { static const int Maxn = 1e6+7; int sz, a[Maxn]; Heap() { sz = 0; memset(a, 0, sizeof a); } inline bool cmp(int x, int y) { return x &lt; y; } // 小根堆 inline int size() { return sz; } inline bool empty() { return sz == 0; } inline int top() { return a[1]; } inline void push(int x) { a[++sz] = x; swift_up(sz); } inline void pop() { swap(a[1], a[sz--]); swift_down(1); } inline void swift_up(int p) { while(p &gt; 1 &amp;&amp; cmp(a[p], a[p&gt;&gt;1])) // a[p] &lt; a[p&lt;&lt;1] swap(a[p], a[p&gt;&gt;1]), p &gt;&gt;= 1; } inline void swift_down(int p) { int l, r, s; while(true) { l = p&lt;&lt;1; r = p&lt;&lt;1|1; if(l &gt; sz) break; if(r &gt; sz || cmp(a[l], a[r])) s = l; // a[l] &lt; a[r] else s = r; if(cmp(a[s], a[p])) // a[s] &lt; a[p] swap(a[p], a[s]), p = s; else break; } } }; 可删堆copyright by axiomofchoice 代码 template &lt;typename T&gt; struct Heap{ priority_queue&lt;T&gt; a,b; // heap=a-b void push(T x){a.push(x);} void erase(T x){b.push(x);} T top(){ while(!b.empty() &amp;&amp; a.top()==b.top()) a.pop(),b.pop(); return a.size() ? a.top() : 0; // ??? } void pop(){ while(!b.empty() &amp;&amp; a.top()==b.top()) a.pop(),b.pop(); a.pop(); } T top2(){ // 次大值 T t=top(); pop(); T ans=top(); push(t); return ans; } size_t size(){return a.size()-b.size();} }; 二叉查找树平衡树替罪羊树|Scapegoat TreeTreapSplay 代码 struct Splay { #define root e[0].ch[1] typedef int T; struct node { T v = 0; int ch[2] = {0, 0}; int fa = 0, sum = 0, cnt = 0; } e[N]; int n; void update(int x) { e[x].sum = e[e[x].ch[0]].sum+e[e[x].ch[1]].sum+e[x].cnt; } int identify(int x) { return x == e[e[x].fa].ch[1]; } // check left or right child void connect(int x, int f, int son) { e[x].fa = f; e[f].ch[son] = x; } void rotate(int x) { int y = e[x].fa, r = e[y].fa, rson = identify(y), yson = identify(x), b = e[x].ch[yson^1]; connect(b, y, yson); connect(y, x, yson^1); connect(x, r, rson); update(y); update(x); } void splay(int at, int to) { to = e[to].fa; int up; while((up = e[at].fa) != to) { if(e[up].fa != to) rotate(identify(up) == identify(at) ? up : at); rotate(at); } } int add_point(T v, int fa) { ++n; e[n].v = v; e[n].fa = fa; e[n].sum = e[n].cnt = 1; return n; } int find(T v) { int now = root, last = 0; while (now &amp;&amp; e[now].v != v) last = now, now = e[now].ch[v &gt; e[now].v]; splay((now ? now : last), root); return now; } void insert(T v) { if (!root) { root = add_point(v, root); return; } int now = root, last = 0; while (now &amp;&amp; e[now].v != v) last = now, now = e[now].ch[v &gt; e[now].v]; if (now) ++e[now].cnt; else now = e[last].ch[v &gt; e[last].v] = add_point(v, last); splay(now, root); } void erase(T v) { int del = find(v); if (!del) return; if (e[del].cnt &gt; 1) { --e[del].cnt; --e[del].sum; } else if (!e[del].ch[0]) { root = e[del].ch[1]; e[root].fa = 0; } else { int oldroot = root; splay(nex(e[del].ch[0], 1), root); connect(e[oldroot].ch[1], root, 1); update(root); } } int rank(T v) { return e[e[find(v)].ch[0]].sum+1; } T atrank(int x) { if (x &gt; e[root].sum) return -INF; int now = root; while (true) { if (x &lt;= e[e[now].ch[0]].sum) now = e[now].ch[0]; else if ((x -= e[e[now].ch[0]].sum) &lt;= e[now].cnt) break; else x -= e[now].cnt, now = e[now].ch[1]; } splay(now, root); return e[now].v; } // small 0, big 1 int nex(int x, int opt) { while (e[x].ch[opt]) x = e[x].ch[opt]; return x; } T lower(T v, int opt) { insert(v); T res = e[nex(e[root].ch[opt], opt^1)].v; erase(v); return res; } #undef root }; 区间反转 代码 struct Splay { typedef int T; struct node { T v = 0; int ch[2] = { 0, 0 }; int fa = 0, sum = 0, cnt = 0, tag = 0; } e[N]; int sz, &amp;root = e[0].ch[1]; void update(int x) { e[x].sum = e[e[x].ch[0]].sum+e[e[x].ch[1]].sum+e[x].cnt; } int identify(int x) { return x == e[e[x].fa].ch[1]; } void connect(int x,int f,int son) { e[x].fa = f; e[f].ch[son] = x; } void rotate(int x) { int y = e[x].fa, r = e[y].fa, rson = identify(y), yson = identify(x), b = e[x].ch[yson^1]; connect(b, y, yson); connect(y, x, yson^1); connect(x, r, rson); update(y); update(x); } void splay(int at,int to = 0) { to = e[to].fa; int up; while((up = e[at].fa) != to) { if(e[up].fa != to) rotate(identify(up) == identify(at) ? up : at); rotate(at); } } int add_point(T v, int fa) { ++sz; e[sz].v = v; e[sz].fa = fa; e[sz].sum = e[sz].cnt = 1; return sz; } int find(int x) { if (x &gt; e[root].sum) return -INF; int now = root; while (true) { push_down(now); if (x &lt;= e[e[now].ch[0]].sum) now = e[now].ch[0]; else if ((x -= e[e[now].ch[0]].sum) &lt;= e[now].cnt) break; else x -= e[now].cnt, now = e[now].ch[1]; } return now; } int build(int l, int r, int fa) { if (l &gt; r) return 0; int mid = (l+r)&gt;&gt;1, now = add_point(mid, fa); e[now].ch[0] = build(l, mid-1, now); e[now].ch[1] = build(mid+1, r, now); update(now); return now; } void push_down(int x) { if (x &amp;&amp; e[x].tag) { e[e[x].ch[0]].tag ^= 1; e[e[x].ch[1]].tag ^= 1; swap(e[x].ch[0], e[x].ch[1]); e[x].tag = 0; } } void reverse(int l, int r) { int pl = find(l-1+1), pr = find(r+1+1); splay(pl); splay(pr, pl); e[e[e[root].ch[1]].ch[0]].tag ^= 1; } void print_LMR(int x) { if (!x) return; push_down(x); print_LMR(e[x].ch[0]); if (e[x].v != 0 &amp;&amp; e[x].v != n+1) write(a[e[x].v]), putchar(' '); print_LMR(e[x].ch[1]); } } tree; 线段树区间加减区间和 代码 template &lt;typename T&gt; struct SegmentTree { int sz; T tr[N&lt;&lt;2], lazy[N&lt;&lt;2]; SegmentTree(){} void build(const int &amp;n, const T &amp;k = 0) { sz = n; _build(1, n, k); } template &lt;typename TT&gt; void build(const TT a[], const int &amp;n) { sz = n; _build(a, 1, n); } void modify(const int &amp;x, const T &amp;k) { _modify(x, k, 1, sz); } void add(const int &amp;x, const T &amp;k) { _add(x, x, k, 1, sz); } void add(int l, int r, const T &amp;k) { if (l &gt; r) swap(l, r); _add(l, r, k, 1, sz); } T query(const int &amp;x) { return _query(x, x, 1, sz); } T query(int l, int r) { if (l &gt; r) swap(l, r); return _query(l, r, 1, sz); } private : void push_up(const int &amp;i) { tr[i] = tr[i&lt;&lt;1]+tr[i&lt;&lt;1|1]; } void push_down(const int &amp;i, const int &amp;len) { if (!lazy[i]) return; tr[i&lt;&lt;1] += lazy[i]*(len-len/2); tr[i&lt;&lt;1|1] += lazy[i]*(len/2); lazy[i&lt;&lt;1] += lazy[i]; lazy[i&lt;&lt;1|1] += lazy[i]; lazy[i] = 0; } void _build(const int &amp;l, const int &amp;r, const T &amp;k = 0, const int &amp;i = 1) { lazy[i] = 0; if (l == r) { tr[i] = k; return; } int mid = (l+r)&gt;&gt;1; _build(l, mid, k, i&lt;&lt;1); _build(mid+1, r, k, i&lt;&lt;1|1); push_up(i); } template &lt;typename TT&gt; void _build(const TT a[], const int &amp;l, const int &amp;r, const int &amp;i = 1) { lazy[i] = 0; if (l == r) { tr[i] = a[l]; return; } int mid = (l+r)&gt;&gt;1; _build(a, l, mid, i&lt;&lt;1); _build(a, mid+1, r, i&lt;&lt;1|1); push_up(i); } void _modify(const int &amp;x, const T &amp;k, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl == x &amp;&amp; trr == x) { tr[i] = k; lazy[i] = 0; return; } push_down(i, trr-trl+1); int mid = (trl+trr)&gt;&gt;1; if (x &lt;= mid) _modify(x, k, trl, mid, i&lt;&lt;1); else _modify(x, k, mid+1, trr, i&lt;&lt;1|1); push_up(i); } void _add(const int &amp;l, const int &amp;r, const T &amp;k, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl &gt;= l &amp;&amp; trr &lt;= r) { tr[i] += k*(trr-trl+1); lazy[i] += k; return; } push_down(i, trr-trl+1); int mid = (trl+trr)&gt;&gt;1; if (l &lt;= mid) _add(l, r, k, trl, mid, i&lt;&lt;1); if (r &gt; mid) _add(l, r, k, mid+1, trr, i&lt;&lt;1|1); push_up(i); } T _query(const int &amp;l, const int &amp;r, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl &gt;= l &amp;&amp; trr &lt;= r) return tr[i]; push_down(i, trr-trl+1); int mid = (trl+trr)&gt;&gt;1; T res = 0; if (l &lt;= mid) res += _query(l, r, trl, mid, i&lt;&lt;1); if (r &gt; mid) res += _query(l, r, mid+1, trr, i&lt;&lt;1|1); return res; } }; 动态开点 template &lt;typename T&gt; struct SegmentTree { // 区间加减区间和 struct TreeNode { int l, r; TreeNode *ls, *rs; T val, lazy; TreeNode() { ls = rs = nullptr; } TreeNode(const int &amp;_l, const int &amp;_r, const T &amp;_val = 0) : l(_l), r(_r), val(_val) { ls = rs = nullptr; lazy = 0; } int len() const { return r-l+1; } }; TreeNode *root; void clear(TreeNode *rt) { if (!rt) return; clear(rt-&gt;ls); clear(rt-&gt;rs); delete rt; } void build(const int &amp;n) { clear(root); root = new TreeNode(1, n); } void push_up(TreeNode *rt) { rt-&gt;val = (rt-&gt;ls ? rt-&gt;ls-&gt;val : 0)+(rt-&gt;rs ? rt-&gt;rs-&gt;val : 0); } void push_down(TreeNode *rt) { if (!rt-&gt;lazy) return; int mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;1; if (!rt-&gt;ls) rt-&gt;ls = new TreeNode(rt-&gt;l, mid); if (!rt-&gt;rs) rt-&gt;rs = new TreeNode(mid+1, rt-&gt;r); rt-&gt;ls-&gt;lazy += rt-&gt;lazy; rt-&gt;ls-&gt;val += rt-&gt;lazy*rt-&gt;ls-&gt;len(); rt-&gt;rs-&gt;lazy += rt-&gt;lazy; rt-&gt;rs-&gt;val += rt-&gt;lazy*rt-&gt;rs-&gt;len(); rt-&gt;lazy = 0; } void update(const int &amp;x, const T &amp;k) { update(x, k, root); } void update(const int &amp;x, const T &amp;k, TreeNode *rt) { if (rt-&gt;l == x &amp;&amp; rt-&gt;r == x) return rt-&gt;val = k, void(); push_down(rt); int mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;1; if (x &lt;= mid) update(x, k, rt-&gt;ls ? rt-&gt;ls : rt-&gt;ls = new TreeNode(rt-&gt;l, mid)); else update(x, k, rt-&gt;rs ? rt-&gt;rs : rt-&gt;rs = new TreeNode(mid+1, rt-&gt;r)); push_up(rt); } void add(const int &amp;x, const T &amp;k) { add(x, x, k, root); } void add(const int &amp;l, const int &amp;r, const T &amp;k) { add(l, r, k, root); } void add(const int &amp;l, const int &amp;r, const T &amp;k, TreeNode *rt) { if (rt-&gt;l &gt;= l &amp;&amp; rt-&gt;r &lt;= r) { rt-&gt;val += rt-&gt;len()*k; rt-&gt;lazy += k; return; } push_down(rt); int mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;1; if (l &lt;= mid) add(l, r, k, rt-&gt;ls ? rt-&gt;ls : rt-&gt;ls = new TreeNode(rt-&gt;l, mid)); if (r &gt; mid) add(l, r, k, rt-&gt;rs ? rt-&gt;rs : rt-&gt;rs = new TreeNode(mid+1, rt-&gt;r)); push_up(rt); } T query(const int &amp;x) { return query(x, x, root); } T query(const int &amp;l, const int &amp;r) { return query(l, r, root); } T query(const int &amp;l, const int &amp;r, TreeNode *rt) { if (rt-&gt;l &gt;= l &amp;&amp; rt-&gt;r &lt;= r) return rt-&gt;val; push_down(rt); int mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;1; if (l &lt;= mid &amp;&amp; !rt-&gt;ls) rt-&gt;ls = new TreeNode(rt-&gt;l, mid); if (r &gt; mid &amp;&amp; !rt-&gt;rs) rt-&gt;rs = new TreeNode(mid+1, rt-&gt;r); if (r &lt;= mid) return query(l, r, rt-&gt;ls); if (l &gt; mid) return query(l, r, rt-&gt;rs); return query(l, r, rt-&gt;ls)+query(l, r, rt-&gt;rs); } }; 内存池 template &lt;typename T&gt; struct SegmentTree { // 区间加减区间和 struct TreeNode { int l, r; TreeNode *ls, *rs; T val, lazy; int len() const { return r-l+1; } } tr[N&lt;&lt;1]; queue&lt;TreeNode*&gt; memory_pool; SegmentTree() { for (int i = 0; i &lt; N&lt;&lt;2; ++i) memory_pool.push(tr+i); } TreeNode* fuck(const int &amp;l, const int &amp;r, const T &amp;val = 0) { // new TreeNode *ptr = memory_pool.front(); memory_pool.pop(); ptr-&gt;l = l; ptr-&gt;r = r; ptr-&gt;val = val; ptr-&gt;ls = ptr-&gt;rs = nullptr; return ptr; } void shit(TreeNode *ptr) { memory_pool.push(ptr); } // delete TreeNode *root; void clear(TreeNode *rt) { if (!rt) return; clear(rt-&gt;ls); clear(rt-&gt;rs); shit(rt); } void build(const int &amp;n) { clear(root); root = fuck(1, n); } void push_up(TreeNode *rt) { rt-&gt;val = (rt-&gt;ls ? rt-&gt;ls-&gt;val : 0)+(rt-&gt;rs ? rt-&gt;rs-&gt;val : 0); } void push_down(TreeNode *rt) { if (!rt-&gt;lazy) return; int mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;1; if (!rt-&gt;ls) rt-&gt;ls = fuck(rt-&gt;l, mid); if (!rt-&gt;rs) rt-&gt;rs = fuck(mid+1, rt-&gt;r); rt-&gt;ls-&gt;lazy += rt-&gt;lazy; rt-&gt;ls-&gt;val += rt-&gt;lazy*rt-&gt;ls-&gt;len(); rt-&gt;rs-&gt;lazy += rt-&gt;lazy; rt-&gt;rs-&gt;val += rt-&gt;lazy*rt-&gt;rs-&gt;len(); rt-&gt;lazy = 0; } void update(const int &amp;x, const T &amp;k) { update(x, k, root); } void update(const int &amp;x, const T &amp;k, TreeNode *rt) { if (rt-&gt;l == x &amp;&amp; rt-&gt;r == x) return rt-&gt;val = k, void(); push_down(rt); int mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;1; if (x &lt;= mid) update(x, k, rt-&gt;ls ? rt-&gt;ls : rt-&gt;ls = fuck(rt-&gt;l, mid)); else update(x, k, rt-&gt;rs ? rt-&gt;rs : rt-&gt;rs = fuck(mid+1, rt-&gt;r)); push_up(rt); } void add(const int &amp;x, const T &amp;k) { add(x, x, k, root); } void add(const int &amp;l, const int &amp;r, const T &amp;k) { add(l, r, k, root); } void add(const int &amp;l, const int &amp;r, const T &amp;k, TreeNode *rt) { if (rt-&gt;l &gt;= l &amp;&amp; rt-&gt;r &lt;= r) { rt-&gt;val += rt-&gt;len()*k; rt-&gt;lazy += k; return; } push_down(rt); int mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;1; if (l &lt;= mid) add(l, r, k, rt-&gt;ls ? rt-&gt;ls : rt-&gt;ls = fuck(rt-&gt;l, mid)); if (r &gt; mid) add(l, r, k, rt-&gt;rs ? rt-&gt;rs : rt-&gt;rs = fuck(mid+1, rt-&gt;r)); push_up(rt); } T query(const int &amp;x) { return query(x, x, root); } T query(const int &amp;l, const int &amp;r) { return query(l, r, root); } T query(const int &amp;l, const int &amp;r, TreeNode *rt) { if (rt-&gt;l &gt;= l &amp;&amp; rt-&gt;r &lt;= r) return rt-&gt;val; push_down(rt); int mid = (rt-&gt;l+rt-&gt;r)&gt;&gt;1; if (l &lt;= mid &amp;&amp; !rt-&gt;ls) rt-&gt;ls = fuck(rt-&gt;l, mid); if (r &gt; mid &amp;&amp; !rt-&gt;rs) rt-&gt;rs = fuck(mid+1, rt-&gt;r); if (r &lt;= mid) return query(l, r, rt-&gt;ls); if (l &gt; mid) return query(l, r, rt-&gt;rs); return query(l, r, rt-&gt;ls)+query(l, r, rt-&gt;rs); } }; 区间修改区间和 代码 template &lt;typename T&gt; struct SegmentTree { int sz; int tag[N&lt;&lt;2]; T tr[N&lt;&lt;2], lazy[N&lt;&lt;2]; SegmentTree(){} void build(const int &amp;n, const T &amp;k = 0) { sz = n; _build(1, n, k); } template &lt;typename TT&gt; void build(const TT a[], const int &amp;n) { sz = n; _build(a, 1, n); } void update(const int &amp;x, const T &amp;k) { _update(x, x, k, 1, sz); } void update(int l, int r, const T &amp;k) { if (l &gt; r) swap(l, r); _update(l, r, k, 1, sz); } T query(const int &amp;x) { return _query(x, x, 1, sz); } T query(int l, int r) { if (l &gt; r) swap(l, r); return _query(l, r, 1, sz); } private : void push_up(const int &amp;i) { tr[i] = tr[i&lt;&lt;1]+tr[i&lt;&lt;1|1]; } void push_down(const int &amp;i, const int &amp;len) { if (!tag[i]) return; tr[i&lt;&lt;1] = lazy[i]*(len-len/2); tr[i&lt;&lt;1|1] = lazy[i]*(len/2); lazy[i&lt;&lt;1] = lazy[i&lt;&lt;1|1] = lazy[i]; tag[i&lt;&lt;1] = tag[i&lt;&lt;1|1] = 1; tag[i] = 0; } void _build(const int &amp;l, const int &amp;r, const T &amp;k = 0, const int &amp;i = 1) { lazy[i] = tag[i] = 0; if (l == r) { tr[i] = k; return; } int mid = (l+r)&gt;&gt;1; _build(l, mid, k, i&lt;&lt;1); _build(mid+1, r, k, i&lt;&lt;1|1); push_up(i); } template &lt;typename TT&gt; void _build(const TT a[], const int &amp;l, const int &amp;r, const int &amp;i = 1) { lazy[i] = tag[i] = 0; if (l == r) { tr[i] = a[l]; return; } int mid = (l+r)&gt;&gt;1; _build(a, l, mid, i&lt;&lt;1); _build(a, mid+1, r, i&lt;&lt;1|1); push_up(i); } void _update(const int &amp;l, const int &amp;r, const T &amp;k, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl &gt;= l &amp;&amp; trr &lt;= r) { tr[i] = k*(trr-trl+1); lazy[i] = k; tag[i] = 1; return; } push_down(i, trr-trl+1); int mid = (trl+trr)&gt;&gt;1; if (l &lt;= mid) _update(l, r, k, trl, mid, i&lt;&lt;1); if (r &gt; mid) _update(l, r, k, mid+1, trr, i&lt;&lt;1|1); push_up(i); } T _query(const int &amp;l, const int &amp;r, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl &gt;= l &amp;&amp; trr &lt;= r) return tr[i]; push_down(i, trr-trl+1); int mid = (trl+trr)&gt;&gt;1; T res = 0; if (l &lt;= mid) res += _query(l, r, trl, mid, i&lt;&lt;1); if (r &gt; mid) res += _query(l, r, mid+1, trr, i&lt;&lt;1|1); return res; } }; 区间加减区间最值 代码 template &lt;typename T, typename U = greater&lt;T&gt;&gt; struct SegmentTree { U cmp = U(); int n; T tr[N&lt;&lt;2], lazy[N&lt;&lt;2], init_val = cmp(0, 1) ? INF : -INF; SegmentTree(){} T mv(const T &amp;x, const T &amp;y) { return cmp(x, y) ? x : y;} void build(const int &amp;_n, const T &amp;k = 0) { n = _n; _build(1, n, k); } template &lt;typename TT&gt; void build(const TT a[], const int &amp;_n) { n = _n; _build(a, 1, n); } void modify(const int &amp;x, const T &amp;k) { _modify(x, k, 1, n); } void add(const int &amp;x, const T &amp;k) { _add(x, x, k, 1, n); } void add(const int &amp;l, const int &amp;r, const T &amp;k) { _add(l, r, k, 1, n); } T query(const int &amp;x) { return _query(x, x, 1, n); } T query(const int &amp;l, const int &amp;r) { return _query(l, r, 1, n); } private : void push_up(const int &amp;i) { tr[i] = mv(tr[i&lt;&lt;1], tr[i&lt;&lt;1|1]); } void push_down(const int &amp;i) { if (!lazy[i]) return; tr[i&lt;&lt;1] += lazy[i]; tr[i&lt;&lt;1|1] += lazy[i]; lazy[i&lt;&lt;1] += lazy[i]; lazy[i&lt;&lt;1|1] += lazy[i]; lazy[i] = 0; } void _build(const int &amp;l, const int &amp;r, const T &amp;k = 0, const int &amp;i = 1) { lazy[i] = 0; if (l == r) { tr[i] = k; return; } int mid = (l+r)&gt;&gt;1; _build(l, mid, k, i&lt;&lt;1); _build(mid+1, r, k, i&lt;&lt;1|1); push_up(i); } template &lt;typename TT&gt; void _build(const TT a[], const int &amp;l, const int &amp;r, const int &amp;i = 1) { lazy[i] = 0; if (l == r) { tr[i] = a[l]; return; } int mid = (l+r)&gt;&gt;1; _build(a, l, mid, i&lt;&lt;1); _build(a, mid+1, r, i&lt;&lt;1|1); push_up(i); } void _modify(const int &amp;x, const T &amp;k, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl == x &amp;&amp; trr == x) return tr[i] = k, void(); push_down(i); int mid = (trl+trr)&gt;&gt;1; if (x &lt;= mid) _modify(x, k, trl, mid, i&lt;&lt;1); else _modify(x, k, mid+1, trr, i&lt;&lt;1|1); push_up(i); } void _add(const int &amp;l, const int &amp;r, const T &amp;k, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl &gt;= l &amp;&amp; trr &lt;= r) { tr[i] += k; lazy[i] += k; return; } push_down(i); int mid = (trl+trr)&gt;&gt;1; if (l &lt;= mid) _add(l, r, k, trl, mid, i&lt;&lt;1); if (r &gt; mid) _add(l, r, k, mid+1, trr, i&lt;&lt;1|1); push_up(i); } T _query(const int &amp;l, const int &amp;r, const int &amp;trl, const int &amp;trr, const int &amp;i = 1) { if (trl &gt;= l &amp;&amp; trr &lt;= r) return tr[i]; push_down(i); int mid = (trl+trr)&gt;&gt;1; if (r &lt;= mid) return _query(l, r, trl, mid, i&lt;&lt;1); if (l &gt; mid) return _query(l, r, mid+1, trr, i&lt;&lt;1|1); return mv(_query(l, r, trl, mid, i&lt;&lt;1), _query(l, r, mid+1, trr, i&lt;&lt;1|1)); } }; 区间更新最值 代码 template &lt;typename T, typename U = greater&lt;T&gt;&gt; struct SegmentTree { SegmentTree(){} void build(const int &amp;_n, const T &amp;k = 0) { n = _n; _build(1, n, k); } template &lt;typename TT&gt; void buiil(const int _n, const TT a[]) { n = _n; _build(1, n, a); } void modify(const int &amp;x, const T &amp;k) { _modify(x, x, k); } void modify(const int &amp;l, const int &amp;r, const T &amp;k) { _modify(l, r, k); } void add(const int &amp;x, const T &amp;k) { _add(x, k); } T query(const int &amp;x) { return _query(x, x); } T query(const int &amp;l, const int &amp;r) { return _query(l, r); } private: struct TreeNode { int l, r; T v, lazy; } tr[N&lt;&lt;2]; int n; T init_val = cmp(0, 1) ? INF : -INF; U cmp = U(); T mv(const T &amp;x, const T &amp;y) { return cmp(x, y) ? x : y;} void update(const int &amp;i, const T &amp;k) { tr[i].v = mv(tr[i].v, k); tr[i].lazy = mv(tr[i].lazy, k); } void push_up(const int &amp;i) { tr[i].v = mv(tr[i&lt;&lt;1].v, tr[i&lt;&lt;1|1].v); } void push_down(const int &amp;i) { if (tr[i].lazy == init_val) return; update(i&lt;&lt;1, tr[i].lazy); update(i&lt;&lt;1|1, tr[i].lazy); tr[i].lazy = init_val; } void _build(const int &amp;l, const int &amp;r, const T &amp;k = 0, const int &amp;i = 1) { tr[i].lazy = init_val; tr[i].l = l; tr[i].r = r; if (l == r) { tr[i].v = k; return; } int mid = (l+r)&gt;&gt;1; _build(l, mid, k, i&lt;&lt;1); _build(mid+1, r, k, i&lt;&lt;1|1); push_up(i); } template &lt;typename TT&gt; void _build(const int &amp;l, const int &amp;r, const TT a[], const int &amp;i = 1) { tr[i].lazy = init_val; tr[i].l = l; tr[i].r = r; if (l == r) { tr[i].v = a[l]; return; } int mid = (l+r)&gt;&gt;1; _build(l, mid, a, i&lt;&lt;1); _build(mid+1, r, a, i&lt;&lt;1|1); push_up(i); } void _modify(const int &amp;l, const int &amp;r, const T &amp;k, const int &amp;i = 1) { if (tr[i].l &gt;= l &amp;&amp; tr[i].r &lt;= r) { update(i, k); return; } push_down(i); int mid = (tr[i].l+tr[i].r)&gt;&gt;1; if (l &lt;= mid) _modify(l, r, k, i&lt;&lt;1); if (r &gt; mid) _modify(l, r, k, i&lt;&lt;1|1); push_up(i); } void _add(const int &amp;x, const T &amp;k, const int &amp;i = 1) { if (tr[i].l == x &amp;&amp; tr[i].r == x) { tr[i].v += k; return; } push_down(i); int mid = (tr[i].l+tr[i].r)&gt;&gt;1; if (x &lt;= mid) _add(x, k, i&lt;&lt;1); else _add(x, k, i&lt;&lt;1|1); push_up(i); } T _query(const int &amp;l, const int &amp;r, const int &amp;i = 1) { if (tr[i].l &gt;= l &amp;&amp; tr[i].r &lt;= r) return tr[i].v; push_down(i); int mid = (tr[i].l+tr[i].r)&gt;&gt;1; T res = init_val; if (l &lt;= mid) res = mv(res, _query(l, r, i&lt;&lt;1)); if (r &gt; mid) res = mv(res, _query(l, r, i&lt;&lt;1|1)); return res; } }; 区间最大连续子段和 代码 struct SegmentTree { struct TreeNode { long long s, ls, rs, ms; void set(long long x) { s = ls = rs = ms = x; } friend TreeNode operator +(const TreeNode &amp;lc, const TreeNode &amp;rc) { return TreeNode { lc.s+rc.s, max(lc.ls, lc.s+rc.ls), max(rc.rs, lc.rs+rc.s), max({lc.ms, rc.ms, lc.rs+rc.ls}) }; } } tr[N&lt;&lt;2]; int *a, n; void build(int a[], int n) { this-&gt;a = a; this-&gt;n = n; build(1, n, 1); } void build(int l, int r, int i) { if (l == r) return tr[i].set(a[l]); int mid = (l+r)&gt;&gt;1; build(l, mid, i&lt;&lt;1); build(mid+1, r, i&lt;&lt;1|1); tr[i] = tr[i&lt;&lt;1]+tr[i&lt;&lt;1|1]; } void update(int x, long long v) { update(x, v, 1, n, 1); } void update(int x, long long v, int l, int r, int i) { if (l == r) return tr[i].set(v); int mid = (l+r)&gt;&gt;1; if (x &lt;= mid) update(x, v, l, mid, i&lt;&lt;1); else update(x, v, mid+1, r, i&lt;&lt;1|1); tr[i] = tr[i&lt;&lt;1]+tr[i&lt;&lt;1|1]; } long long query(int L, int R) { return query(L, R, 1, n, 1).ms; } TreeNode query(int L, int R, int l, int r, int i) { if (l &gt;= L &amp;&amp; r &lt;= R) return tr[i]; int mid = (l+r)&gt;&gt;1; if (R &lt;= mid) return query(L, R, l, mid, i&lt;&lt;1); if (L &gt; mid) return query(L, R, mid+1, r, i&lt;&lt;1|1); return query(L, R, l, mid, i&lt;&lt;1)+query(L, R, mid+1, r, i&lt;&lt;1|1); } }; ZKW线段树warning:区间最值尚为验证 代码 template &lt;typename T&gt; struct zkwSegmentTree { int sz; T sum[N&lt;&lt;2], mn[N&lt;&lt;2], mx[N&lt;&lt;2], add[N&lt;&lt;2]; void update(const int &amp;x) { T tmp; tmp = min(mn[x], mn[x^1]); mn[x] -= tmp; mn[x^1] -= tmp; mn[x&gt;&gt;1] += tmp; tmp = max(mx[x], mx[x^1]); mx[x] -= tmp; mx[x^1] -= tmp; mx[x&gt;&gt;1] += tmp; } template &lt;typename TT&gt; void build(const TT a[], const int &amp;n) { for (sz = 1; sz &lt;= n+1; sz &lt;&lt;= 1); for (int i = sz+1; i &lt;= sz+n; ++i) sum[i] = mn[i] = mx[i] = a[i-sz]; for (int i = sz-1; i; --i) { sum[i] = sum[i&lt;&lt;1]+sum[i&lt;&lt;1|1]; mn[i] = min(mn[i&lt;&lt;1], mn[i&lt;&lt;1|1]); mn[i&lt;&lt;1] -= mn[i]; mn[i&lt;&lt;1|1] -= mn[i]; mx[i] = max(mx[i&lt;&lt;1], mx[i&lt;&lt;1|1]); mx[i&lt;&lt;1] -= mx[i]; mx[i&lt;&lt;1|1] -= mx[i]; } } void update(int x, const T &amp;v) { x += sz; mx[x] += v; mn[x] += v; sum[x] += v; for ( ; x &gt; 1; x &gt;&gt;= 1) { sum[x] += v; update(x); } } void update(int s, int t, const T &amp;v) { int lc = 0, rc = 0, len = 1; for (s += sz-1, t += sz+1; s^t^1; s &gt;&gt;= 1, t &gt;&gt;= 1, len &lt;&lt;= 1) { if (~s&amp;1) add[s^1] += v, lc += len, mn[s^1] += v, mx[s^1] += v; if ( t&amp;1) add[t^1] += v, rc += len, mn[t^1] += v, mx[t^1] += v; sum[s&gt;&gt;1] += v*lc; sum[t&gt;&gt;1] += v*rc; update(s); update(t); } for (lc += rc; s; s &gt;&gt;= 1) { sum[s&gt;&gt;1] += v*lc; update(s); } } T query(int x) { T res = 0; for (x += sz; x; x &gt;&gt;= 1) res += mn[x]; return res; } T query_sum(int s, int t) { int lc = 0, rc = 0, len = 1; T res = 0; for (s += sz-1, t += sz+1; s^t^1; s &gt;&gt;= 1, t &gt;&gt;= 1, len &lt;&lt;= 1) { if (~s&amp;1) res += sum[s^1]+len*add[s^1], lc += len; if ( t&amp;1) res += sum[t^1]+len*add[t^1], rc += len; if (add[s&gt;&gt;1]) res += add[s&gt;&gt;1]*lc; if (add[t&gt;&gt;1]) res += add[t&gt;&gt;1]*rc; } for (lc += rc, s &gt;&gt;= 1; s; s &gt;&gt;= 1) if (add[s]) res += add[s]*lc; return res; } T query_min(int s, int t) { if (s == t) return query(s); T l = 0, r = 0, res = 0; for (s += sz, t += sz; s^t^1; s &gt;&gt;= 1, t &gt;&gt;= 1) { l += mn[s]; r += mn[t]; if (~s^1) l = min(l, mn[s^1]); if ( t^1) r = min(r, mn[t^1]); } for (res = min(l, r), s &gt;&gt;= 1; s; s &gt;&gt;= 1) res += mn[s]; return res; } T query_max(int s, int t) { if (s == t) return query(s); T l = 0, r = 0, res = 0; for (s += sz, t += sz; s^t^1; s &gt;&gt;= 1, t &gt;&gt;= 1) { l += mx[s]; r += mx[t]; if (~s^1) l = max(l, mx[s^1]); if ( t^1) r = max(r, mx[t^1]); } for (res = max(l, r), s &gt;&gt;= 1; s; s &gt;&gt;= 1) res += mx[s]; return res; } }; 李超线段树李超线段树是一种用于维护平面直角坐标系内线段关系的数据结构。它常被用来处理这样一种形式的问题：给定一个平面直角坐标系，支持动态插入一条线段，询问从某一个位置 (x,+∞) 向下看能看到的最高的一条线段（也就是给一条竖线，问这条竖线与所有线段的最高的交点。 线段树合并有 $O(m)$ 棵树(个操作) 结点数量 $O(m\\log n)$, 暴力合并,均摊复杂度 $O(\\log n)$ 代码 int merge(int x, int y) { // 太难了,现场全重写吧 if (!x || !y) return x+y; int &amp;z = x; // int z = new_node(); // 新建结点? lc[z] = merge(lc[x], lc[y]); rc[z] = merge(rc[x], rc[y]); if (!lc[z] &amp;&amp; !rc[z]) tr[z].first = tr[x].first+tr[y].first; else push_up(z); // tr[z] = giao(x, y); // del(y); // del(x); // 保留结点? return z; } 线段树分裂一次分裂复杂度 $O(\\log n)$ 代码 template &lt;typename T&gt; struct Tree { int tot, lc[NLOG], rc[NLOG]; T tr[NLOG]; void init() { tot = 0; } T giao(const T &amp;x, const T &amp;y) { return x+y; } void push_up(int i) { tr[i] = giao(tr[lc[i]], tr[rc[i]]); } int new_node(T v = 0) { ++tot; // assert(++tot &lt; NLOG); lc[tot] = rc[tot] = 0; tr[tot] = v; return tot; } void add(int x, T v, int l, int r, int &amp;i) { if (!i) i = new_node(); if (l == r) return tr[i] += v, void(); int mid = (l+r)&gt;&gt;1; if (x &lt;= mid) add(x, v, l, mid, lc[i]); else add(x, v, mid+1, r, rc[i]); push_up(i); } void merge(int l, int r, int &amp;x, int &amp;y) { // merge y to x if (!x || !y) return x += y, void(); if (l == r) return tr[x] += tr[y], void(); int mid = (l+r)&gt;&gt;1; merge(l, mid, lc[x], lc[y]); merge(mid+1, r, rc[x], rc[y]); push_up(x); // del(y); } /* int merge(int l, int r, int x, int y) { // new node if (!x || !y) return x += y; int cur = new_node(), mid = (l+r)&gt;&gt;1; if (l == r) return tr[cur] = tr[x]+tr[y], cur; lc[cur] = merge(l, mid, lc[x], lc[y]); rc[cur] = merge(mid+1, r, rc[x], rc[y]); push_up(cur); return cur; } */ void split(int L, int R, int l, int r, int &amp;x, int &amp;y) { //split x [L, R] to y if (!x) return; if (L &lt;= l &amp;&amp; r &lt;= R) return y = x, x = 0, void(); if (!y) y = new_node(); int mid = (l+r)&gt;&gt;1; if (L &lt;= mid) split(L, R, l, mid, lc[x], lc[y]); if (R &gt; mid) split(L, R, mid+1, r, rc[x], rc[y]); push_up(x); push_up(y); } T query(int L, int R, int l, int r, int i) { if (!i) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return tr[i]; int mid = (l+r)&gt;&gt;1; if (R &lt;= mid) return query(L, R, l, mid, lc[i]); if (L &gt; mid) return query(L, R, mid+1, r, rc[i]); return giao(query(L, R, l, mid, lc[i]), query(L, R, mid+1, r, rc[i])); } int query_kth(int k, int l, int r, int i) { if (l == r) return l; int mid = (l+r)&gt;&gt;1; if (k &lt;= tr[lc[i]]) return query_kth(k, l, mid, lc[i]); return query_kth(k-tr[lc[i]], mid+1, r, rc[i]); } }; 猫树所谓 “猫树” 就是一种不支持修改，仅仅支持快速区间询问的一种静态线段树。 构造一棵这样的静态线段树需要 $O(n\\log n)$ 次合并操作，但是此时的查询复杂度被加速至 $O(1)$ 次合并操作。 吉老师线段树|吉司机线段树区间最值操作 区间取min 询问区间min 询问区间和 $O(m \\log n)$ 代码 struct Tree { struct TreeNode { int l, r, mx, se, cnt, tag; ll sum; } tr[N&lt;&lt;2]; void push_up(int i) { tr[i].sum = tr[i&lt;&lt;1].sum+tr[i&lt;&lt;1|1].sum; if (tr[i&lt;&lt;1].mx &gt; tr[i&lt;&lt;1|1].mx) { tr[i].mx = tr[i&lt;&lt;1].mx; tr[i].cnt = tr[i&lt;&lt;1].cnt; tr[i].se = max(tr[i&lt;&lt;1].se, tr[i&lt;&lt;1|1].mx); } else if (tr[i&lt;&lt;1].mx &lt; tr[i&lt;&lt;1|1].mx) { tr[i].mx = tr[i&lt;&lt;1|1].mx; tr[i].cnt = tr[i&lt;&lt;1|1].cnt; tr[i].se = max(tr[i&lt;&lt;1|1].se, tr[i&lt;&lt;1].mx); } else { tr[i].mx = tr[i&lt;&lt;1].mx; tr[i].cnt = tr[i&lt;&lt;1].cnt+tr[i&lt;&lt;1|1].cnt; tr[i].se = max(tr[i&lt;&lt;1].se, tr[i&lt;&lt;1|1].se); } } void push_tag(int i, int v) { if (v &gt;= tr[i].mx) return; tr[i].sum -= 1ll*(tr[i].mx-v)*tr[i].cnt; tr[i].mx = tr[i].tag = v; } void push_down(int i) { if (tr[i].tag == -1) return; push_tag(i&lt;&lt;1, tr[i].tag); push_tag(i&lt;&lt;1|1, tr[i].tag); tr[i].tag = -1; } void build(int l, int r, int i = 1) { tr[i].l = l; tr[i].r = r; tr[i].tag = -1; if (l == r) { tr[i].sum = tr[i].mx = a[l]; tr[i].cnt = 1; tr[i].se = -1; return; } int mid = (l+r)&gt;&gt;1; build(l, mid, i&lt;&lt;1); build(mid+1, r, i&lt;&lt;1|1); push_up(i); } void update_min(int l, int r, int v, int i = 1) { if (v &gt;= tr[i].mx) return; if (l &lt;= tr[i].l &amp;&amp; r &gt;= tr[i].r &amp;&amp; v &gt; tr[i].se) return push_tag(i, v); push_down(i); int mid = (tr[i].l+tr[i].r)&gt;&gt;1; if (l &lt;= mid) update_min(l, r, v, i&lt;&lt;1); if (r &gt; mid) update_min(l, r, v, i&lt;&lt;1|1); push_up(i); } int query_max(int l, int r, int i = 1) { if (l &lt;= tr[i].l &amp;&amp; r &gt;= tr[i].r) return tr[i].mx; push_down(i); int mid = (tr[i].l+tr[i].r)&gt;&gt;1; if (r &lt;= mid) return query_max(l, r, i&lt;&lt;1); if (l &gt; mid) return query_max(l, r, i&lt;&lt;1|1); return max(query_max(l, r, i&lt;&lt;1), query_max(l, r, i&lt;&lt;1|1)); } ll query_sum(int l, int r, int i = 1) { if (l &lt;= tr[i].l &amp;&amp; r &gt;= tr[i].r) return tr[i].sum; push_down(i); int mid = (tr[i].l+tr[i].r)&gt;&gt;1; if (r &lt;= mid) return query_sum(l, r, i&lt;&lt;1); if (l &gt; mid) return query_sum(l, r, i&lt;&lt;1|1); return query_sum(l, r, i&lt;&lt;1)+query_sum(l, r, i&lt;&lt;1|1); } }; 给一个区间[L,R] 加上一个数x 把一个区间[L,R] 里小于x 的数变成x 把一个区间[L,R] 里大于x 的数变成x 求区间[L,R] 的和 求区间[L,R] 的最大值 求区间[L,R] 的最小值 $O(m\\log^2 n)$ 代码 struct SegmentTree { #define rt tr[i] #define ls tr[i&lt;&lt;1] #define rs tr[i&lt;&lt;1|1] typedef int T; struct TreeNode { int l, r; T mn1, mn2, mx1, mx2, cmn, cmx, tag1, tag2, tag3; long long sum; }; vector&lt;T&gt; a; vector&lt;TreeNode&gt; tr; void push_up(int i) { rt.sum = ls.sum+rs.sum; if (ls.mn1 == rs.mn1) { rt.mn1 = ls.mn1; rt.cmn = ls.cmn+rs.cmn; rt.mn2 = min(ls.mn2, rs.mn2); } else if (ls.mn1 &lt; rs.mn1) { rt.mn1 = ls.mn1; rt.cmn = ls.cmn; rt.mn2 = min(ls.mn2, rs.mn1); } else if (ls.mn1 &gt; rs.mn1) { rt.mn1 = rs.mn1; rt.cmn = rs.cmn; rt.mn2 = min(ls.mn1, rs.mn2); } if (ls.mx1 == rs.mx1) { rt.mx1 = ls.mx1; rt.cmx = ls.cmx+rs.cmx; rt.mx2 = max(ls.mx2, rs.mx2); } else if (ls.mx1 &gt; rs.mx1) { rt.mx1 = ls.mx1; rt.cmx = ls.cmx; rt.mx2 = max(ls.mx2, rs.mx1); } else if (ls.mx1 &lt; rs.mx1) { rt.mx1 = rs.mx1; rt.cmx = rs.cmx; rt.mx2 = max(ls.mx1, rs.mx2); } } // 1 2 3 -&gt; min, max, other void push_tag(int i, T add1, T add2, T add3) { if (rt.mn1 == rt.mx1) { add1 == add3 ? add1 = add2 : add2 = add1; // 不应被其他值的标记作用 rt.sum += 1ll*rt.cmn*add1; } else { rt.sum += 1ll*rt.cmn*add1+1ll*rt.cmx*add2 +(rt.r-rt.l+1ll-rt.cmn-rt.cmx)*add3; } if (rt.mn2 == rt.mx1) rt.mn2 += add2; else if (rt.mn2 != INF) rt.mn2 += add3; if (rt.mx2 == rt.mn1) rt.mx2 += add1; else if (rt.mx2 != -INF) rt.mx2 += add3; rt.mn1 += add1; rt.mx1 += add2; rt.tag1 += add1; rt.tag2 += add2; rt.tag3 += add3; } void push_down(int i) { T mn = min(ls.mn1, rs.mn1); T mx = max(ls.mx1, rs.mx1); push_tag(i&lt;&lt;1 , ls.mn1 == mn ? rt.tag1 : rt.tag3, ls.mx1 == mx ? rt.tag2 : rt.tag3, rt.tag3); push_tag(i&lt;&lt;1|1, rs.mn1 == mn ? rt.tag1 : rt.tag3, rs.mx1 == mx ? rt.tag2 : rt.tag3, rt.tag3); rt.tag1 = rt.tag2 = rt.tag3 = 0; } template &lt;typename TT&gt; void build(int n, TT arr[]) { a.resize(1); a.insert(a.end(), arr+1, arr+n+1); tr.resize(n*4+1); build(1, n, 1); } void build(int n, T val = 0) { a.resize(n+1, val); tr.resize(n*4+1); build(1, n, 1); } void build(int l, int r, int i) { rt.l = l; rt.r = r; rt.tag1 = rt.tag2 = rt.tag3 = 0; if (l == r) { rt.sum = rt.mn1 = rt.mx1 = a[l]; rt.mn2 = INF; rt.mx2 = -INF; rt.cmn = rt.cmx = 1; return; } int mid = (l+r)&gt;&gt;1; build(l, mid, i&lt;&lt;1); build(mid+1, r, i&lt;&lt;1|1); push_up(i); } void update_add(int l, int r, T v, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return; if (rt.l &gt;= l &amp;&amp; rt.r &lt;= r) return push_tag(i, v, v, v); push_down(i); update_add(l, r, v, i&lt;&lt;1); update_add(l, r, v, i&lt;&lt;1|1); push_up(i); } void update_max(int l, int r, T v, int i = 1) { if (rt.r &lt; l || rt.l &gt; r || rt.mn1 &gt;= v) return; if (rt.l &gt;= l &amp;&amp; rt.r &lt;= r &amp;&amp; rt.mn2 &gt; v) return push_tag(i, v-rt.mn1, 0, 0); push_down(i); update_max(l, r, v, i&lt;&lt;1); update_max(l, r, v, i&lt;&lt;1|1); push_up(i); } void update_min(int l, int r, T v, int i = 1) { if (rt.r &lt; l || rt.l &gt; r || rt.mx1 &lt;= v) return; if (rt.l &gt;= l &amp;&amp; rt.r &lt;= r &amp;&amp; rt.mx2 &lt; v) return push_tag(i, 0, v-rt.mx1, 0); push_down(i); update_min(l, r, v, i&lt;&lt;1); update_min(l, r, v, i&lt;&lt;1|1); push_up(i); } long long query_sum(int l, int r, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return 0; if (rt.l &gt;= l &amp;&amp; rt.r &lt;= r) return rt.sum; push_down(i); return query_sum(l, r, i&lt;&lt;1)+query_sum(l, r, i&lt;&lt;1|1); } T query_max(int l, int r, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return -INF; if (rt.l &gt;= l &amp;&amp; rt.r &lt;= r) return rt.mx1; push_down(i); return max(query_max(l, r, i&lt;&lt;1), query_max(l, r, i&lt;&lt;1|1)); } T query_min(int l, int r, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return INF; if (rt.l &gt;= l &amp;&amp; rt.r &lt;= r) return rt.mn1; push_down(i); return min(query_min(l, r, i&lt;&lt;1), query_min(l, r, i&lt;&lt;1|1)); } #undef rt #undef ls #undef rs }; 区间历史最值区间加区间修改 区间加 区间修改 区间最大值 区间历史最大值 $O(m\\log n)$ 代码 struct SegmentTree { #define rt tr[i] #define ls tr[i&lt;&lt;1] #define rs tr[i&lt;&lt;1|1] typedef int T; struct TreeNode { int l, r; bool tag; T add, cov, mx, hadd, hcov, hmx; } tr[N&lt;&lt;2]; void push_up(int i) { rt.mx = max(ls.mx, rs.mx); rt.hmx = max(ls.hmx, rs.hmx); } void plus(int i, T k, T hk) { rt.hmx = max(rt.hmx, rt.mx+hk); rt.mx += k; rt.tag ? rt.hcov = max(rt.hcov, rt.cov+hk), rt.cov += k : rt.hadd = max(rt.hadd, rt.add+hk), rt.add += k; } void cover(int i, T k, T hk) { rt.hmx = max(rt.hmx, hk); rt.mx = k; rt.hcov = max(rt.hcov, hk); rt.cov = k; rt.tag = 1; } void push_down(int i) { if (rt.add) { plus(i&lt;&lt;1 , rt.add, rt.hadd); plus(i&lt;&lt;1|1, rt.add, rt.hadd); rt.add = rt.hadd = 0; } if (rt.tag) { cover(i&lt;&lt;1 , rt.cov, rt.hcov); cover(i&lt;&lt;1|1, rt.cov, rt.hcov); rt.tag = 0; rt.hcov = -INF; } } void build(int l, int r, int i = 1) { rt.l = l; rt.r = r; rt.tag = false; rt.add = rt.hadd = 0; rt.hcov = -INF; if (l == r) return rt.hmx = rt.mx = 0, void(); int mid = (l+r)&gt;&gt;1; build(l, mid, i&lt;&lt;1); build(mid+1, r, i&lt;&lt;1|1); push_up(i); } T query_max(int l, int r, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return -INF; if (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) return rt.mx; push_down(i); return max(query_max(l, r, i&lt;&lt;1), query_max(l, r, i&lt;&lt;1|1)); } T query_hmax(int l, int r, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return -INF; if (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) return rt.hmx; push_down(i); return max(query_hmax(l, r, i&lt;&lt;1), query_hmax(l, r, i&lt;&lt;1|1)); } void update_add(int l, int r, T v, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return; if (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) return plus(i, v, v); push_down(i); update_add(l, r, v, i&lt;&lt;1); update_add(l, r, v, i&lt;&lt;1|1); push_up(i); } void update_cov(int l, int r, T v, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return; if (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) return cover(i, v, v); push_down(i); update_cov(l, r, v, i&lt;&lt;1); update_cov(l, r, v, i&lt;&lt;1|1); push_up(i); } #undef rt #undef ls #undef rs }; 区间最值操作与历史最值询问同向单点查询 代码 struct SegmentTree { #define rt tr[i] #define ls tr[i&lt;&lt;1] #define rs tr[i&lt;&lt;1|1] typedef long long T; struct Tag { T add, mx; Tag(T _add = 0, T _mx = -INF) : add(_add), mx(_mx) {} Tag operator +(const Tag &amp;t) const { // 合并tag return Tag(max(-INF, add+t.add), max(mx+t.add, t.mx)); } Tag operator *(const Tag &amp;t) const { // 取max return Tag(max(add, t.add), max(mx, t.mx)); } Tag&amp; operator +=(const Tag &amp;t) { return *this = *this+t; } Tag&amp; operator *=(const Tag &amp;t) { return *this = *this*t; } }; struct TreeNode { int l, r; Tag his, cur; } tr[N&lt;&lt;2]; void push_tag(int i, Tag hk, Tag k) { rt.his *= rt.cur+hk; rt.cur += k; } void push_down(int i) { push_tag(i&lt;&lt;1 , rt.his, rt.cur); push_tag(i&lt;&lt;1|1, rt.his, rt.cur); rt.his = rt.cur = Tag(); } void build(int l, int r, int i = 1) { rt.l = l; rt.r = r; rt.his = rt.cur = Tag(); if (l == r) return rt.his = rt.cur = Tag(a[l]), void(); int mid = (l+r)&gt;&gt;1; build(l, mid, i&lt;&lt;1); build(mid+1, r, i&lt;&lt;1|1); } // add(val, -INF) cov(-INF, val) max(0, val) void update(int l, int r, T a, T x = -INF, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return; if (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) return push_tag(i, Tag(a, x), Tag(a, x)); push_down(i); update(l, r, a, x, i&lt;&lt;1); update(l, r, a, x, i&lt;&lt;1|1); } T query_max(int x, int i = 1) { if (rt.l == rt.r) return max(rt.cur.add, rt.cur.mx); push_down(i); int mid = (rt.l+rt.r)&gt;&gt;1; if (x &lt;= mid) return query_max(x, i&lt;&lt;1); else return query_max(x, i&lt;&lt;1|1); } T query_hmax(int x, int i = 1) { if (rt.l == rt.r) return max(rt.his.add, rt.his.mx); push_down(i); int mid = (rt.l+rt.r)&gt;&gt;1; if (x &lt;= mid) return query_hmax(x, i&lt;&lt;1); else return query_hmax(x, i&lt;&lt;1|1); } #undef rt #undef ls #undef rs }; 区间最值操作与历史最值询问反向 区间加 区间max 询问min 历史min 代码 struct SegmentTree { #define rt tr[i] #define ls tr[i&lt;&lt;1] #define rs tr[i&lt;&lt;1|1] typedef int T; struct TreeNode { int l, r; T mn, hmn, se, tag1, htag1, tag2, htag2; } tr[N&lt;&lt;2]; void push_up(int i) { rt.hmn = min(ls.hmn, rs.hmn); if (ls.mn == rs.mn) { rt.mn = ls.mn; rt.se = min(ls.se, rs.se); } else if (ls.mn &lt; rs.mn) { rt.mn = ls.mn; rt.se = min(ls.se, rs.mn); } else if (ls.mn &gt; rs.mn) { rt.mn = rs.mn; rt.se = min(ls.mn, rs.se); } } void push_tag(int i, T add1, T hadd1, T add2, T hadd2) { rt.hmn = min(rt.hmn, rt.mn+hadd1); rt.htag1 = min(rt.htag1, rt.tag1+hadd1); rt.mn += add1; rt.tag1 += add1; rt.htag2 = min(rt.htag2, rt.tag2+hadd2); if (rt.se != INF) rt.se += add2; rt.tag2 += add2; } void push_down(int i) { T mn = min(ls.mn, rs.mn); push_tag(i&lt;&lt;1 , ls.mn == mn ? rt.tag1 : rt.tag2, ls.mn == mn ? rt.htag1 : rt.htag2, rt.tag2, rt.htag2); push_tag(i&lt;&lt;1|1, rs.mn == mn ? rt.tag1 : rt.tag2, rs.mn == mn ? rt.htag1 : rt.htag2, rt.tag2, rt.htag2); rt.tag1 = rt.htag1 = rt.tag2 = rt.htag2 = 0; } void build(int l, int r, int i = 1) { rt.l = l; rt.r = r; rt.tag1 = rt.htag1 = rt.tag2 = rt.htag2 = 0; if (l == r) { rt.hmn = rt.mn = a[l]; rt.se = INF; return; } int mid = (l+r)&gt;&gt;1; build(l, mid, i&lt;&lt;1); build(mid+1, r, i&lt;&lt;1|1); push_up(i); } void update_add(int l, int r, T v, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return; if (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) return push_tag(i, v, v, v, v); push_down(i); update_add(l, r, v, i&lt;&lt;1); update_add(l, r, v, i&lt;&lt;1|1); push_up(i); } void update_max(int l, int r, T v, int i = 1) { if (rt.r &lt; l || rt.l &gt; r || v &lt;= rt.mn) return; if (l &lt;= rt.l &amp;&amp; rt.r &lt;= r &amp;&amp; v &lt; rt.se) return push_tag(i, v-rt.mn, v-rt.mn, 0, 0); push_down(i); update_max(l, r, v, i&lt;&lt;1); update_max(l, r, v, i&lt;&lt;1|1); push_up(i); } T query_min(int l, int r, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return INF; if (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) return rt.mn; push_down(i); return min(query_min(l, r, i&lt;&lt;1), query_min(l, r, i&lt;&lt;1|1)); } T query_hmin(int l, int r, int i = 1) { if (rt.r &lt; l || rt.l &gt; r) return INF; if (l &lt;= rt.l &amp;&amp; rt.r &lt;= r) return rt.hmn; push_down(i); return min(query_hmin(l, r, i&lt;&lt;1), query_hmin(l, r, i&lt;&lt;1|1)); } #undef rt #undef ls #undef rs }; 维护历史最值和树套树在第一维线段树的每个结点建立第二维线段树 K-D Tree | KDTLuogu P4148 简单题 将格子(x,y)加上v 求(xl,yl)到(xr,yr)区间和 代码 struct Node { int x, y, v; } s[N]; bool cmpx(int a, int b) { return s[a].x &lt; s[b].x; } bool cmpy(int a, int b) { return s[a].y &lt; s[b].y; } struct KDTree { double alpha = 0.725; int rt, cur, xl, yl, xr, yr; //rt根结点 int d[N], siz[N], lc[N], rc[N]; //d=1竖着砍，sz子树大小 int L[N], R[N], D[N], U[N]; //该子树的界线 int sum[N]; //维护的二维区间信息（二维区间和） int g[N], gt; void pia(int x) { //将树还原成序列g if (!x) return; pia(lc[x]); g[++gt] = x; pia(rc[x]); } void push_up(int x) { //更新信息 siz[x] = siz[lc[x]] + siz[rc[x]] + 1; sum[x] = sum[lc[x]] + sum[rc[x]] + s[x].v; L[x] = R[x] = s[x].x; D[x] = U[x] = s[x].y; if (lc[x]) { L[x] = min(L[x], L[lc[x]]); R[x] = max(R[x], R[lc[x]]); D[x] = min(D[x], D[lc[x]]); U[x] = max(U[x], U[lc[x]]); } if (rc[x]) { L[x] = min(L[x], L[rc[x]]); R[x] = max(R[x], R[rc[x]]); D[x] = min(D[x], D[rc[x]]); U[x] = max(U[x], U[rc[x]]); } } int build(int l, int r) { //以序列g[l..r]为模板重建树，返回根结点 if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; double ax = 0, ay = 0, sx = 0, sy = 0; for (int i = l; i &lt;= r; i++) ax += s[g[i]].x, ay += s[g[i]].y; ax /= (r - l + 1); ay /= (r - l + 1); for (int i = l; i &lt;= r; i++) { sx += (ax - s[g[i]].x) * (ax - s[g[i]].x); sy += (ay - s[g[i]].y) * (ay - s[g[i]].y); } if (sx &gt; sy) nth_element(g + l, g + mid, g + r + 1, cmpx), d[g[mid]] = 1; else nth_element(g + l, g + mid, g + r + 1, cmpy), d[g[mid]] = 2; lc[g[mid]] = build(l, mid - 1); rc[g[mid]] = build(mid + 1, r); push_up(g[mid]); return g[mid]; } void rebuild(int &amp;x) { gt = 0; pia(x); x = build(1, gt); } bool bad(int x) { return alpha * siz[x] &lt;= max(siz[lc[x]], siz[rc[x]]); } void insert(int x, int y, int v) { //在(x,y)处插入元素 s[++cur] = {x, y, v}; insert(rt, cur); } void insert(int &amp;x, int v) { if (!x) return push_up(x = v); if (d[x]) insert(s[v].x &lt;= s[x].x ? lc[x] : rc[x], v); else insert(s[v].y &lt;= s[x].y ? lc[x] : rc[x], v); push_up(x); if (bad(x)) rebuild(x); } int query(int xl, int yl, int xr, int yr) { //查询[x1,x2]×[y1,y2]的区间和 if (xl &gt; xr) swap(xl, xr); if (yl &gt; yr) swap(yl, yr); this-&gt;xl = xl; this-&gt;yl = yl; this-&gt;xr = xr; this-&gt;yr = yr; return query(rt); } int query(int x) { if (!x || xr &lt; L[x] || xl &gt; R[x] || yr &lt; D[x] || yl &gt; U[x]) return 0; if (xl &lt;= L[x] &amp;&amp; R[x] &lt;= xr &amp;&amp; yl &lt;= D[x] &amp;&amp; U[x] &lt;= yr) return sum[x]; int res = 0; if (xl &lt;= s[x].x &amp;&amp; s[x].x &lt;= xr &amp;&amp; yl &lt;= s[x].y &amp;&amp; s[x].y &lt;= yr) res += s[x].v; return query(lc[x]) + query(rc[x]) + res; } }; Link Cut Tree | LCT 树状数组一维单点修改区间查询 区间修改单点查询 代码 template &lt;typename T&gt; struct BinaryIndexedTree { int n; vector&lt;T&gt; tr; void init(const int &amp;n) { this-&gt;n = n; tr = vector&lt;T&gt;(n+1, 0); } void add(const int &amp;x, const T &amp;v) { for (int i = x; i &lt;= n; i += i&amp;-i) tr[i] += v; } void add(const int &amp;x, const int &amp;y, const T &amp;v) { add(x, v); add(y+1, -v); } T query(const int &amp;x) { T res = 0; for (int i = x ; i; i -= i&amp;-i) res += tr[i]; return res; } T query(const int &amp;x, const int &amp;y) { return query(y)-query(x-1); } }; O(n)初始化 代码 template &lt;typename TT&gt; void init(const int &amp;_n, const TT a[]) { n = _n; clear(); for (int i = 1; i &lt;= n; ++i) { tr[i] += a[i]; if (i+(i&amp;-i) &lt;= n) tr[i+(i&amp;-i)] += tr[i]; } } 区间修改区间查询 代码 struct BIT{ static const int SIZE=1e6+5; ll bit1[SIZE],bit2[SIZE]; int limit; void init(int n=SIZE-1){ limit=n; for(int i=1;i&lt;=n;i++)bit1[i]=bit2[i]=0; } BIT(){init();} void add(ll *bit,int x,ll v){ while(x&lt;=limit)bit[x]+=v,x+=x&amp;-x; } ll query(ll *bit,int x){ ll res=0; while(x)res+=bit[x],x-=x&amp;-x; return res; } void add(int l,int r,ll v){ add(bit1,l,v); add(bit2,l,v*l); add(bit1,r+1,-v); add(bit2,r+1,-v*(r+1)); } ll query(int l,int r){ return (r+1)*query(bit1,r)-query(bit2,r)-l*query(bit1,l-1)+query(bit2,l-1); } }bit; 二维单点修改区间查询 代码 template &lt;typename T&gt; struct BIT_2D { int n, m; T a[N][N], tr[N][N]; BIT_2D() { memset(tr, 0, sizeof tr); } void init(const int &amp;_n, const int &amp;_m) { n = _n; m = _m; memset(a, 0, sizeof a); memset(tr, 0, sizeof tr); } void add(const int &amp;x, const int &amp;y, const T &amp;k) { a[x][y] += k; for (int i = x; i &lt;= n; i += i&amp;-i) for (int j = y; j &lt;= m; j += j&amp;-j) tr[i][j] += k; } T query(const int &amp;x, const int &amp;y) { return a[x][y]; // return query(x, y, x, y); } T query(int r1, int c1, int r2, int c2) { if (r1 &gt; r2) swap(r1, r2); if (c1 &gt; c2) swap(c1, c2); return _query(r2, c2)-_query(r1-1, c2)-_query(r2, c1-1)+_query(r1-1, c1-1); } T _query(const int &amp;x, const int &amp;y) { T res = 0; for (int i = x; i; i -= i&amp;-i) for (int j = y; j; j -= j&amp;-j) res += tr[i][j]; return res; } }; 可持久化数组 代码 template &lt;typename T&gt; struct PersistantArray { static const int NN = N*(log2(N)+3); int rt[N], ls[NN], rs[NN], val[NN], tot, n; void build(const int &amp;n) { this-&gt;n = n; tot = 0; rt[0] = build(1, n); } int build(const int &amp;l, const int &amp;r) { int cur = ++tot; assert(tot &lt; NN); if (l == r) return val[cur] = a[l], cur; int mid = (l+r)&gt;&gt;1; ls[cur] = build(l, mid); rs[cur] = build(mid+1, r); return cur; } void update(const int &amp;cur, const int &amp;pre, const int &amp;x, const T &amp;k) { rt[cur] = update(rt[pre], x, k, 1, n); } int update(const int &amp;pre, const int &amp;x, const T &amp;k, const int &amp;l, const int &amp;r) { int cur = ++tot; assert(tot &lt; NN); if (l == x &amp;&amp; r == x) return val[cur] = k, cur; ls[cur] = ls[pre]; rs[cur] = rs[pre]; int mid = (l+r)&gt;&gt;1; if (x &lt;= mid) ls[cur] = update(ls[pre], x, k, l, mid); else rs[cur] = update(rs[pre], x, k, mid+1, r); return cur; } T query(const int &amp;cur, const int &amp;x) { return query(rt[cur], x, 1, n); } T query(const int &amp;cur, const int &amp;x, const int &amp;l, const int &amp;r) { if (l == x &amp;&amp; r == x) return val[cur]; int mid = (l+r)&gt;&gt;1; if (x &lt;= mid) return query(ls[cur], x, l, mid); return query(rs[cur], x, mid+1, r); } }; 可持久化线段树(主席树)自带离散 代码 template &lt;typename T&gt; struct PersistantSegmentTree { static const int NN = N*(log2(N)+5); int rt[N], sum[NN], ls[NN], rs[NN], tot, sz; vector&lt;T&gt; des; void build(const T a[], const int &amp;n) { vector&lt;T&gt;(a+1, a+n+1).swap(des); sort(des.begin(), des.end()); des.erase(unique(des.begin(), des.end()), des.end()); sz = des.size(); tot = 0; rt[0] = _build(1, sz); for (int i = 1; i &lt;= n; ++i) { int t = lower_bound(des.begin(), des.end(), a[i])-des.begin()+1; rt[i] = _update(rt[i-1], 1, sz, t); } } void update(const int &amp;id, const T &amp;k) { int t = lower_bound(des.begin(), des.end(), k)-des.begin()+1; rt[id] = _update(rt[id-1], 1, sz, t); } T query(const int &amp;l, const int &amp;r, const int &amp;k) { return des[_query(rt[l-1], rt[r], 1, sz, k)-1]; } private: int _build(const int &amp;l, const int &amp;r) { int cur = ++tot; sum[cur] = 0; if (l &gt;= r) return cur; int mid = (l+r)&gt;&gt;1; ls[cur] = _build(l, mid); rs[cur] = _build(mid+1, r); return cur; } int _update(const int &amp;pre, const int &amp;l, const int &amp;r, const int &amp;k) { int cur = ++tot; ls[cur] = ls[pre]; rs[cur] = rs[pre]; sum[cur] = sum[pre]+1; if (l &gt;= r) return cur; int mid = (l+r)&gt;&gt;1; if (k &lt;= mid) ls[cur] = _update(ls[pre], l, mid, k); else rs[cur] = _update(rs[pre], mid+1, r, k); return cur; } int _query(const int &amp;u, const int &amp;v, const int &amp;l, const int &amp;r, const int &amp;k) { if (l &gt;= r) return l; int num = sum[ls[v]]-sum[ls[u]], mid = (l+r)&gt;&gt;1; if (num &gt;= k) return _query(ls[u], ls[v], l, mid, k); else return _query(rs[u], rs[v], mid+1, r, k-num); } }; 不带离散 代码 template &lt;typename T&gt; struct PersistantSegmentTree { static const int NN = N*(log2(N)+5); int rt[N], sum[NN], ls[NN], rs[NN], tot, n; void build(const int &amp;n) { this-&gt;n = n; tot = 0; rt[0] = _build(1, n); } void update(const int &amp;cur, const int &amp;pre, const T &amp;k) { rt[cur] = _update(rt[pre], 1, n, k); } T query(const int &amp;l, const int &amp;r, const int &amp;k) { return _query(rt[l-1], rt[r], 1, n, k); } private: int _build(const int &amp;l, const int &amp;r) { int cur = ++tot; sum[cur] = 0; if (l &gt;= r) return cur; int mid = (l+r)&gt;&gt;1; ls[cur] = _build(l, mid); rs[cur] = _build(mid+1, r); return cur; } int _update(const int &amp;pre, const int &amp;l, const int &amp;r, const int &amp;k) { int cur = ++tot; ls[cur] = ls[pre]; rs[cur] = rs[pre]; sum[cur] = sum[pre]+1; if (l &gt;= r) return cur; int mid = (l+r)&gt;&gt;1; if (k &lt;= mid) ls[cur] = _update(ls[pre], l, mid, k); else rs[cur] = _update(rs[pre], mid+1, r, k); return cur; } int _query(const int &amp;u, const int &amp;v, const int &amp;l, const int &amp;r, const int &amp;k) { if (l &gt;= r) return l; int num = sum[ls[v]]-sum[ls[u]], mid = (l+r)&gt;&gt;1; if (num &gt;= k) return _query(ls[u], ls[v], l, mid, k); else return _query(rs[u], rs[v], mid+1, r, k-num); } }; 动态开点?oj可以跑本地莫名re 代码 template &lt;class T&gt; class PersistantSegmentTree { public: void init(int n) { tot = 0; this-&gt;n = n; rt = vector&lt;int&gt;(1, 0); tr = vector&lt;TreeNode&gt;(1, TreeNode{0, 0, 0}); } void update(int cur, int pre, int k, T v = 1) { rt.resize(cur+1); // assert rt.size()+1 &lt;= cur rt[cur] = update(rt[pre], 1, n, k, v); } int update(int pre, int l, int r, int k, T v) { int cur = ++tot; // assert tot == tr.size() tr.emplace_back(tr[pre]); tr[cur].sum += v; if (l == r) return cur; int mid = (l+r)&gt;&gt;1; if (k &lt;= mid) tr[cur].lc = update(tr[pre].lc, l, mid, k, v); else tr[cur].rc = update(tr[pre].rc, mid+1, r, k, v); return cur; } T query(int l, int r, int ql, int qr) { return query(rt[l-1], rt[r], 1, n, ql, qr); } // [u, v] 段 [ql, qr] 区间和 T query(int u, int v, int l, int r, int ql, int qr) { if (!u &amp;&amp; !v) return 0; if (l &gt;= ql &amp;&amp; r &lt;= qr) return tr[v].sum-tr[u].sum; int mid = (l+r)&gt;&gt;1; if (qr &lt;= mid) return query(tr[u].lc, tr[v].lc, l, mid, ql, qr); if (ql &gt; mid) return query(tr[u].rc, tr[v].rc, mid+1, r, ql, qr); return query(tr[u].lc, tr[v].lc, l, mid, ql, qr)+query(tr[u].rc, tr[v].rc, mid+1, r, ql, qr); } private: struct TreeNode { int lc, rc; T sum; }; int tot, n; vector&lt;int&gt; rt; vector&lt;TreeNode&gt; tr; }; dingbacode 高地 代码 template &lt;typename T&gt; struct PersistantSegmentTree { static const int NN = N*(log2(N)+5); int rt[N], ls[NN], rs[NN], tot, n; T sum[NN]; void build(const int &amp;n) { this-&gt;n = n; tot = 0; rt[0] = _build(1, n); } void update(const int &amp;cur, const int &amp;pre, const int &amp;k, const T &amp;v) { rt[cur] = _update(rt[pre], 1, n, k, v); } T query(const int &amp;l, const int &amp;r, const int &amp;ql, const int &amp;qr) { return _query(rt[l-1], rt[r], 1, n, ql, qr); } private: int _build(const int &amp;l, const int &amp;r) { int cur = ++tot; sum[cur] = 0; if (l &gt;= r) return cur; int mid = (l+r)&gt;&gt;1; ls[cur] = _build(l, mid); rs[cur] = _build(mid+1, r); return cur; } int _update(const int &amp;pre, const int &amp;l, const int &amp;r, const int &amp;k, const T &amp;v) { int cur = ++tot; ls[cur] = ls[pre]; rs[cur] = rs[pre]; sum[cur] = sum[pre]+v; if (l &gt;= r) return cur; int mid = (l+r)&gt;&gt;1; if (k &lt;= mid) ls[cur] = _update(ls[pre], l, mid, k, v); else rs[cur] = _update(rs[pre], mid+1, r, k, v); return cur; } // [u, v] 段 [ql, qr] 区间和 T _query(const int &amp;u, const int &amp;v, const int &amp;l, const int &amp;r, const int &amp;ql, const int &amp;qr) { if (l &gt;= ql &amp;&amp; r &lt;= qr) return sum[v]-sum[u]; int mid = (l+r)&gt;&gt;1; if (qr &lt;= mid) return _query(ls[u], ls[v], l, mid, ql, qr); if (ql &gt; mid) return _query(rs[u], rs[v], mid+1, r, ql, qr); return _query(ls[u], ls[v], l, mid, ql, qr)+_query(rs[u], rs[v], mid+1, r, ql, qr); } }; 分块例题 代码 struct FenKuai { typedef long long T; int t; // 每组大小 static const int NN = static_cast&lt;int&gt;(sqrt(N))+7; T a[N], sum[NN], add[NN]; FenKuai() { memset(a, 0, sizeof a); memset(sum, 0, sizeof sum); memset(add, 0, sizeof add); } void init() { t = static_cast&lt;int&gt;(sqrt(n)+0.5); for (int i = 0; i &lt; n; ++i) sum[i/t] += a[i]; } void update(int x, T k) { a[x] += k; sum[x/t] += k; } void update(int x, int y, T k) { for ( ; x &lt;= y &amp;&amp; x%t; ++x) a[x] += k, sum[x/t] += k; for ( ; x+t-1 &lt;= y; x += t) sum[x/t] += k*t, add[x/t] += k; for ( ; x &lt;= y; ++x) a[x] += k, sum[x/t] += k; } T query(int x) { return a[x]+add[x/t]; } T query(int x, int y) { T res = 0; for ( ; x &lt;= y &amp;&amp; x%t; ++x) res += a[x]+add[x/t]; for ( ; x+t-1 &lt;= y; x += t) res += sum[x/t]; for ( ; x &lt;= y; ++x) res += a[x]+add[x/t]; return res; } } B; 代码 struct FenKuai { typedef int T; int t; // 每组大小 T a[N], b[N], add[N]; FenKuai() { memset(a, 0, sizeof a); memset(b, 0, sizeof b); memset(add, 0, sizeof add); } void build(int x) { for (int i = x*t; i &lt; min(x*t+t, n); ++i) b[i] = a[i]; sort(b+x*t, b+min(x*t+t, n)); } void init() { t = static_cast&lt;int&gt;(sqrt(n)+0.5); for (int i = 0; i*t &lt; n; ++i) build(i); } void update(int x, int y, T c) { int i = x; for ( ; i &lt;= y &amp;&amp; i%t; ++i) a[i] += c; build(x/t); for ( ; i+t-1 &lt;= y; i += t) add[i/t] += c; for ( ; i &lt;= y; ++i) a[i] += c; build(y/t); } T query(int x, int y, long long c) { T res = 0; int i = x; for ( ; i &lt;= y &amp;&amp; i%t; ++i) res += (a[i]+add[i/t] &lt; c*c); for ( ; i+t-1 &lt;= y; i += t) res += lower_bound(b+i, b+i+t, c*c-add[i/t])-(b+i); for ( ; i &lt;= y; ++i) res += (a[i]+add[i/t] &lt; c*c); return res; } } B; 代码 struct FenKuai { typedef int T; int t, sz; static const int NN = static_cast&lt;int&gt;(sqrt(N))+7; T a[N]; deque&lt;int&gt; q[NN]; void init(int _n) { sz = _n; t = static_cast&lt;int&gt;(sqrt(sz*1.5)+0.5); for (int i = 0; i &lt; sz; ++i) q[i/t].push_back(a[i]); } void update(int x, int k) { stack&lt;int&gt; tmp; for (int i = 0; i != x%t; ++i) { tmp.push(q[x/t].front()); q[x/t].pop_front(); } q[x/t].push_front(k); while (tmp.size()) { q[x/t].push_front(tmp.top()); tmp.pop(); } ++sz; if (sz/t == x/t) return; for (int i = x/t, val; i &lt; sz/t; ++i) { val = q[i].back(); q[i].pop_back(); q[i+1].push_front(val); } } T query(int x) { stack&lt;int&gt; tmp; for (int i = 0; i != x%t; ++i) { tmp.push(q[x/t].front()); q[x/t].pop_front(); } int res = q[x/t].front(); while (tmp.size()) { q[x/t].push_front(tmp.top()); tmp.pop(); } return res; } } B; 莫队$O(1)修改$ 一般取 $block = \\frac{n}{\\sqrt{m} }, O(n\\sqrt{m})$ 移动前两步先扩大区间 $l–,r++$ 后两步缩小区间 $l++,r–$ 奇偶性排序 代码 template &lt;typename T&gt; bool cmp(const T &amp;q1, const T &amp;q2) { return q1.l/block != q2.l/block ? q1.l &lt; q2.l : (q1.l/block)&amp;1 ? q1.r &lt; q2.r : q1.r &gt; q2.r; } 带修改莫队以 $n^{\\frac{2}{3} }$ 为一块，分成了 $n^{\\frac{1}{3} }$ 块，第一关键字是左端点所在块，第二关键字是右端点所在块，第三关键字是时间. 复杂度 $O(n^{\\frac{5}{3} })$ 代码 template &lt;typename T&gt; bool cmp(const T &amp;q1, const T &amp;q2) { return q1.l/block != q2.l/block ? q1.l &lt; q2.l : q1.r/block != q2.r/block ? q1.r &lt; q2.r : q1.t &lt; q2.t; } 值域分块维护块的前缀和以及块内部前缀和, $O(\\sqrt{n})$ 修改, $O(1)$ 求区间和 代码 template &lt;typename T&gt; struct PreSum { int n, block; T s[N], t[(int)sqrt(N)+3]; void init(int n) { this-&gt;n = n; block = sqrt(n); } void add(int x, T k) { for (int i = x; i/block == x/block &amp;&amp; i &lt;= n; ++i) s[i] += k; for (int i = x/block+1; i &lt;= n/block; ++i) t[i] += k; } T query(int x) { return t[x/block]+s[x]; } }; template &lt;typename T&gt; struct SufSum { int n, block; T s[N], t[(int)sqrt(N)+3]; void init(int n) { this-&gt;n = n; block = sqrt(n); } void add(int x, T k) { for (int i = x; i/block == x/block &amp;&amp; i &gt;= 1; --i) s[i] += k; for (int i = x/block-1; i &gt;= 0; --i) t[i] += k; } T query(int x) { return t[x/block]+s[x]; } }; 二次离线莫队大概是一种需要维护信息具有可减性的莫队。只要具可减性，就可以容斥，就可以二次离线。所谓『二次离线』，大概是指由于普通莫队无法快速计算贡献，所以第一次离线把询问离线下来，第二次离线把莫队的转移过程离线下来。 由于信息具有可减性(比如常见的「点对数」)，记 $(a,b)(c,d)$ 表示区间 $[a,b]$ 内的点和区间 $[c,d]$ 内的点对彼此产生的贡献(区间内部不算)。 $[l,r]\\to[l+t,r],\\sum\\limits_{i=l}^{l+t−1}(i,i)(i+1,r)=\\sum\\limits_{i=l}^{l+t−1}(i,i)(1,r)−(i,i)(1,i)$ $[l,r]\\to[l-t,r],\\sum\\limits_{i=l-t}^{l-1}(i,i)(i+1,r)=\\sum\\limits_{i=l-t}^{l-1}(i,i)(1,r)−(i,i)(1,i)$ $[l,r]\\to[l,r+t],\\sum\\limits_{i=r+1}^{r+t}(i,i)(l,i-1)=\\sum\\limits_{i=r+1}^{r+t}(1,i-1)(i,i)-(1,l-1)(i,i)$ $[l,r]\\to[l,r-t],\\sum\\limits_{i=r-t+1}^{r}(i,i)(l,i-1)=\\sum\\limits_{i=r-t+1}^{r}(1,i-1)(i,i)-(1,l-1)(i,i)$ 对于 $(1,i-1)(i,i)$ 没什么好说,暴力处理前缀和 对于 $(1,l-1)(i,i)$ 由于莫队的复杂度,至多有 $n\\sqrt{m}$ 个不同询问,把每个询问 打标记到左端点(比如 $[l,r]\\to [l,r-t]$ 就打到 $l-1$ 上), 最后扫一遍全部 $i \\in [1,n]$ ,处理出询问值, 因为此时 $i$ 枚举 $O(n)$ 次,可以用『值域分块』技巧。这样最终复杂度 $O(n\\sqrt n+n\\sqrt{n})$ 求区间逆序对 代码 struct Query { int id, l, r; Query() {} Query(int i, int _l, int _r) : id(i), l(_l), r(_r) {} }; int n, m, block; int a[N]; long long res[N], sumil[N], sumir[N], ans[N]; Query q[N]; SufSum&lt;int&gt; suml; PreSum&lt;int&gt; sumr; vector&lt;Query&gt; ql[N], qr[N]; inline void calc_sumi() { static BinaryIndexedTree&lt;int&gt; tree; tree.init(n); for (int i = 1; i &lt;= n; ++i) { sumil[i] = sumil[i-1]+i-1-tree.query(a[i]); tree.add(a[i], 1); } tree.clear(); for (int i = n; i; --i) { sumir[i] = sumir[i+1]+tree.query(a[i]-1); tree.add(a[i], 1); } } signed main() { read(n); read(m); for (int i = 1; i &lt;= n; ++i) read(a[i]); discrete(); block = n/sqrt(m); for (int i = 1; i &lt;= m; ++i) { q[i].id = i; read(q[i].l); read(q[i].r); } sort(q+1, q+m+1, cmp); calc_sumi(); q[0] = Query(0, 1, 0); for (int i = 1, ul, vl, ur, vr; i &lt;= m; ++i) { ul = q[i-1].l; ur = q[i-1].r; vl = q[i].l; vr = q[i].r; res[i] = sumil[vr]-sumil[ur]+sumir[vl]-sumir[ul]; if (vl &lt; ul) qr[vr+1].emplace_back(-i, vl, ul-1); if (vl &gt; ul) qr[vr+1].emplace_back(+i, ul, vl-1); if (vr &lt; ur) ql[ul-1].emplace_back(+i, vr+1, ur); if (vr &gt; ur) ql[ul-1].emplace_back(-i, ur+1, vr); } suml.init(n+1); for (int i = 1; i &lt;= n; ++i) { suml.add(a[i], 1); for (auto &amp;qq : ql[i]) { for (int j = qq.l; j &lt;= qq.r; ++j) { if (qq.id &gt; 0) res[qq.id] += suml.query(a[j]+1); else res[-qq.id] -= suml.query(a[j]+1); } } } sumr.init(n); for (int i = n; i; --i) { sumr.add(a[i], 1); for (auto &amp;qq : qr[i]) { for (int j = qq.l; j &lt;= qq.r; ++j) { if (qq.id &gt; 0) res[qq.id] += sumr.query(a[j]-1); else res[-qq.id] -= sumr.query(a[j]-1); } } } for (int i = 1; i &lt;= m; ++i) { res[i] += res[i-1]; ans[q[i].id] = res[i]; } for (int i = 1; i &lt;= m; ++i) write(ans[i]), putchar('\\n'); return 0; } ST表一维 代码 template &lt;typename T, typename U = std::greater&lt;T&gt;&gt; struct ST { static const int NN = 31-__builtin_clz(N)+3; static const T INF = 1e9; int lg2[N]; U cmp = U(); T rmq[N][NN]; ST() { fill(rmq[0], rmq[0]+N*NN, cmp(-INF, +INF) ? INF : -INF); for (int i = 2; i &lt; N; ++i) lg2[i] = lg2[i&gt;&gt;1]+1; } T&amp; operator [] (const int &amp;i) { return rmq[i][0]; } void init(const T &amp;val = 0) { fill(rmq[0], rmq[0]+N*NN, val); } T mv(const T &amp;x, const T &amp;y) { return cmp(x, y) ? x : y; } // rmq[i][j] ==&gt; [i, i+2^j-1] void build(T a[], const int &amp;n) { for (int i = n; i; --i) { rmq[i][0] = a[i]; for (int j = 1; j &lt;= lg2[n-i+1]; ++j) rmq[i][j] = mv(rmq[i][j-1], rmq[i+(1&lt;&lt;(j-1))][j-1]); } } T query(const int &amp;l, const int &amp;r) { if (l &gt; r) return query(r, l); int k = lg2[r-l+1]; return mv(rmq[l][k], rmq[r-(1&lt;&lt;k)+1][k]); } }; /* rmq[i][j] ==&gt; [i-2^j+1, i] void build(T a[], const int &amp;n) { for (int i = 1; i &lt;= n; ++i) { rmq[i][0] = a[i]; for (int j = 1; j &lt;= lg2[i]; ++j) rmq[i][j] = mv(rmq[i][j-1], rmq[i-(1&lt;&lt;(j-1))][j-1]); } } T query(const int &amp;l, const int &amp;r) { if (l &gt; r) return query(r, l); int k = lg2[r-l+1]; return mv(rmq[r][k], rmq[l+(1&lt;&lt;k)-1][k]); } */ 二维$O(nm\\log n \\log m)$ 代码 template &lt;typename T, typename U = std::greater&lt;T&gt;&gt; struct ST { static const int NN = (int)log2(N)+3; static const T INF = 1e9; U cmp = U(); T rmq[N][N][NN][NN]; // rmq[i][j][k][l] [i, j] [i+2^k-1, j+2^l-1] ST() { init(); } ST(const T &amp;val) { init(val); } T&amp; operator [] (const int &amp;i) { return rmq[i][0]; } void init(){ fill(rmq[0][0][0], rmq[0][0][0]+N*N*NN*NN, cmp(-INF, +INF) ? INF : -INF); } void init(const T &amp;val) { fill(rmq[0][0][0], rmq[0][0][0]+N*N*NN*NN, val); } T mv(const T &amp;x, const T &amp;y) { return cmp(x, y) ? x : y; } void build(T a[N][N], const int &amp;n, const int &amp;m) { for (int k = 0; k &lt;= log_2[n]; ++k) for (int l = 0; l &lt;= log_2[m]; ++l) for (int i = 1; i+(1&lt;&lt;k)-1 &lt;= n; ++i) for (int j = 1; j+(1&lt;&lt;l)-1 &lt;= m; ++j) { T &amp;cur = rmq[i][j][k][l]; if (!k &amp;&amp; !l) cur = a[i][j]; else if (!l) cur = mv(rmq[i][j][k-1][l], rmq[i+(1&lt;&lt;(k-1))][j][k-1][l]); else cur = mv(rmq[i][j][k][l-1], rmq[i][j+(1&lt;&lt;(l-1))][k][l-1]); } } T query(const int &amp;r1, const int &amp;c1, const int &amp;r2, const int &amp;c2) { int k = log_2[r2-r1+1], l = log_2[c2-c1+1]; return mv(mv(rmq[r1][c1][k][l], rmq[r2-(1&lt;&lt;k)+1][c2-(1&lt;&lt;l)+1][k][l]), mv(rmq[r2-(1&lt;&lt;k)+1][c1][k][l], rmq[r1][c2-(1&lt;&lt;l)+1][k][l])); } }; 反向ST 代码 template &lt;typename T, typename U = std::greater&lt;T&gt;&gt; struct rST { static const int NN = (int)log2(N)+3; static const T INF = 1e9; int n; int lg2[N]; U cmp = U(); T rmq[N][NN]; // rmq[i][j] ==&gt; [i, i+2^j-1] rST() { for (int i = 2; i &lt; N; ++i) lg2[i] = lg2[i&gt;&gt;1]+1; } T&amp; operator [] (const int &amp;i) { return rmq[i][0]; } T mv(const T &amp;x, const T &amp;y) { return cmp(x, y) ? x : y; } void init(const int &amp;_n, const T &amp;val = 0) { n = _n; for (int i = 1; i &lt;= n; ++i) fill(rmq[i], rmq[i]+NN, val); } void update(const int &amp;l, const int &amp;r, const T &amp;k) { if (l &gt; r) return void(update(r, l, k)); int b = lg2[r-l+1]; rmq[l][b] = mv(rmq[l][b], k); rmq[r-(1&lt;&lt;b)+1][b] = mv(rmq[r-(1&lt;&lt;b)+1][b], k); } void build() { for (int i = lg2[n]; i &gt;= 0; --i) { for (int l = 1, r; l &lt;= n; ++l) { r = l+(1&lt;&lt;i); if (r &lt;= n) rmq[r][i] = mv(rmq[r][i], rmq[l][i+1]); rmq[l][i] = mv(rmq[l][i], rmq[l][i+1]); } } } T query(const int &amp;l, const int &amp;r) { if (l &gt; r) return query(r, l); int b = lg2[r-l+1]; return mv(rmq[l][b], rmq[r-(1&lt;&lt;b)+1][b]); } }; 并查集路径压缩 代码 struct DSU { vector&lt;int&gt; fa; void init(int n) { fa = vector&lt;int&gt;(n+1); iota(fa.begin(), fa.end(), 0); } int get(int s) { return s == fa[s] ? s : fa[s] = get(fa[s]); } int&amp; operator [] (int i) { return fa[get(i)]; } bool merge(int x, int y) { // merge x to y x = get(x); y = get(y); return x == y ? false : (fa[x] = y, true); } }; 按秩合并秩的意思就是树的高度，按秩合并过后并查集的结构为树形结构，最坏情况为 $O(m \\log n)$ 代码 struct DSU { vector&lt;int&gt; fa, rk; void init(int n) { fa = rk = vector&lt;int&gt;(n+1, 0); iota(fa.begin(), fa.end(), 0); } int get(int s) { return s == fa[s] ? s : get(fa[s]); } int operator [](int i) { return get(i); } bool merge(int x, int y) { x = get(x); y = get(y); if (x == y) return false; if (rk[x] &lt; rk[y]) fa[x] = y; else fa[y] = x, rk[x] += rk[x] == rk[y]; return true; } }; 启发式合并带权并查集 代码 template &lt;typename T = int&gt; struct DSU { vector&lt;int&gt; fa; vector&lt;T&gt; w; void init(int n, T v = 1) { fa = vector&lt;int&gt;(n+1); iota(fa.begin(), fa.end(), 0); w = vector&lt;T&gt;(n+1, v); } void init(int n, T a[]) { fa = vector&lt;int&gt;(n+1); iota(fa.begin(), fa.end(), 0); w = vector&lt;T&gt;(a, a+n+1); } int get(int s) { return s == fa[s] ? s : fa[s] = get(fa[s]); } int&amp; operator [] (int i) { return fa[get(i)]; } bool merge(int x, int y) { // merge x to y x = get(x); y = get(y); return x == y ? false : (w[y] += w[x], fa[x] = y, true); } }; 扩展域并查集例题:关押罪犯,食物链 代码 struct DSU { int n; vector&lt;int&gt; fa; // [1, n] partner, [n+1, 2n] enemy void init(int n) { this-&gt;n = n; fa = vector&lt;int&gt;(2*n+1, 0); iota(fa.begin(), fa.end(), 0); } int get(int s) { return s == fa[s] ? s : fa[s] = get(fa[s]); } int&amp; operator [] (int i) { return fa[get(i)]; } void merge(int x, int y) { fa[get(x)] = get(y); } bool update(int x, int y) { if (get(x) == get(y)) return false; merge(x+n, y); merge(x, y+n); return true; } }; 可撤销并查集用一个栈维护每次操作 按秩合并 代码 struct DSU { vector&lt;int&gt; fa, rk; stack&lt;pair&lt;int&amp;, int&gt;&gt; stk; void init(int n) { stk = stack&lt;pair&lt;int&amp;, int&gt;&gt;(); fa = rk = vector&lt;int&gt;(n+1, 0); iota(fa.begin(), fa.end(), 0); } int get(int s) { while (s != fa[s]) s = fa[s]; return s; } int&amp; operator [](int i) { return fa[get(i)]; } int merge(int x, int y) { // return the number push in stack x = get(x); y = get(y); if (x == y) return 0; if (rk[x] &gt; rk[y]) swap(x, y); stk.push({fa[x], fa[x]}); fa[x] = y; return rk[x] == rk[y] ? stk.push({rk[y], rk[y]++}), 2 : 1; } bool undo() { if (stk.empty()) return false; stk.top().first = stk.top().second; stk.pop(); return true; } }; 启发式合并 代码 struct DSU { vector&lt;int&gt; fa, sz; stack&lt;pair&lt;int, int&gt;&gt; stk; void init(int n) { stk = stack&lt;pair&lt;int, int&gt;&gt;(); fa = sz = vector&lt;int&gt;(n+1, 1); iota(fa.begin(), fa.end(), 0); } int get(int s) { while (s != fa[s]) s = fa[s]; return s; } int&amp; operator [](int i) { return fa[get(i)]; } int merge(int x, int y) { x = get(x); y = get(y); if (x == y) return 0; if (sz[x] &gt; sz[y]) swap(x, y); stk.push({x, y}); fa[x] = y; sz[y] += sz[x]; return 1; } bool undo() { if (stk.empty()) return false; int x = stk.top().first, y = stk.top().y; stk.pop(); fa[x] = x; sz[y] -= sz[x]; return true; } } 可撤销扩展域并查集 代码 struct DSU { int n; vector&lt;int&gt; fa, rk; // [1, n] partner, [n+1, 2n] enemy stack&lt;pair&lt;int&amp;, int&gt;&gt; stk; void init(int n) { this-&gt;n = n; stk = stack&lt;pair&lt;int&amp;, int&gt;&gt;(); fa = rk = vector&lt;int&gt;(2*n+1, 0); iota(fa.begin(), fa.end(), 0); } int&amp; operator [] (int i) { return fa[get(i)]; } int get(int s) { while (s != fa[s]) s = fa[s]; return s; } void undo() { stk.top().first = stk.top().second; stk.pop(); } void merge(int x, int y) { x = get(x); y = get(y); if (x == y) return; if (rk[x] &gt; rk[y]) swap(x, y); stk.push({fa[x], fa[x]}); stk.push({rk[y], rk[y]}); fa[x] = y; rk[y] += rk[x] == rk[y]; } bool update(int x, int y) { if (get(x) == get(y)) return false; merge(x+n, y); merge(x, y+n); return true; } }; 可持久化并查集 代码 struct PersistantUnionSet { static const int NN = N*(log2(N)+3); int rt[N], ls[NN], rs[NN], fa[NN], dep[NN], n, tot; void build(const int &amp;n) { this-&gt;n = n; tot = 0; rt[0] = build(1, n); } int build(const int &amp;l, const int &amp;r) { int cur = ++tot; assert(tot &lt; NN); if (l == r) return fa[cur] = l, dep[cur] = 0, cur; int mid = (l+r)&gt;&gt;1; ls[cur] = build(l, mid); rs[cur] = build(mid+1, r); return cur; } bool query(const int &amp;cur, const int &amp;x, const int &amp;y) { return fa[getf(rt[cur], x)] == fa[getf(rt[cur], y)]; } // return the id of fa[], dep[] int query(const int &amp;cur, const int &amp;x, const int &amp;l, const int &amp;r) { if (l == r) return cur; int mid = (l+r)&gt;&gt;1; if (x &lt;= mid) return query(ls[cur], x, l, mid); else return query(rs[cur], x, mid+1, r); } // return the id of fa[], dep[] int getf(const int &amp;cur, int x) { int fi; while (fa[(fi = query(cur, x, 1, n))] != x) x = fa[fi]; return fi; } void merge(const int &amp;cur, const int &amp;pre, const int &amp;x, const int &amp;y) { rt[cur] = rt[pre]; int fx = getf(rt[cur], x), fy = getf(rt[cur], y); if (fa[fx] == fa[fy]) return; if (dep[fx] &gt; dep[fy]) swap(fx, fy); rt[cur] = update(rt[pre], fa[fx], fa[fy], 1, n); if (dep[fx] == dep[fy]) add(rt[cur], fa[fy], 1, n); } // update fa, merge x to y int update(const int &amp;pre, const int &amp;x, const int &amp;y, const int &amp;l, const int &amp;r) { int cur = ++tot; assert(tot &lt; NN); if (l == r) return fa[cur] = y, dep[cur] = dep[pre], cur; ls[cur] = ls[pre]; rs[cur] = rs[pre]; int mid = (l+r)&gt;&gt;1; if (x &lt;= mid) ls[cur] = update(ls[pre], x, y, l, mid); else rs[cur] = update(rs[pre], x, y, mid+1, r); return cur; } // add dep void add(const int &amp;cur, const int &amp;x, const int &amp;l, const int &amp;r) { if (l == r) return ++dep[cur], void(); int mid = (l+r)&gt;&gt;1; if (x &lt;= mid) add(ls[cur], x, l, mid); else add(rs[cur], x, mid+1, r); } }; 单调队列 代码 template &lt;typename T&gt; struct MonotonousQueue { unsigned head; vector&lt;T&gt; q; MonotonousQueue() { clear(); } T&amp; operator [](const int &amp;i) { return q[head+i];} void clear() { head = 0; q.clear(); } size_t size() { return q.size()-head; } bool empty() { return head == q.size(); } T front() { return q[head]; } T back() { return q.back(); } void push_front(const T &amp;x) {/*unsupported*/} void push_back(const T &amp;x) { q.push_back(x); } void pop_front() { ++head; } void pop_back() { q.pop_back(); } }; 左偏树|可并堆1 x y：将第 x 个数和第 y 个数所在的小根堆合并（若第 x 或第 y 个数已经被删除或第 x 和第 y 个数在用一个堆内，则无视此操作）。 2 x：输出第 x 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 x 个数已经被删除，则输出 -1 并无视删除操作）。 代码 template &lt;typename T&gt; struct Tree { // 左偏树|可并堆 #define ls tr[x].son[0] #define rs tr[x].son[1] struct TreeNode { T val; int dis, rt, son[2]; }; vector&lt;TreeNode&gt; tr; template &lt;typename TT&gt; void build(TT a[], int n) { tr.resize(n+1); tr[0].dis = -1; for (int i = 1; i &lt;= n; ++i) { tr[i].val = a[i]; tr[i].rt = i; } } int get(int x) { return tr[x].rt == x ? x : tr[x].rt = get(tr[x].rt); } void merge(int x, int y) { if (tr[x].val == -1 || tr[y].val == -1) return; x = get(x); y = get(y); if (x != y) tr[x].rt = tr[y].rt = _merge(x, y); } int _merge(int x, int y) { if (!x || !y) return x+y; if (tr[x].val &gt; tr[y].val || (tr[x].val == tr[y].val &amp;&amp; x &gt; y)) swap(x, y); rs = _merge(rs, y); if(tr[ls].dis &lt; tr[rs].dis) swap(ls, rs); tr[ls].rt = tr[rs].rt = tr[x].rt = x; tr[x].dis = tr[rs].dis+1; return x; } T pop(int x) { if (tr[x].val == -1) return -1; x = get(x); T res = tr[x].val; tr[x].val = -1; tr[ls].rt = ls; tr[rs].rt = rs; tr[x].rt = _merge(ls, rs); return res; } #undef ls #undef rs }; 字符串回文字符串|manacher算法从 0 开始，第 i 位对应 p[i*2+2] 代码 inline int manacher(const char *str, char *buf, int *p) { int str_len = strlen(str), buf_len = 2; buf[0] = buf[1] = '#'; for(int i = 0; i &lt; str_len; ++i) buf[buf_len++] = str[i], buf[buf_len++] = '#'; int mx = 0, id, ans = 0; for(int i = 1; i &lt; buf_len; ++i) { if(i &lt;= mx) p[i] = min(p[id*2-i], mx-i); else p[i] = 1; while(buf[i-p[i]] == buf[i+p[i]]) p[i]++; if(i+p[i] &gt; mx) mx = i+p[i], id = i; ans = max(ans, p[i]-1); } return ans; } 判断s[l, r]是否为回文 代码 p[l+r+2]-1 &gt;= r-l+1 KMP.c_str() 未知异常 Segment Fault 代码 inline void get_next(const string &amp;s, int nex[]) { get_next(s.c_str(), nex); } inline void get_next(const char *s, int nex[]) { nex[0] = nex[1] = 0; for (int i = 1, j = 0, l = strlen(s); i &lt; l; ++i) { while (j &amp;&amp; s[i] != s[j]) j = nex[j]; nex[i+1] = s[i] == s[j] ? ++j : 0; } } inline void kmp(const string &amp;s1, const string &amp;s2, int nex[]) { kmp(s1.c_str(), s2.c_str(), nex); } inline void kmp(const char *s1, const char *s2, int nex[]) { for (int i = 0, j = 0, l1 = strlen(s1), l2 = strlen(s2); i &lt; l1; ++i){ while (j &amp;&amp; s1[i] != s2[j]) j = nex[j]; if (s1[i] == s2[j]) ++j; if (j == l2) { cout &lt;&lt; i-l2+2 &lt;&lt; endl; j = nex[j]; } } } 代码 inline void get_next(const string &amp;s, int nex[]) { nex[0] = nex[1] = 0; for (int i = 1, j = 0; i &lt; (int)s.size(); ++i) { while (j &amp;&amp; s[i] != s[j]) j = nex[j]; nex[i+1] = s[i] == s[j] ? ++j : 0; } } inline void kmp(const string &amp;s1, const string &amp;s2, int nex[]) { for (int i = 0, j = 0; i &lt; (int)s1.size(); ++i) { while (j &amp;&amp; s1[i] != s2[j]) j = nex[j]; if (s1[i] == s2[j]) ++j; if (j == (int)s2.size()) { cout &lt;&lt; i-s2.size()+2 &lt;&lt; endl; j = nex[j]; } } } nex 数组往上跳为公差为 i-nex[i] 的等差数列直到 i/2 扩展KMP|Z函数 代码 vector&lt;int&gt; z_function(string s) { int n = (int)s.length(); vector&lt;int&gt; z(n); for (int i = 1, l = 0, r = 0; i &lt; n; ++i) { if (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + 1) { z[i] = z[i - l]; } else { z[i] = max(0, r - i + 1); while (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i]; } if (i + z[i] - 1 &gt; r) l = i, r = i + z[i] - 1; } return z; } 最长公共前后缀hdu2594 Hash 代码 string max_pre_suf(const string &amp;s1, const string &amp;s2) { static const int M1 = 805306457, M2 = 1000173169, P = 31; static pii pre[N], suf[N], pwp[N]; int l1 = s1.size(), l2 = s2.size(); pre[0] = {0, 0}; for (int i = 1; i &lt;= l1; ++i) { pre[i] = {static_cast&lt;int&gt;((1ll*pre[i-1].first*P+s1[i-1]-'a')%M1), static_cast&lt;int&gt;((1ll*pre[i-1].second*P+s1[i-1]-'a')%M2)}; } pwp[0] = {1, 1}; for (int i = 1; i &lt;= l2; ++i) { pwp[i] = {static_cast&lt;int&gt;(1ll*pwp[i-1].first*P%M1), static_cast&lt;int&gt;(1ll*pwp[i-1].second*P%M2)}; } suf[l2+1] = {0, 0}; for (int i = l2; i; --i) { suf[i] = {static_cast&lt;int&gt;((1ll*(s2[i-1]-'a')*pwp[l2-i].first+suf[i+1].first)%M1), static_cast&lt;int&gt;((1ll*(s2[i-1]-'a')*pwp[l2-i].second+suf[i+1].second)%M2)}; } for (int i = min(l1, l2); i; --i) if (pre[i] == suf[l2-i+1]) return s1.substr(0, i); return \"\"; } BM算法Sunday算法字符串哈希 代码 struct StringHash { static const int M1 = 1e9+7; static const int M2 = 998244353; static const int P1 = 31; static const int P2 = 29; int ha1[N], ha2[N], pw1[N], pw2[N]; StringHash() { pw1[0] = pw2[0] = 1; for (int i = 1; i &lt; N; ++i) { pw1[i] = 1ll*pw1[i-1]*P1%M1; pw2[i] = 1ll*pw2[i-1]*P2%M2; } } void init(char *s, int len) { for (int i = 0; i &lt; len; ++i) { ha1[i+1] = (1ll*ha1[i]*P1+s[i]-'a'+1)%M1; ha2[i+1] = (1ll*ha2[i]*P2+s[i]-'a'+1)%M2; } } pair&lt;int, int&gt; get(int l, int r) { return {(ha1[r]-1ll*ha1[l-1]*pw1[r-l+1]%M1+M1)%M1, (ha2[r]-1ll*ha2[l-1]*pw2[r-l+1]%M2+M2)%M2}; } }; 字典树 代码 struct TireTree { static const int NN = 5e5+7; static const int SZ = 26; char beg; int nex[NN][SZ], num[NN], cnt; bool exist[NN]; TireTree(char _beg = 'a') : beg(_beg) { clear(); } void clear() { memset(nex, 0, sizeof(nex[0])*(cnt+1)); memset(num, 0, sizeof(int)*(cnt+1)); memset(exist, 0, sizeof(bool)*(cnt+1)); cnt = 0; } void insert(const char *s) { int len = strlen(s), p = 0; for (int i = 0, c; i &lt; len; ++i) { c = s[i]-beg; if (!nex[p][c]) nex[p][c] = ++cnt; p = nex[p][c]; ++num[p]; } exist[p] = true; } bool find(const char *s) { int len = strlen(s), p = 0; for (int i = 0, c; i &lt; len; ++i) { c = s[i]-beg; if (!nex[p][c]) return false; p = nex[p][c]; } return exist[p]; } int count(const char *s) { int len = strlen(s), p = 0; for (int i = 0, c; i &lt; len; ++i) { c = s[i]-beg; if (!nex[p][c]) return 0; p = nex[p][c]; } return num[p]; } void insert(const string &amp;s) { insert(s.c_str()); } bool find(const string &amp;s) { return find(s.c_str()); } int count(const string &amp;s) { return count(s.c_str()); } }; 求异或最大异或 代码 struct TireTree { static const int SZ = 2; static const int B = 30; static const int NN = N*B; int nex[NN][SZ], cnt; void init() { clear(); } void clear() { memset(nex, 0, sizeof(int)*(cnt+1)*SZ); cnt = 0; } void insert(int x) { for (int i = B, c, p = 0; i &gt;= 0; --i) { c = (x&gt;&gt;i)&amp;1; if (!nex[p][c]) nex[p][c] = ++cnt; p = nex[p][c]; } } int max_xor(int x) const { int ans = 0; for (int i = B, c, p = 0; i &gt;= 0; --i) { c = (x&gt;&gt;i)&amp;1; if (!nex[p][c^1]) p = nex[p][c]; else p = nex[p][c^1], ans |= 1&lt;&lt;i; } return ans; } }; 动态开点+支持合并 代码 struct TireTree { static const int SZ = 2; static const int B = 30; typedef array&lt;int, SZ&gt; T; vector&lt;T&gt; nex; TireTree() { init(); } void init() { nex.assign(1, T()); /* nex.reserve(N); */ } void clear() { nex = vector&lt;T&gt;(); } size_t size() const { return nex.size(); } void extend(int &amp;x) { if (x != 0) return; x = nex.size(); nex.emplace_back(T()); } void insert(int x) { for (int i = B, c, p = 0; i &gt;= 0; --i) { c = (x&gt;&gt;i)&amp;1; extend(nex[p][c]); p = nex[p][c]; } } int max_xor(int x) const { int ans = 0; for (int i = B, c, p = 0; i &gt;= 0; --i) { c = (x&gt;&gt;i)&amp;1; if (!nex[p][c^1]) p = nex[p][c]; else p = nex[p][c^1], ans |= 1&lt;&lt;i; } return ans; } void dfs(const TireTree &amp;t, int p = 0, int pt = 0) { for (int c = 0; c &lt; SZ; ++c) { if (t.nex[pt][c] == 0) continue; extend(nex[p][c]); dfs(t, nex[p][c], t.nex[pt][c]); } } void join(TireTree &amp;t) { if (t.size() &lt; size()) swap(*this, t); dfs(t); t.clear(); } }; AC自动机AC 自动机是 以 Trie 的结构为基础，结合 KMP 的思想 建立的。 将所有模式串构成一棵 Trie, 再对所有结点构造失配指针 Luogu P3808如需构造可重建AC自动机,每次构造建一个nex数组的拷贝 代码 struct Aho_Corasick_Automaton { static const int NN = 5e6+7; static const int SZ = 26; char beg; int nex[NN][SZ], num[NN], fail[NN], cnt; Aho_Corasick_Automaton(const char &amp;_beg = 'a') : beg(_beg) {} void clear() { memset(nex, 0, sizeof(nex[0])*(cnt+1)); memset(num, 0, sizeof(int)*(cnt+1)); memset(fail, 0, sizeof(int)*(cnt+1)); cnt = 0; } void insert(const char *s) { int len = strlen(s), p = 0; for (int i = 0, c; i &lt; len; ++i) { c = s[i]-beg; if (!nex[p][c]) nex[p][c] = ++cnt; p = nex[p][c]; } ++num[p]; } void build() { static queue&lt;int&gt; q; for (int i = 0; i &lt; SZ; ++i) if (nex[0][i]) q.push(nex[0][i]); while (q.size()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; SZ; ++i) { if (nex[u][i]) { fail[nex[u][i]] = nex[fail[u]][i]; q.push(nex[u][i]); } else { nex[u][i] = nex[fail[u]][i]; } } } } int query(const char *s) { int len = strlen(s), p = 0, res = 0; for (int i = 0; i &lt; len; ++i) { p = nex[p][s[i]-beg]; for (int t = p; t &amp;&amp; ~num[t]; t = fail[t]) { res += num[t]; num[t] = -1; } } return res; } }; Luogu P5357 代码 struct Aho_Corasick_Automaton { static const int NN = 2e5+7; static const int SZ = 26; char beg; int cnt; int nex[NN][SZ], fail[NN], vis[NN]; Aho_Corasick_Automaton(const char &amp;_beg = 'a') : beg(_beg) {} void clear() { memset(nex, 0, sizeof(nex[0])*(cnt+1)); memset(fail, 0, sizeof(int)*(cnt+1)); memset(vis, 0, sizeof(int)*(cnt+1)); cnt = 0; } int insert(const char *s) { int len = strlen(s), p = 0; for (int i = 0, c; i &lt; len; ++i) { c = s[i]-beg; if (!nex[p][c]) nex[p][c] = ++cnt; p = nex[p][c]; } return p; } void build() { static queue&lt;int&gt; q; for (int i = 0; i &lt; SZ; ++i) if (nex[0][i]) q.push(nex[0][i]); while (q.size()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; SZ; ++i) { if (nex[u][i]) { fail[nex[u][i]] = nex[fail[u]][i]; q.push(nex[u][i]); } else { nex[u][i] = nex[fail[u]][i]; } } } } void query(char *s) { static int deg[NN]; static queue&lt;int&gt; q; int len = strlen(s); for (int i = 0, p = 0; i &lt; len; ++i) { p = nex[p][s[i]-beg]; ++vis[p]; // for (int t = p; t; t = fail[t]) ++vis[t]; } for (int i = 1; i &lt;= cnt; ++i) ++deg[fail[i]]; for (int i = 1; i &lt;= cnt; ++i) if (!deg[i]) q.push(i); while (q.size()) { int u = q.front(); q.pop(); vis[fail[u]] += vis[u]; if (--deg[fail[u]] == 0) q.push(fail[u]); } } } ac; 后缀数组|SA$sa[i]$ 表示将所有后缀排序后第 $i$ 小的后缀的编号 $rk[i]$ 表示后缀 $i$ 的排名 性质:$sa[rk[i]]=rk[sa[i]]=i$ $lcp(i, j)$ 表示后缀 $i$ 和后缀 $j$ 的最长公共前缀(的长度) $height[i]=lcp(sa[i], sa[i-1])$ 引理 $height[rk[i]] \\geq height[rk[i-1]]-1$ $lcp(sa[i],sa[j])=\\min{height[i+1\\cdots j]}$ 不同子串数目:$\\frac{n(n+1)}{2}-\\sum\\limits_{i=2}^{n}{height[i]}$ $O(nlog^2n)$ 代码 int sa[N], rk[N&lt;&lt;1], height[N]; template &lt;typename T&gt; // s start from 1 inline void SA(const T *s, const int &amp;n) { static int oldrk[N&lt;&lt;1]; memset(rk+n+1, 0, sizeof(int)*n); for (int i = 1; i &lt;= n; ++i) rk[i] = s[i]; for (int w = 1; w &lt;= n; w &lt;&lt;= 1) { iota(sa+1, sa+n+1, 1); sort(sa+1, sa+n+1, [&amp;](const int &amp;x, const int &amp;y) { return rk[x] == rk[y] ? rk[x+w] &lt; rk[y+w] : rk[x] &lt; rk[y]; }); memcpy(oldrk+1, rk+1, sizeof(int)*2*n); for (int p = 0, i = 1; i &lt;= n; ++i) { if (oldrk[sa[i]] == oldrk[sa[i-1]] &amp;&amp; oldrk[sa[i]+w] == oldrk[sa[i-1]+w]) { rk[sa[i]] = p; } else { rk[sa[i]] = ++p; } } } for (int i = 1, k = 0; i &lt;= n; ++i) { if (k) --k; while (s[i+k] == s[sa[rk[i]-1]+k]) ++k; height[rk[i]] = k; } } $O(nlogn)$ 代码 int sa[N], rk[N&lt;&lt;1], height[N]; template &lt;typename T&gt; // s start from 1 inline void SA(const T *s, const int &amp;n) { #define cmp(x, y, w) oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w] static int oldrk[N&lt;&lt;1], id[N], px[N], cnt[N], m; // memset(oldrk+n+1, 0, sizeof(int)*n); // multi testcase memset(cnt, 0, sizeof(int) * (m = 128)); for (int i = 1; i &lt;= n; ++i) ++cnt[rk[i] = s[i]]; for (int i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (int i = n; i; --i) sa[cnt[rk[i]]--] = i; for (int w = 1, p, i; w &lt;= n; w &lt;&lt;= 1, m = p) { for (p = 0, i = n; i &gt; n - w; --i) id[++p] = i; for (i = 1; i &lt;= n; ++i) if (sa[i] &gt; w) id[++p] = sa[i] - w; memset(cnt + 1, 0, sizeof(int) * m); for (i = 1; i &lt;= n; ++i) ++cnt[px[i] = rk[id[i]]]; for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1]; for (i = n; i; --i) sa[cnt[px[i]]--] = id[i]; swap(oldrk, rk); // memcpy(oldrk+1, rk+1, sizeof(int)*n); for (p = 0, i = 1; i &lt;= n; ++i) rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p; } for (int i = 1, k = 0; i &lt;= n; ++i) { if (k) --k; while (s[i+k] == s[sa[rk[i]-1]+k]) ++k; height[rk[i]] = k; } #undef cmp } $O(n)$ 代码 namespace SuffixArray { int sa[N], rk[N], ht[N]; bool t[N &lt;&lt; 1]; inline bool islms(const int i, const bool *t) { return i &gt; 0 &amp;&amp; t[i] &amp;&amp; !t[i - 1]; } template &lt;class T&gt; inline void sort(T s, int *sa, const int len, const int sz, const int sigma, bool *t, int *b, int *cb, int *p) { memset(b, 0, sizeof(int) * sigma); memset(sa, -1, sizeof(int) * len); for (register int i = 0; i &lt; len; i++) b[static_cast&lt;int&gt;(s[i])]++; cb[0] = b[0]; for (register int i = 1; i &lt; sigma; i++) cb[i] = cb[i - 1] + b[i]; for (register int i = sz - 1; i &gt;= 0; i--) sa[--cb[static_cast&lt;int&gt;(s[p[i]])]] = p[i]; for (register int i = 1; i &lt; sigma; i++) cb[i] = cb[i - 1] + b[i - 1]; for (register int i = 0; i &lt; len; i++) if (sa[i] &gt; 0 &amp;&amp; !t[sa[i] - 1]) sa[cb[static_cast&lt;int&gt;(s[sa[i] - 1])]++] = sa[i] - 1; cb[0] = b[0]; for (register int i = 1; i &lt; sigma; i++) cb[i] = cb[i - 1] + b[i]; for (register int i = len - 1; i &gt;= 0; i--) if (sa[i] &gt; 0 &amp;&amp; t[sa[i] - 1]) sa[--cb[static_cast&lt;int&gt;(s[sa[i] - 1])]] = sa[i] - 1; } template &lt;class T&gt; inline void sais(T s, int *sa, const int len, bool *t, int *b, int *b1, const int sigma) { register int i, j, x, p = -1, cnt = 0, sz = 0, *cb = b + sigma; for (t[len - 1] = 1, i = len - 2; i &gt;= 0; i--) t[i] = s[i] &lt; s[i + 1] || (s[i] == s[i + 1] &amp;&amp; t[i + 1]); for (i = 1; i &lt; len; i++) if (t[i] &amp;&amp; !t[i - 1]) b1[sz++] = i; sort(s, sa, len, sz, sigma, t, b, cb, b1); for (i = sz = 0; i &lt; len; i++) if (islms(sa[i], t)) sa[sz++] = sa[i]; for (i = sz; i &lt; len; i++) sa[i] = -1; for (i = 0; i &lt; sz; i++) { for (x = sa[i], j = 0; j &lt; len; j++) { if (p == -1 || s[x + j] != s[p + j] || t[x + j] != t[p + j]) { cnt++, p = x; break; } else if (j &gt; 0 &amp;&amp; (islms(x + j, t) || islms(p + j, t))) { break; } } sa[sz + (x &gt;&gt;= 1)] = cnt - 1; } for (i = j = len - 1; i &gt;= sz; i--) if (sa[i] &gt;= 0) sa[j--] = sa[i]; register int *s1 = sa + len - sz, *b2 = b1 + sz; if (cnt &lt; sz) sais(s1, sa, sz, t + len, b, b1 + sz, cnt); else for (i = 0; i &lt; sz; i++) sa[s1[i]] = i; for (i = 0; i &lt; sz; i++) b2[i] = b1[sa[i]]; sort(s, sa, len, sz, sigma, t, b, cb, b2); } template &lt;class T&gt; inline void getHeight(T s, int n) { for (register int i = 1; i &lt;= n; i++) rk[sa[i]] = i; register int j = 0, k = 0; for (register int i = 0; i &lt; n; ht[rk[i++]] = k) for (k ? k-- : 0, j = sa[rk[i] - 1]; s[i + k] == s[j + k]; k++) ; } template &lt;class T&gt; // s start from 0 inline void init(T s, const int len, const int sigma = 128) { sais(s, sa, len + 1, t, rk, ht, sigma); getHeight(s, len); for (int i = 1; i &lt;= len; ++i) ++sa[i]; for (int i = len; i; --i) rk[i] = rk[i-1]; } } // namespace SuffixArray 树上SA树上可能出现完全相同的字符串,增加上一轮的有序状态rk为”第三关键字” 代码 struct SAonTree { int n, d[N], cnt[N], sa[N], rk[N&lt;&lt;1], _rk[N&lt;&lt;1], _oldrk[N&lt;&lt;1], tp[N&lt;&lt;1]; template &lt;typename T&gt; void tsort(int *sa, T *rk, int *tp, int m) { memset(cnt, 0, sizeof(int)*(m+1)); for (int i = 1; i &lt;= n; ++i) ++cnt[rk[i]]; for (int i = 1; i &lt;= m; ++i) cnt[i] += cnt[i-1]; for (int i = n; i; --i) sa[cnt[rk[tp[i]]]--] = tp[i]; } template &lt;typename T&gt; void build(int *f, const T *a, const int n) { this-&gt;n = n; int p = 128, i; // p = n iota(tp+1, tp+n+1, 1); tsort(sa, a, tp, p); for (i = 1, p = 0; i &lt;= n; ++i) { _rk[sa[i]] = a[sa[i-1]] == a[sa[i]] ? p : ++p; rk[sa[i]] = i; } for (int w = 1, t = 0; w &lt; n; w &lt;&lt;= 1, ++t) { for (i = 1; i &lt;= n; ++i) _oldrk[i] = rk[f[i]]; tsort(tp, _oldrk, sa, n); tsort(sa, _rk, tp, p); swap(_rk, tp); for (i = 1, p = 0; i &lt;= n; ++i) { _rk[sa[i]] = tp[sa[i-1]] == tp[sa[i]] &amp;&amp; tp[f[sa[i-1]]] == tp[f[sa[i]]] ? p : ++p; rk[sa[i]] = i; } for (int i = n; i; --i) f[i] = f[f[i]]; // attention special tree } } }; 后缀平衡树后缀自动机|SAM一个状态表示一个 $endpos$ 的等价类 $len(v)$ 为该状态最长的字符串长度 后缀链接 $link(v)$ 连接到对应于该状态最长字符串的最长后缀的另一个 $endpos$ 等价类的状态。 代码空间换时间 代码 struct SAM { // root 0 static const int A = 26; static const int M = N&lt;&lt;1; static const char C = 'a'; int sz, last, len[M], link[M], nex[M][A]; void init() { memset(nex, 0, sizeof(int)*A*sz); link[0] = -1; sz = 1; last = 0; } int extend(int c) { int cur = sz++, p = last; len[cur] = len[last]+1; for (; ~p &amp;&amp; !nex[p][c]; p = link[p]) nex[p][c] = cur; if (p == -1) return link[cur] = 0, cur; int q = nex[p][c]; if (len[p]+1 == len[q]) return link[cur] = q, cur; int clone = sz++; memcpy(nex[clone], nex[q], sizeof nex[q]); link[clone] = link[q]; len[clone] = len[p]+1; for (; ~p &amp;&amp; nex[p][c] == q; p = link[p]) nex[p][c] = clone; link[q] = link[cur] = clone; return cur; } void insert(const string &amp;s) { init(); for (char ch : s) last = extend(ch-C); } }; 时间换空间 代码 template &lt;typename T&gt; struct SAM { // root 0 struct State { int len, link; map&lt;T, int&gt; nex; } st[N&lt;&lt;1]; int sz, last; SAM() { init(); } void init() { st[0].len = 0; st[0].link = -1; sz = 1; last = 0; } void extend(T c) { int cur = sz++; st[cur].len = st[last].len+1; int p = last; while (~p &amp;&amp; !st[p].nex.count(c)) { st[p].nex[c] = cur; p = st[p].link; } if (p == -1) { st[cur].link = 0; } else { int q = st[p].nex[c]; if (st[p].len+1 == st[q].len) { st[cur].link = q; } else { int clone = sz++; st[clone].len = st[p].len+1; st[clone].nex = st[q].nex; st[clone].link = st[q].link; while (~p &amp;&amp; st[p].nex[c] == q) { st[p].nex[c] = clone; p = st[p].link; } st[q].link = st[cur].link = clone; } } last = cur; } }; 代码 void build() { // topo on parent tree static int t[M], rk[M]; memset(t, 0, sizeof(int)*sz); for (int i = 0; i &lt; sz; ++i) ++t[len[i]]; for (int i = 1; i &lt; sz; ++i) t[i] += t[i-1]; for (int i = 0; i &lt; sz; ++i) rk[--t[len[i]]] = i; for (int _ = sz-1, i, j; _; --_) { // assert(rk[0] == 0); i = rk[_]; j = link[i]; cnt[j] += cnt[i]; } } 检查字符串是否出现丢进去转移。这个算法还找到了模式串在文本串中出现的最大前缀长度。 不同子串个数不同子串的个数等于自动机中以 $t_0$ 为起点的不同路径的条数-1(空串)。令 $d_{v}$ 为从状态 $v$ 开始的路径数量（包括长度为零的路径） $d_{v}=1+\\sum\\limits_{w:(v,w,c)\\in DAWG}d_{w}$ 另一种方法是利用上述后缀自动机的树形结构。统计节点对应的子串数量 $\\operatorname{len}(i)-\\operatorname{len}(\\operatorname{link}(i))$ ps:若新增一个字符,其增量为$len(cur)-len(link(cur))$ 不包括 $clone$ 结点 所有不同子串的总长度$ans_{v}=\\sum\\limits_{w:(v,w,c)\\in DAWG}d_{w}+ans_{w}$ 法二:每个节点对应的所有后缀长度是 $\\frac{\\operatorname{len}(i)\\times (\\operatorname{len}(i)+1)}{2}$，减去其 $\\operatorname{link}$ 节点的对应值就是该节点的净贡献 字典序第 k 大子串不同位置的相同子串算作一个,每个非 clone 状态的数量记为1 不同位置的相同子串算作多个,每个状态的数量为 parent 树上求子树和 在 SAM 的 DAG 求和然后字典序搞搞 两个字符串的最长公共子串 代码 int lcs(const string &amp;s) { int u = 0, l = 0, res = 0, c; for (char ch : s) { c = ch-C; while (u &amp;&amp; !nex[u][c]) l = len[u = link[u]]; if (nex[u][c]) u = nex[u][c], ++l; res = max(res, l); } return res; } 多个字符串间的最长公共子串记录 $f[i][j]$ 为第 $i$ 个字符串在 sam 上状态 $j$ 的匹配长度 $ans = \\max\\limits_{j}{(\\min\\limits_{i}{f[i][j]})}$ 后缀的最长公共前缀|height求两个后缀的最长公共前缀，显然就是两个后缀的节点在Parent树上的LCA 广义后缀自动机广义后缀自动机 (General Suffix Automaton) 是将后缀自动机整合到字典树中来解决对于多个字符串的子串问题 离线构造 代码 struct generalSAM { static const int A = 26; static const int M = N&lt;&lt;1; static const char C = 'a'; int sz, len[M], link[M], nex[M][A]; generalSAM() { init(); } void init() { // memset(nex, 0, sizeof(int)*A*sz); link[0] = -1; sz = 1; } int insertSAM(int last, int c) { int cur = nex[last][c]; if (len[cur]) return cur; len[cur] = len[last]+1; int p = link[last]; for (; ~p &amp;&amp; !nex[p][c]; p = link[p]) nex[p][c] = cur; if (p == -1) return link[cur] = 0, cur; int q = nex[p][c]; if (len[p]+1 == len[q]) return link[cur] = q, cur; int clone = sz++; for (int i = 0; i &lt; A; ++i) nex[clone][i] = len[nex[q][i]] ? nex[q][i] : 0; len[clone] = len[p]+1; for (; ~p &amp;&amp; nex[p][c] == q; p = link[p]) nex[p][c] = clone; link[clone] = link[q]; link[q] = link[cur] = clone; return cur; } int insertTrie(int cur, int c) { return nex[cur][c] ? nex[cur][c] : nex[cur][c] = sz++; } void insert(const string &amp;s) { int last = 0; for (char ch : s) last = insertTrie(last, ch-C); } void insert(const char *s, int n) { for (int i = 0, last = 0; i &lt; n; ++i) last = insertTrie(last, s[i]-C); } void build() { queue&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; A; ++i) if (nex[0][i]) q.push({0, i}); while (!q.empty()) { auto item = q.front(); q.pop(); int last = insertSAM(item.first, item.second); for (int i = 0; i &lt; A; ++i) if (nex[last][i]) q.push({last, i}); } } }; 在线构造 代码 struct generalSAM { static const int A = 26; static const int M = N&lt;&lt;1; static const char C = 'a'; int sz, len[M], link[M], nex[M][A]; generalSAM() { init(); } void init() { memset(nex, 0, sizeof(int)*A*sz); link[0] = -1; sz = 1; } int extend(int last, int c) { if (nex[last][c]) { int p = last, cur = nex[p][c]; if (len[p]+1 == len[cur]) return cur; int q = sz++; len[q] = len[p]+1; memcpy(nex[q], nex[cur], sizeof nex[q]); for ( ; ~p &amp;&amp; nex[p][c] == cur; p = link[p]) nex[p][c] = q; link[q] = link[cur]; link[cur] = q; return q; } int cur = sz++, p = last; len[cur] = len[p]+1; for ( ; ~p &amp;&amp; !nex[p][c]; p = link[p]) nex[p][c] = cur; if (p == -1) return link[cur] = 0, cur; int q = nex[p][c]; if (len[p]+1 == len[q]) return link[cur] = q, cur; int clone = sz++; len[clone] = len[p]+1; memcpy(nex[clone], nex[q], sizeof nex[q]); for (; ~p &amp;&amp; nex[p][c] == q; p = link[p]) nex[p][c] = clone; link[clone] = link[q]; link[q] = link[cur] = clone; return cur; } void insert(const string &amp;s) { int last = 0; for (char ch : s) last = extend(last, ch-C); } void insert(const char *s) { for (int i = 0, last = 0; s[i]; ++i) last = extend(last, s[i]-C); } }; 多个字符串间的最长公共子串设有 $k$ 个字符串,每个结点建立长度为 $k$ 的标记,在 parent 树自底向上合并,若满足所有标记,则记录 (对于本题而言，可以仅为标记数组，若需要求出此子串的个数，则需要改成计数数组)(可用二进制或bitset) 根号暴力在 parent 树上从字符串的每一个前缀的状态暴力往上跳(须标记vis) 例如可用此法记录上述的标记数组 证明:对于第 $i$ 个字符串,它最多会贡献 $\\min{(n,\\lvert s_i \\rvert^2)}, n=\\sum{\\lvert s_i \\rvert},O(n\\sqrt{n})$ 代码 void jump(const string &amp;s, int id) { int x = 0; for (char ch : s) { x = nex[x][ch-C]; for (int y = x; y &amp;&amp; vis[y] != id; y = link[y]) { vis[y] = id; ++k[y]; // 记录信息 } } } 树上本质不同路径数一颗无根树上任意一条路径必定可以在以某个叶节点为根时，变成一条从上到下的路径 暴力把所有叶子结点为根的树加入自动机,就这? 代码 void dfs(int u, int fa = 0, int last = 0) { int nex = gsam.extend(last, a[u]); for (int v : e[u]) if (v != fa) dfs(v, u, nex); } 循环同构问题CF235C:SAM 读入字符串是支持删除首字符的! 将一个字符串所有的循环同构串插入到 sam, 外加 vis 去重 代码 ll cyclic_query(const string &amp;s) { // 循环同构 static int id = 0, vis[M]; ++id; ll res = 0; for (int i = 0, c, m = s.size(), u = 0, l = 0; i &lt; m*2-1; ++i) { c = s[i%m]-C; while (u &amp;&amp; !nex[u][c]) l = len[u = link[u]]; if (nex[u][c]) u = nex[u][c], ++l; if (l &gt; m &amp;&amp; --l == len[link[u]]) u = link[u]; // 删除首字符 if (l == m &amp;&amp; vis[u] != id) res += cnt[u], vis[u] = id; // 去重,记录答案 } return res; } 最小表示法$S[i\\cdots n]+S[1\\cdots i-1] = T$ 则称 $S$ 与 $T$ 循环同构 字符串 $S$ 的最小表示为与 $S$ 循环同构的所有字符串中字典序最小的字符串 $O(n)$ 代码 int min_cyclic_string(const string &amp;s) { int k = 0, i = 0, j = 1, n = s.size(); while (k &lt; n &amp;&amp; i &lt; n &amp;&amp; j &lt; n) { if (s[(i + k) % n] == s[(j + k) % n]) { k++; } else { s[(i + k) % n] &gt; s[(j + k) % n] ? i = i + k + 1 : j = j + k + 1; if (i == j) i++; k = 0; } } return min(i, j); } Lyndon分解Lyndon 串：对于字符串 $s$，如果 $s$ 的字典序严格小于 $s$ 的所有后缀的字典序，我们称 $s$ 是简单串，或者 Lyndon 串。 Lyndon 分解：串 $s$ 的 Lyndon 分解记为 $s=w_1w_2\\cdots w_k$，其中所有 $w_i$ 为简单串，并且他们的字典序按照非严格单减排序，即 $w_1\\ge w_2\\ge\\cdots\\ge w_k$。可以发现，这样的分解存在且唯一。 Duval 可以在 $O(n)$ 的时间内求出一个串的 Lyndon 分解。 代码 // duval_algorithm vector&lt;string&gt; duval(string const&amp; s) { int n = s.size(), i = 0; vector&lt;string&gt; factorization; while (i &lt; n) { int j = i + 1, k = i; while (j &lt; n &amp;&amp; s[k] &lt;= s[j]) { if (s[k] &lt; s[j]) k = i; else k++; j++; } while (i &lt;= k) { factorization.push_back(s.substr(i, j - k)); i += j - k; } } return factorization; } 回文树|回文自动机|PAM定理:对于一个字符串 $s$,它的本质不同回文子串个数最多只有 $\\lvert s \\rvert$ 个。 状态数,复杂度 $O(n)$ 由于回文树的构造过程中，节点本身就是按照拓扑序插入，因此可以按序枚举所有状态实现树遍历 代码 struct PAM { static const int A = 26; static const char C = 'a'; int sz, tot, last; int ch[N][A], len[N], fail[N]; char s[N]; PAM() { init(); } int node(int l) { ++sz; memset(ch[sz], 0, sizeof ch[sz]); len[sz] = l; fail[sz] = 0; return sz; } void init() { sz = -1; last = 0; s[tot = 0] = '$'; node(0); fail[0] = node(-1); } int getfail(int x) { while (s[tot-len[x]-1] != s[tot]) x = fail[x]; return x; } void insert(char c) { s[++tot] = c; int now = getfail(last); if (!ch[now][c-C]) { int x = node(len[now]+2); fail[x] = ch[getfail(fail[now])][c-C]; ch[now][c-C] = x; } last = ch[now][c-C]; } }; 特殊log性质记字符串 $s$ 长度为 $i$ 的前缀为 $pre(s,i)$，长度为 $i$ 的后缀为 $suf(s,i)$ 周期：若 $0&lt; p \\le |s|$，$\\forall 1 \\le i \\le |s|-p,s[i]=s[i+p]$，就称 $p$ 是 $s$ 的周期。 border：若 $0 \\le r &lt; |s|$，$pre(s,r)=suf(s,r)$，就称 $pre(s,r)$ 是 $s$ 的 border。 周期和 border 的关系：$t$ 是 $s$ 的 border，当且仅当 $|s|-|t|$ 是 $s$ 的周期。 引理 $1$：$t$ 是回文串 $s$ 的后缀，$t$ 是 $s$ 的 border 当且仅当 $t$ 是回文串。 引理 $2$：$t$ 是回文串 $s$ 的 border ($|s|\\le 2|t|$)，$s$ 是回文串当且仅当 $t$ 是回文串。 引理 $3$：$t$ 是回文串 $s$ 的 border，则 $|s|-|t|$ 是 $s$ 的周期，$|s|-|t|$ 为 $s$ 的最小周期，当且仅当 $t$ 是 $s$ 的最长回文真后缀。 引理 $4$：$x$ 是一个回文串，$y$ 是 $x$ 的最长回文真后缀，$z$ 是 $y$ 的最长回文真后缀。令 $u,v$ 分别为满足 $x=uy,y=vz$ 的字符串，则有下面三条性质 $|u| \\ge |v|$； 如果 $|u| &gt; |v|$，那么 $|u| &gt; |z|$； 如果 $|u| = |v|$，那么 $u=v$。 推论：$s$ 的所有回文后缀按照长度排序后，可以划分成 $\\log |s|$ 段等差数列。 回文树上的每个节点 $u$ 需要多维护两个信息，$diff[u]$ 和 $slink[u]$。$diff[u]$ 表示节点 $u$ 和 $fail[u]$ 所代表的回文串的长度差，即 $len[u]-len[fail[u]]$。$slink[u]$ 表示 $u$ 一直沿着 fail 向上跳到第一个节点 $v$，使得 $diff[v] \\neq diff[u]$，也就是 $u$ 所在等差数列中长度最小的那个节点。 diff[x] = len[x]-len[fail[x]]; slink[x] = diff[x] == diff[fail[x]] ? slink[fail[x]] : fail[x]; for (int i = 2; i &lt;= sz; ++i) for (int j = i, k = slink[i]; j; j = k, k = slink[j]) // 等差数列[len[k], len[j]] d = diff[j] 最小回文划分问题描述:求最小的 $k$,使得字符串能分成 $k$ 段且每段都是回文串 暴力:$dp[i]=1+\\min\\limits_{s[j+1\\cdots i]为回文串}dp[j]$ $g[v]$ 表示 $v$ 所在等差数列的 $dp$ 值之和，且 $v$ 是这个等差数列中长度最长的节点，则 $g[v]=\\sum_{x,slink[x]=v} dp[i-len[x]]$，这里 $i$ 是当前枚举到的下标。(该题改求和为取min) 假设当前枚举到第 $i$ 个字符，回文树上对应节点为 $x$。$g[x]=g[fail[x]]+dp[i-(len[slink[x]]+diff[x])]$ 代码 void solve() { dp[0] = 1; for (int x = 0, i = 1; i &lt;= tot; ++i) { while (s[i-len[x]-1] != s[i]) x = fail[x]; x = ch[x][s[i]-C]; for (int j = x; j &gt; 1; j = slink[j]) { g[j] = dp[i-len[slink[j]]-diff[j]]; if (diff[j] == diff[fail[j]]) update(g[j], g[fail[j]]); update(dp[i], g[j]); } } } 回文级数优化回文树上dp问题描述:把字符串 $s$ 划分成若干个字符串 $t_1t_2\\cdots t_k$,使得 $t_i=t_{k-i+1}$,求方案数 问题转化:将字符串转为 $s_1s_ns_2s_{n-1}\\cdots$,原划分方案恰好对应了对新串进行偶数长度的回文划分的方案 tips:只需要考虑偶数下标位置的 $dp$ 值即可 序列自动机序列自动机是接受且仅接受一个字符串的子序列的自动机。 代码 struct SeqAutomaton { // suppose string [1, n] static const int A = 26; static const char C = 'a'; int nex[N][A]; void build(const string &amp;s) { memset(nex[s.size()], 0, sizeof nex[0]); for (int i = s.size(); i; --i) { memcpy(nex[i-1], nex[i], sizeof nex[0]); nex[i-1][s[i-1]-C] = i; } } }; Main-Lorentz 算法我们将一个字符串连续写两遍所产生的新字符串称为 重串 (tandem repetition)。将被重复的这个字符串称为原串。 如果一个重串的原串不是重串，则我们称这个重串为 本原重串 (primitive repetition)。可以证明，本原重串最多有 $O(n \\log n)$ 个。 如果我们把一个重串用 Crochemore 三元组 $(i, p, r)$ 进行压缩，其中 $i$ 是重串的起始位置，$p$ 是该重串某个循环节的长度（注意不是原串长度！），$r$ 为这个循环节重复的次数。则某字符串的所有重串可以被 $O(n \\log n)$ 个 Crochemore 三元组表示。 图论|树论DFS树树的重心 代码 void treedp(int cur, int fa) { s[cur] = c[cur]; for(int i = fir[cur]; i; i = nex[i]) { if(e[i] == fa) continue; treedp(e[i], cur); s[cur] += s[e[i]]; maxs[cur] = max(maxs[cur], s[e[i]]); } maxs[cur] = max(maxs[cur], sum-s[cur]); } 最大团最大独立集数=补图的最大团 代码 struct MaxClique { vector&lt;int&gt; res, tmp, cnt; bool dfs(int p) { for (int i = p+1, flag; i &lt;= n; ++i) { if (cnt[i]+tmp.size() &lt;= res.size()) return false; if (!g[p][i]) continue; flag = 1; for (int j : tmp) if (!g[i][j]) flag = 0; if (!flag) continue; tmp.push_back(i); if (dfs(i)) return true; tmp.pop_back(); } if (tmp.size() &gt; res.size()) { res = tmp; return true; } return false; } void solve() { vector&lt;int&gt;(n+1, 0).swap(cnt); vector&lt;int&gt;().swap(res); for (int i = n; i; --i) { vector&lt;int&gt;(1, i).swap(tmp); dfs(i); cnt[i] = res.size(); } } } MC; 稳定婚姻匹配 代码 template &lt;typename T = int&gt; struct Stable_Marriage { int t[N], b[N], g[N], rkb[N][N], rkg[N][N]; T wb[N][N], wg[N][N]; queue&lt;int&gt; q; void init(const int &amp;n) { queue&lt;int&gt;().swap(q); memset(t, 0, sizeof(int)*(n+3)); memset(b, 0, sizeof(int)*(n+3)); memset(g, 0, sizeof(int)*(n+3)); for (int i = 1; i &lt;= n; ++i) { q.push(i); for (int j = 1; j &lt;= n; ++j) rkb[i][j] = rkg[i][j] = j; sort(rkb[i]+1, rkb[i]+n+1, [&amp;](const int &amp;x, const int &amp;y) { return wb[i][y] &lt; wb[i][x]; }); //sort(rkg[i]+1, rkg[i]+n+1, // [&amp;](const int &amp;x, const int &amp;y) { return wg[i][y] &lt; wg[i][x]; }); } } bool match(const int &amp;x, const int &amp;y) { if (g[y]) { if (wg[y][x] &lt; wg[y][g[y]]) return false; b[g[y]] = 0; q.push(g[y]); } b[x] = y; g[y] = x; return true; } void gale_shapely(const int &amp;n) { init(n); while (q.size()) { int x = q.front(); q.pop(); int y = rkb[x][++t[x]]; if (!match(x, y)) q.push(x); } } }; 最小生成树Prim 代码 inline void prim() { fill(dis, dis+n+1, INF); dis[1] = 0; for(int t = 1; t &lt;= n; ++t) { int mini = 0; for(int i = 1; i &lt;= n; ++i) if(!vis[i] &amp;&amp; dis[i] &lt; dis[mini]) mini = i; vis[mini] = 1; ans += dis[mini]; for(int i = 1; i &lt;= n; ++i) if(!vis[i]) dis[i] = min(dis[i], calc(mini, i)); } } Kruskal (略) 二分图二分图最大匹配增广路算法 Augmenting Path Algorithm $O(nm)$ 代码 bool check(int u) { for (int v : e[u]) { if (vis[v]) continue; vis[v] = 1; if (!co[v] || check(co[v])) { co[v] = u; return true; } } return false; } inline int solve() { int res = 0; memset(co, 0, sizeof co); for (int i = 1; i &lt;= n; ++i) { memset(vis, 0, sizeof(int)*(n+3)); res += check(i); } return res; } 网络流 $O(\\sqrt{n}m)$ 二分图最大权匹配Hungarian Algorithm (Kuhn-Munkres Algorithm)匈牙利算法又称为 KM 算法，可以在 $O(n^3)$ 时间内求出二分图的 最大权完美匹配。 二分图最小顶点覆盖定义：假如选了一个点就相当于覆盖了以它为端点的所有边。最小顶点覆盖就是选择最少的点来覆盖所有的边。 定理：最小顶点覆盖等于二分图的最大匹配。 最大独立集定义：选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。找出一个包含顶点数最多的独立集称为最大独立集。 定理：最大独立集 = 所有顶点数 - 最小顶点覆盖 = 所有顶点数 - 最大匹配 最近公共祖先|LCA倍增 代码 struct LCA { static const int NN = (int)log2(N)+3; int f[N][NN], d[N], lg2[N]; LCA() { for (int i = 2; i &lt; N; ++i) lg2[i] = lg2[i&gt;&gt;1]+1; } template &lt;typename TT&gt; void build(const TT e[], const int &amp;u = 1, const int &amp;fa = 0) { d[u] = d[fa]+1; f[u][0] = fa; for (int i = 1; (1&lt;&lt;i) &lt;= d[u]; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (auto v : e[u]) if (v != fa) build(e, v, u); } int get(int x, int y) { if (d[x] &lt; d[y]) swap(x, y); while (d[x] &gt; d[y]) x = f[x][lg2[d[x]-d[y]]]; if (x == y) return x; for (int i = lg2[d[x]]; i &gt;= 0; --i) if(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; } }; 树剖 代码 struct HLD { int fa[N], d[N], num[N], son[N], tp[N]; vector&lt;int&gt; *e; void build(vector&lt;int&gt; *e, const int &amp;rt = 1) { this-&gt;e = e; fa[rt] = 0; dfs1(rt); dfs2(rt); } void dfs1(const int &amp;u = 1) { d[u] = d[fa[u]]+1; num[u] = 1; son[u] = 0; for (const int &amp;v : e[u]) if (v != fa[u]) { fa[v] = u; dfs1(v); num[u] += num[v]; if (num[v] &gt; num[son[u]]) son[u] = v; } } void dfs2(const int &amp;u = 1) { tp[u] = son[fa[u]] == u ? tp[fa[u]] : u; if (son[u]) dfs2(son[u]); for (const int &amp;v : e[u]) if (v != son[u] &amp;&amp; v != fa[u]) dfs2(v); } int lca(int x, int y) { while (tp[x] != tp[y]) { if (d[tp[x]] &lt; d[tp[y]]) swap(x, y); x = fa[tp[x]]; } return d[x] &lt; d[y] ? x : y; } }; 欧拉序dfs 时进入一个节点加入序列,回溯回来也加一次 lca 转变为区间深度最小的点 带权LCA 代码 template &lt;typename T&gt; struct LCA { static const int NN = (int)log2(N)+3; int f[N][NN], d[N], lg2[N]; T w[N][NN], init_val = 0; LCA() { for (int i = 2; i &lt; N; ++i) lg2[i] = lg2[i&gt;&gt;1]+1; init(); } // set sum or min or max, and don't forget to set init_val T update(const T &amp;x, const T &amp;y) { return x+y; } void init(const int &amp;n = N-1) { fill(w[0], w[0]+(n+1)*NN, init_val); } template &lt;typename TT&gt; void build(const TT e[], const int &amp;u = 1, const int &amp;fa = 0) { d[u] = d[fa]+1; f[u][0] = fa; for (int i = 1; (1&lt;&lt;i) &lt;= d[u]; ++i) { f[u][i] = f[f[u][i-1]][i-1]; w[u][i] = update(w[u][i-1], w[f[u][i-1]][i-1]); } for (auto v : e[u]) if (v.first != fa) { w[v.first][0] = v.second; build(e, v.first, u); } } T get(int x, int y) { T res = init_val; if (d[x] &lt; d[y]) swap(x, y); while (d[x] &gt; d[y]) { res = update(res, w[x][lg2[d[x]-d[y]]]); x = f[x][lg2[d[x]-d[y]]]; } if (x == y) return res; for (int i = lg2[d[x]]; i &gt;= 0; --i) if(f[x][i] != f[y][i]) { res = update(res, w[x][i]); res = update(res, w[y][i]); x = f[x][i], y = f[y][i]; } return update(res, update(w[x][0], w[y][0])); } }; 最小环 树上差分 代码 template &lt;typename T&gt; struct Tree { T val[N]; void update_point(const int &amp;x, const int &amp;y, const T &amp;k) { int _lca = lca(x, y); val[x] += k; val[y] += k; val[_lca] -= k; val[f[_lca][0]] -= k; } void update_edge(const int &amp;x, const int &amp;y, const T &amp;k) { int _lca = lca(x, y); val[x] += k; val[y] += k; val[_lca] -= 2*k; } void dfs(const int &amp;u = 1, const int &amp;fa = 0) { for (int v : e[u]) if (v != fa) { dfs(v, u); val[u] += val[v]; } } }; 树链剖分 代码 template &lt;typename T&gt; struct HLD { int dfn; int fa[N], d[N], num[N], son[N], id[N], tp[N]; T init_val[N]; vector&lt;int&gt; *e; SegmentTree ST; void build(vector&lt;int&gt; *e, T *a, int n, int rt = 1) { this-&gt;e = e; fa[rt] = dfn = 0; dfs1(rt); dfs2(rt); for (int i = 1; i &lt;= n; ++i) init_val[id[i]] = a[i]; ST.build(init_val, n); } void dfs1(const int &amp;u = 1) { d[u] = d[fa[u]]+1; num[u] = 1; son[u] = 0; for (const int &amp;v : e[u]) if (v != fa[u]) { fa[v] = u; dfs1(v); num[u] += num[v]; if (num[v] &gt; num[son[u]]) son[u] = v; } } void dfs2(const int &amp;u = 1) { tp[u] = son[fa[u]] == u ? tp[fa[u]] : u; id[u] = ++dfn; if (son[u]) dfs2(son[u]); for (const int &amp;v : e[u]) if (v != son[u] &amp;&amp; v != fa[u]) dfs2(v); } void add_sons(const int &amp;x, const T &amp;k) { ST.add(id[x], id[x]+num[x]-1, k); } void add(int x, int y, const T &amp;k, const int &amp;is_edge = 0) { while (tp[x] != tp[y]) { if (d[tp[x]] &lt; d[tp[y]]) swap(x, y); ST.add(id[tp[x]], id[x], k); x = fa[tp[x]]; } if (d[x] &gt; d[y]) swap(x, y); ST.add(id[x], id[y], k); if (is_edge) ST.add(id[x], -k); } T query_sons(const int &amp;x) { return ST.query(id[x], id[x]+num[x]-1); } T query(const int &amp;x) { return ST.query(id[x]); } T query(int x, int y) { T res = 0; while (tp[x] != tp[y]) { if (d[tp[x]] &lt; d[tp[y]]) swap(x, y); res += ST.query(id[tp[x]], id[x]); x = fa[tp[x]]; } if (d[x] &gt; d[y]) swap(x, y); return res+ST.query(id[x], id[y]); } }; 网络流网络流24题 最大流EK$O(nm^2)$ 代码 template &lt;typename T&gt; struct EK { struct Edge { int v, nex; T w; } e[M&lt;&lt;1]; int tot = 0, n; int fir[N], vis[N], pre[N]; T incf[N]; T work(const int &amp;s, const int &amp;t) { T res = 0; while (bfs(s, t)) { int u = t, id; while (u != s) { id = pre[u]; e[id].w -= incf[t]; e[id^1].w += incf[t]; u = e[id^1].v; } res += incf[t]; } return res; } void init(const int &amp;sz) { n = sz; tot = 0; memset(fir, -1, sizeof(int)*(n+3)); } void add_edge(const int &amp;u, const int &amp;v, const T &amp;w) { e[tot] = {v, fir[u], w}; fir[u] = tot++; e[tot] = {u, fir[v], 0}; fir[v] = tot++; } bool bfs(const int &amp;s, const int &amp;t) { queue&lt;int&gt; q; memset(vis, 0, sizeof(int)*(n+3)); q.push(s); vis[s] = 1; incf[s] = INF; while (q.size()) { int u = q.front(); q.pop(); for (int i = fir[u], v; i != -1; i = e[i].nex) { v = e[i].v; if (vis[v] || !e[i].w) continue; incf[v] = min(incf[u], e[i].w); pre[v] = i; if (v == t) return true; q.push(v); vis[v] = 1; } } return false; } }; Dinic普通情况下 $O(n^2m)$二分图中 $O(\\sqrt{n}m)$ 该板子存在可能效率极其低下的问题 代码 template &lt;typename T&gt; struct Dinic { struct EDGE { int v, nex; T w; EDGE(const int &amp;_v, const int &amp;_nex, const T &amp;_w) : v(_v), nex(_nex), w(_w) {} }; vector&lt;EDGE&gt; e; int n, s, t; int fir[N], dep[N], cur[N]; Dinic() { e.reserve(N&lt;&lt;2); } T work(const int &amp;_s, const int &amp;_t) { s = _s; t = _t; T maxflow = 0, flow; while (bfs()) while ((flow = dfs(s, INF))) maxflow += flow; return maxflow; } void init(const int &amp;_n) { n = _n; e.clear(); memset(fir, -1, sizeof(int)*(n+3)); } void add_edge(const int &amp;u, const int &amp;v, const T &amp;w) { e.emplace_back(v, fir[u], w); fir[u] = e.size()-1; e.emplace_back(u, fir[v], 0); fir[v] = e.size()-1; } bool bfs() { queue&lt;int&gt; q; memset(dep, 0, sizeof(int)*(n+3)); q.push(s); dep[s] = 1; for (int i = 0; i &lt;= n; ++i) cur[i] = fir[i]; while (q.size()) { int u = q.front(); q.pop(); for (int i = fir[u], v; i != -1; i = e[i].nex) { v = e[i].v; if (dep[v] || !e[i].w) continue; dep[v] = dep[u]+1; if (v == t) return true; q.push(v); } } return false; } T dfs(const int &amp;u, const T &amp;flow) { if (!flow || u == t) return flow; T rest = flow, now; for (int &amp;i = cur[u], v; i != -1; i = e[i].nex) { v = e[i].v; if (dep[v] != dep[u]+1 || !e[i].w) continue; now = dfs(v, min(rest, e[i].w)); if (!now) { dep[v] = 0; } else { e[i].w -= now; e[i^1].w += now; rest -= now; if (rest == flow) break; } } return flow-rest; } }; ISAP渐进时间复杂度和dinic相同，但是非二分图的情况下isap更具优势在某些情况(题目)中远慢于dinic OI Wiki版本 代码 template &lt;typename T&gt; struct ISAP { // copy from oi-wiki struct Edge { int from, to; T cap, flow; Edge(int u, int v, T c, T f) : from(u), to(v), cap(c), flow(f) {} friend bool operator&lt;(const Edge&amp; a, const Edge&amp; b) { return a.from &lt; b.from || (a.from == b.from &amp;&amp; a.to &lt; b.to); } }; int n, m, s, t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[N]; bool vis[N]; int d[N], cur[N], p[N], num[N]; void add_edge(int from, int to, int cap) { edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1); } bool BFS() { memset(vis, 0, sizeof(bool)*(n+3)); queue&lt;int&gt; Q; Q.push(t); vis[t] = 1; d[t] = 0; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; (int)G[x].size(); i++) { Edge&amp; e = edges[G[x][i] ^ 1]; if (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) { vis[e.from] = 1; d[e.from] = d[x] + 1; Q.push(e.from); } } } return vis[s]; } void init(int n) { this-&gt;n = n; for (int i = 1; i &lt;= n; i++) G[i].clear(); edges.clear(); } T Augment() { int x = t; T flow = INF; while (x != s) { Edge&amp; e = edges[p[x]]; flow = min(flow, e.cap - e.flow); x = edges[p[x]].from; } x = t; while (x != s) { edges[p[x]].flow += flow; edges[p[x]^1].flow -= flow; x = edges[p[x]].from; } return flow; } T work(int s, int t) { this-&gt;s = s; this-&gt;t = t; T flow = 0; BFS(); memset(num+1, 0, sizeof(int)*n); for (int i = 1; i &lt;= n; i++) num[d[i]]++; int x = s; memset(cur+1, 0, sizeof(int)*n); while (d[s] &lt; n) { if (x == t) { flow += Augment(); x = s; } int ok = 0; for (int i = cur[x]; i &lt; (int)G[x].size(); i++) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to]+1) { ok = 1; p[e.to] = G[x][i]; cur[x] = i; x = e.to; break; } } if (!ok) { int m = n-1; for (int i = 0; i &lt; (int)G[x].size(); i++) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow) m = min(m, d[e.to]); } if (--num[d[x]] == 0) break; num[d[x] = m+1]++; cur[x] = 0; if (x != s) x = edges[p[x]].from; } } return flow; } }; Luogu版本 代码 template &lt;typename T&gt; struct ISAP { struct EDGE { int v, nex; T w; EDGE(const int &amp;_v, const int &amp;_nex, const T &amp;_w) : v(_v), nex(_nex), w(_w) {} }; vector&lt;EDGE&gt; e; int n, s, t; T maxflow; int fir[N], gap[N], dep[N]; T work(const int &amp;_s, const int &amp;_t) { s = _s; t = _t; maxflow = 0; bfs(); while (dep[s] &lt; n) dfs(s, INF); return maxflow; } void init(const int &amp;_n) { n = _n; e.clear(); e.reserve(N&lt;&lt;2); memset(fir, -1, sizeof(int)*(n+3)); } void clear() { for (int i = 0; i &lt; (int)e.size(); i += 2) { e[i].w += e[i^1].w; e[i^1].w = 0; } } void modify_edge(const int &amp;u, const int &amp;v, const T &amp;w) { for (int i = fir[u]; ~i; i = e[i].nex) if (e[i].v == v) { e[i].w = w; e[i^1].w = 0; break; } } void add_edge(const int &amp;u, const int &amp;v, const T &amp;w) { e.emplace_back(v, fir[u], w); fir[u] = e.size()-1; e.emplace_back(u, fir[v], 0); fir[v] = e.size()-1; } void bfs() { queue&lt;int&gt; q; memset(dep, -1, sizeof(int)*(n+3)); memset(gap, 0, sizeof(int)*(n+3)); dep[t] = 0; gap[0] = 1; q.push(t); while (q.size()) { int u = q.front(); q.pop(); for (int i = fir[u], v; i != -1; i = e[i].nex) { v = e[i].v; if (dep[v] != -1) continue; q.push(v); dep[v] = dep[u]+1; ++gap[dep[v]]; } } } T dfs(const int &amp;u, const T &amp;flow) { if (u == t) return maxflow += flow, flow; T used = 0; for (int i = fir[u], v; i != -1; i = e[i].nex) { v = e[i].v; if (!e[i].w || dep[v]+1 != dep[u]) continue; T minf = dfs(v, min(e[i].w, flow-used)); if (minf) { e[i].w -= minf; e[i^1].w += minf; used += minf; } if (used == flow) return used; } if (--gap[dep[u]] == 0) dep[s] = n+1; ++gap[++dep[u]]; return used; } }; HLPP最小割最小割等价最大流 费用流MCMF 代码 template &lt;typename T&gt; struct MCMF { struct Edge { int v, nex; T w, c; // edge wight and cost Edge(const int &amp;_v, const int &amp;_nex, const T &amp;_w, const T &amp;_c) \\ : v(_v), nex(_nex), w(_w), c(_c) {} }; vector&lt;Edge&gt; e; int n, s, t; int fir[N], vis[N], pre[N]; T incf[N], dis[N]; void init(const int &amp;_n) { n = _n; e.clear(); e.reserve(N&lt;&lt;4); memset(fir, -1, sizeof(int)*(n+3)); } void add_edge(const int &amp;u, const int &amp;v, const T &amp;w, const T &amp;c) { e.emplace_back(v, fir[u], w, c); fir[u] = e.size()-1; e.emplace_back(u, fir[v], 0, -c); fir[v] = e.size()-1; } pair&lt;T, T&gt; work(const int &amp;_s, const int &amp;_t) { s = _s; t = _t; T maxflow = 0, mincost = 0; while (spfa()) { for (int u = t, id; u != s; u = e[id^1].v) { id = pre[u]; e[id].w -= incf[t]; e[id^1].w += incf[t]; mincost += incf[t]*e[id].c; } maxflow += incf[t]; } return {maxflow, mincost}; } bool spfa() { queue&lt;int&gt; q; memset(dis, 0x3f, sizeof(T)*(n+3)); memset(vis, 0, sizeof(int)*(n+3)); q.push(s); dis[s] = 0; incf[s] = INF; incf[t] = 0; while (q.size()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = fir[u], v; i != -1; i = e[i].nex) { v = e[i].v; if (!e[i].w || dis[v] &lt;= dis[u]+e[i].c) continue; dis[v] = dis[u]+e[i].c; incf[v] = min(incf[u], e[i].w); pre[v] = i; if (vis[v]) continue; q.push(v); vis[v] = 1; } } return incf[t]; } }; 类Dinic 代码 template &lt;typename T&gt; struct Dinic { struct Edge { int v, nex; T w, c; // edge wight and cost Edge(const int &amp;_v, const int &amp;_nex, const T &amp;_w, const T &amp;_c) \\ : v(_v), nex(_nex), w(_w), c(_c) {} }; vector&lt;Edge&gt; e; int n, s, t; int fir[N], vis[N]; T maxflow, mincost; T dis[N]; void init(const int &amp;_n) { n = _n; e.clear(); e.reserve(N&lt;&lt;4); maxflow = mincost = 0; memset(vis, 0, sizeof(int)*(n+3)); memset(fir, -1, sizeof(int)*(n+3)); } void add_edge(const int &amp;u, const int &amp;v, const T &amp;w, const T &amp;c) { e.emplace_back(v, fir[u], w, c); fir[u] = e.size()-1; e.emplace_back(u, fir[v], 0, -c); fir[v] = e.size()-1; } pair&lt;T, T&gt; work(const int &amp;_s, const int &amp;_t) { s = _s; t = _t; T flow; while (spfa()) while ((flow = dfs(s, INF))) maxflow += flow; return {maxflow, mincost}; } bool spfa() { queue&lt;int&gt; q; memset(dis, 0x3f, sizeof(int)*(n+3)); q.push(s); dis[s] = 0; vis[s] = 1; while (q.size()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = fir[u], v; i != -1; i = e[i].nex) { v = e[i].v; if (!e[i].w || dis[v] &lt;= dis[u]+e[i].c) continue; dis[v] = dis[u]+e[i].c; if (vis[v]) continue; q.push(v); vis[v] = 1; } } return dis[t] != INF; } T dfs(const int &amp;u, const T &amp;flow) { if (!flow || u == t) return flow; T res = 0 , now; vis[u] = 1; for (int i = fir[u], v; i != -1 &amp;&amp; res &lt; flow; i = e[i].nex) { v = e[i].v; if (vis[v] || !e[i].w || dis[v] != dis[u]+e[i].c) continue; now = dfs(v, min(flow-res, e[i].w)); if (!now) continue; mincost += now*e[i].c; e[i].w -= now; e[i^1].w += now; res += now; } vis[u] = 0; return res; } }; DijkstraPrimal-Dual 原始对偶算法 ZKW_SPFA 代码 template &lt;typename T&gt; struct ZKW_SPFA { struct Edge { int v, nex; T w, c; // edge wight and cost Edge(const int &amp;_v, const int &amp;_nex, const T &amp;_w, const T &amp;_c) \\ : v(_v), nex(_nex), w(_w), c(_c) {} }; vector&lt;Edge&gt; e; int n, s, t; int fir[N], vis[N]; T maxflow, mincost; T dis[N]; ZKW_SPFA() { e.reserve(N&lt;&lt;4); } void init(const int &amp;_n) { n = _n; maxflow = mincost = 0; e.clear(); memset(fir, -1, sizeof(int)*(n+3)); } void add_edge(const int &amp;u, const int &amp;v, const T &amp;w = 1, const T &amp;c = 0) { e.emplace_back(v, fir[u], w, c); fir[u] = e.size()-1; e.emplace_back(u, fir[v], 0, -c); fir[v] = e.size()-1; } pair&lt;T, T&gt; work(const int &amp;_s, const int &amp;_t) { s = _s; t = _t; while (spfa()) { vis[t] = 1; while (vis[t]) { memset(vis, 0, sizeof(int)*(n+3)); maxflow += dfs(s, INF); } } return {maxflow, mincost}; } private: bool spfa() { memset(dis, 0x3f, sizeof(T)*(n+3)); memset(vis, 0, sizeof(int)*(n+3)); deque&lt;int&gt; q; q.push_back(t); dis[t] = 0; vis[t] = 1; while (q.size()) { int u = q.front(); q.pop_front(); for (int i = fir[u], v; ~i; i = e[i].nex) { v = e[i].v; if (!e[i^1].w || dis[v] &lt;= dis[u]+e[i^1].c) continue; dis[v] = dis[u]+e[i^1].c; if (vis[v]) continue; vis[v] = 1; if (q.size() &amp;&amp; dis[v] &lt; dis[q.front()]) q.push_front(v); else q.push_back(v); } vis[u] = 0; } return dis[s] &lt; INF; } T dfs(const int &amp;u, const T &amp;flow) { vis[u] = 1; if (u == t || flow &lt;= 0) return flow; T res, used = 0; for (int i = fir[u], v; ~i; i = e[i].nex) { v = e[i].v; if (vis[v] || !e[i].w || dis[u] != dis[v]+e[i].c) continue; res = dfs(v, min(e[i].w, flow-used)); if (!res) continue; mincost += res*e[i].c; e[i].w -= res; e[i^1].w += res; used += res; if (used == flow) break; } return used; } }; 上下界网络流全局最小割StoerWagner 代码 template &lt;typename T&gt; T sw(int n, T dis[N][N]) { int s, t; T res = INF; vector&lt;int&gt; dap(n+1, 0), ord(n+1, 0), vis; vector&lt;T&gt; w; function&lt;T(int)&gt; proc = [&amp;](int x) { vis = vector&lt;int&gt;(n+1, 0); w = vector&lt;T&gt;(n+1, 0); w[0] = -1; for (int i = 1; i &lt;= n-x+1; ++i) { int mx = 0; for (int j = 1; j &lt;= n; ++j) { if (!dap[j] &amp;&amp; !vis[j] &amp;&amp; w[j] &gt; w[mx]) mx = j; } vis[mx] = 1; ord[i] = mx; for (int j = 1; j &lt;= n; ++j) { if (!dap[j] &amp;&amp; ! vis[j]) w[j] += dis[mx][j]; } } s = ord[n-x]; t = ord[n-x+1]; return w[t]; }; for (int i = 1; i &lt; n; ++i) { res = min(res, proc(i)); dap[t] = 1; for (int j = 1; j &lt;= n; ++j) { dis[s][j] += dis[t][j]; dis[j][s] += dis[j][t]; } } return res; } 最短路弱化标准 Floyd略 Dijkstra邻接表+堆优化 代码 inline void Dijkstra() { priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt;q; memset(dis, 0x7f, sizeof dis); dis[S] = 0; q.push(make_pair(0, S)); pair&lt;int, int&gt; cur; while(q.size()) { cur = q.top(); q.pop(); if(dis[cur.second] &lt; cur.first) continue; for(int i = fir[cur.second], to, now; i; i = nex[i]) { to = ver[i]; now = cur.first+w[i]; if(now &gt;= dis[to]) continue; dis[to] = now; q.push(make_pair(now, to)); } } } SPFA 代码 inline void SPFA() { fill(dis+1, dis+n+1, INT_MAX); dis[S] = 0; head = tail = 0; q[++tail] = S; while(head &lt; tail) { int cur = q[++head]; for(int i = fir[cur], to, tmp; i; i = nex[i]) { to = ver[i]; tmp = dis[cur]+w[i]; if(tmp &gt;= dis[to]) continue; dis[to] = tmp; q[++tail] = to; } } } 负环 代码 // 返回true有负环,返回false没负环 inline bool SPFA() { q[++tail] = 1; vis[1] = 1; cnt[1] = 1; dis[1] = 0; while(head &lt; tail) { int cur = q[(++head)%Maxn]; vis[cur] = 0; for(int i = fir[cur], to; i; i = nex[i]) { to = ver[i]; if(dis[cur]+w[i] &lt; dis[to]) { dis[to] = dis[cur]+w[i]; if(!vis[to]) { q[(++tail)%Maxn] = to; vis[to] = 1; if(++cnt[to] &gt; n) return true; } } } } return false; } 割点 代码 void tarjan(int cur, int fa) { dfn[cur] = low[cur] = ++_dfn; int child = 0; for(auto i : e[cur]) { if(!dfn[i]) { child++; tarjan(i, fa); low[cur] = min(low[cur], low[i]); if(cur != fa &amp;&amp; low[i] &gt;= dfn[cur]) flag[cur] = 1; } low[cur] = min(low[cur], dfn[i]); } if(cur == fa &amp;&amp; child &gt;= 2) flag[cur] = 1; } SCC强连通分量|Tarjan递归版本 代码 int _dfn, _col, _top; int dfn[N], low[N], vis[N], col[N], sta[N]; void tarjan(const int &amp;u) { dfn[u] = low[u] = ++_dfn; vis[u] = 1; sta[++_top] = u; for (int v : e[u]) { if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (vis[v]) { low[u] = min(low[u], low[v]); } } if (dfn[u] == low[u]) { ++_col; do { col[sta[_top]] = _col; vis[sta[_top]] = 0; } while (sta[_top--] != u); } } 非递归版本 代码 int _dfn, _col, _top; int dfn[N], low[N], ins[N], col[N], sta[N]; struct Stack_Node { int u; int edge_info; int state; } tarjan_stack[N]; void tarjan(const int &amp;u) { static int stack_top; stack_top = 0; tarjan_stack[++stack_top] = {u, 0, 0}; while (stack_top) { bool flag = false; int &amp;u = tarjan_stack[stack_top].u; auto &amp;i = tarjan_stack[stack_top].edge_info; switch (tarjan_stack[stack_top].state) { case 0 : tarjan_stack[stack_top].state = 1; flag = false; dfn[u] = low[u] = ++_dfn; ins[u] = 1; sta[++_top] = u; for (; i &lt; (int)e[u].size(); ++i) { #define v e[u][i] if (!dfn[v]) { tarjan_stack[++stack_top] = {v, 0, 0}; flag = true; break; case 1 : flag = false; low[u] = min(low[u], low[v]); } else if (ins[v]) { low[u] = min(low[u], low[v]); } #undef v } if (flag) break; if (dfn[u] == low[u]) { ++_col; do { col[sta[_top]] = _col; ins[sta[_top]] = 0; } while (sta[_top--] != u); } --stack_top; } } } 缩点 代码 void tarjan(int u) { dfn[u] = low[u] = ++_dfn; vis[u] = 1; sta[++top] = u; for (int v : e[u]) { if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (vis[v]) { low[u] = min(low[u], low[v]); } } if (dfn[u] == low[u]) { w_col[++_col] = 0; do { col[sta[top]] = _col; vis[sta[top]] = 0; w_col[_col] += w[sta[top]]; } while (sta[top--] != u); } } inline void suodian() { for (int i = 1; i &lt;= n; ++i) { if (!dfn[i]) tarjan(i); } for (int i = 1; i &lt;= n; ++i) { for (int j : e[i]) { if (col[i] == col[j]) continue; e_col[col[i]].push_back(col[j]); } } } 2-SATSCC Tarjan$O(n+m)$ 代码 struct TWO_SAT { // node start from 0 int top, _dfn, _scc; int dfn[N&lt;&lt;1], low[N&lt;&lt;1], stk[N&lt;&lt;1], scc[N&lt;&lt;1], res[N]; vector&lt;int&gt; e[N&lt;&lt;1]; void init(const int &amp;n) { top = 0; memset(dfn, 0, sizeof(int)*n*2); memset(low, 0, sizeof(int)*n*2); memset(scc, 0, sizeof(int)*n*2); for (int i = 0; i &lt; n&lt;&lt;1; ++i) vector&lt;int&gt;().swap(e[i]); } // if u then v void add_edge(const int &amp;u, const int &amp;v) { e[u].emplace_back(v); } void add_edge(const int &amp;u, const int &amp;uv, const int &amp;v, const int &amp;vv) { e[u&lt;&lt;1^uv].emplace_back(v&lt;&lt;1^vv); } // pt i ==&gt; i&lt;&lt;1 &amp;&amp; i&lt;&lt;1|1 ==&gt; 0 &amp;&amp; 1 inline bool work(const int &amp;n) { for (int i = 0; i &lt;= n&lt;&lt;1; ++i) if (!dfn[i]) tarjan(i); for (int i = 0; i &lt; n; ++i) { if (scc[i&lt;&lt;1] == scc[i&lt;&lt;1|1]) return false; res[i] = scc[i&lt;&lt;1] &gt; scc[i&lt;&lt;1|1]; } return true; } void tarjan(const int &amp;u) { dfn[u] = low[u] = ++_dfn; stk[++top] = u; for (int &amp;v : e[u]) { if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (!scc[v]) { low[u] = min(low[u], dfn[v]); } } if (dfn[u] == low[u]) { ++_scc; do { scc[stk[top]] = _scc; } while (stk[top--] != u); } } }; DFS$O(nm)$所求结果字典序最小 代码 struct TWO_SAT { int n, cnt; int res[N], mem[N&lt;&lt;1], mark[N&lt;&lt;1]; vector&lt;int&gt; e[N&lt;&lt;1]; void init(const int &amp;_n) { n = _n; memset(mark, 0, sizeof(int)*n*2); for (int i = 0; i &lt; n&lt;&lt;1; ++i) vector&lt;int&gt;().swap(e[i]); } // if u then v void add_edge(const int &amp;u, const int &amp;v) { e[u].emplace_back(v); } // pt i ==&gt; i&lt;&lt;1 &amp;&amp; i&lt;&lt;1|1 ==&gt; 0 &amp;&amp; 1 void add_edge(const int &amp;u, const int &amp;uv, const int &amp;v, const int &amp;vv) { e[u&lt;&lt;1|uv].emplace_back(v&lt;&lt;1|vv); } // tag 0 any 1 smallest bool work() { for (int i = 0; i &lt; n; ++i) { if (mark[i&lt;&lt;1] || mark[i&lt;&lt;1|1]) continue; cnt = 0; if (!dfs(i&lt;&lt;1)) { while (cnt) mark[mem[cnt--]] = 0; if (!dfs(i&lt;&lt;1|1)) return false; } } for (int i = 0; i &lt; n&lt;&lt;1; ++i) if (mark[i]) res[i&gt;&gt;1] = i&amp;1; return true; } bool dfs(const int &amp;u) { if (mark[u^1]) return false; if (mark[u]) return true; mark[mem[++cnt] = u] = 1; for (int v : e[u]) if (!dfs(v)) return false; return true; } }; 虚树 代码 vector&lt;int&gt; ve[N]; void virtual_tree_clear(const int &amp;u = 1) { for (const int &amp;v : ve[u]) virtual_tree_clear(v); ve[u].clear(); } // return the root of virtual tree int virtual_tree_build(int vset[], const int &amp;k) { static int stk[N], top; // id ==&gt; dfn rank, d ==&gt; depth int *id = hld.id, *d = hld.d; sort(vset+1, vset+k+1, [&amp;](const int &amp;x, const int &amp;y) { return id[x] &lt; id[y]; }); top = 0; int x, z; for (int i = 1; i &lt;= k; ++i) { if (top &amp;&amp; (z = hld.lca(vset[i], stk[top])) != stk[top]) { x = stk[top--]; while (top &amp;&amp; d[stk[top]] &gt; d[z]) { ve[stk[top]].emplace_back(x); x = stk[top--]; } ve[z].emplace_back(x); if (!top || stk[top] != z) stk[++top] = z; } stk[++top] = vset[i]; } x = stk[top--]; while (top) { ve[stk[top]].emplace_back(x); x = stk[top--]; } // if (x != 1) ve[1].emplace_back(x); // force root at 1 return x; } 线段树优化建图 代码 template &lt;typename T&gt; struct SegmentTreeGarph { struct TreeNode { int l, r; int ls, rs; } tr[N*3]; vector&lt;pair&lt;int, T&gt;&gt; *e; int tot, root[2]; // op [down, 0] [up, 1] template &lt;typename E&gt; void build(const int &amp;n, E *_e) { tot = n; e = _e; for (int i = 1; i &lt;= n; ++i) tr[i].l = tr[i].r = i; build(1, n, root[0], 0); build(1, n, root[1], 1); } void build(const int &amp;l, const int &amp;r, int &amp;i, const int &amp;op) { if (l == r) return i = l, void(); i = ++tot; tr[i].l = l; tr[i].r = r; int mid = (l+r)&gt;&gt;1; build(l, mid, tr[i].ls, op); build(mid+1, r, tr[i].rs, op); e[op ? tr[i].ls : i].emplace_back(op ? i : tr[i].ls, 0); e[op ? tr[i].rs : i].emplace_back(op ? i : tr[i].rs, 0); } void insert(const int &amp;o, const int &amp;l, const int &amp;r, const T &amp;w, const int &amp;op) { if (l == r) e[op ? l : o].emplace_back(op ? o : l, w); else insert(o, l, r, w, op, root[op]); } void insert(const int &amp;o, const int &amp;l, const int &amp;r, const T &amp;w, const int &amp;op, const int &amp;i) { if (tr[i].l &gt;= l &amp;&amp; tr[i].r &lt;= r) { e[op ? i : o].emplace_back(op ? o : i, w); return; } int mid = (tr[i].l+tr[i].r)&gt;&gt;1; if (l &lt;= mid) insert(o, l, r, w, op, tr[i].ls); if (r &gt; mid) insert(o, l, r, w, op, tr[i].rs); } }; +最短路+网络流+2-SAT矩阵树定理|Kirchhoff解决一张图的生成树个数计数问题(详情见oi-wiki) 斯坦纳树给定连通图 $G$ 中的 $n$ 个点 $m$ 条边与 $k$ 个关键点，连接 $k$ 个关键点，使得生成树的所有边的权值和最小。 我们使用状态压缩动态规划来求解。用 $f(i,S)$ 表示以 $i$ 为根的一棵树，包含集合 $S$ 中所有点的最小边权值和。 边权最小 首先对连通的子集进行转移， $f(i,S)\\leftarrow \\min(f(i,S),f(i,T)+f(i,S-T))$ 。 在当前的子集连通状态下进行边的松弛操作， $f(i,S)\\leftarrow \\min(f(i,S),f(j,S)+w(j,i))$ 复杂度 $O(n\\times 3^k+m\\log m\\times 2^k)$ 代码 int dp[N][1&lt;&lt;K]; vector&lt;pair&lt;int, int&gt;&gt; e[N]; // e[u] = {w, v} priority_queue&lt;pair&lt;int, int&gt;&gt; q; void dijkstra(int s) { while (q.size()) { int ud = -q.top().first; int u = q.top().second; q.pop(); if (ud &gt; dp[u][s]) continue; for (int i = 0, v, w; i &lt; (int)e[u].size(); ++i) { w = e[u][i].first; v = e[u][i].second; if (dp[v][s] &lt;= dp[u][s]+w) continue; dp[v][s] = dp[u][s]+w; q.push({-dp[v][s], v}); } } } int steiner_tree(int *p) { // p[] is key point memset(dp, 0x3f, sizeof dp); for (int i = 0; i &lt; k; ++i) dp[p[i]][1&lt;&lt;i] = 0; for (int s = 1; s &lt; 1&lt;&lt;k; ++s) { for (int i = 1; i &lt;= n; ++i) { for (int t = s&amp;(s-1); t; t = s&amp;(t-1)) dp[i][s] = min(dp[i][s], dp[i][s^t]+dp[i][t]); if (dp[i][s] != INF) q.push({-dp[i][s], i}); } dijkstra(s); } return dp[p[0]][(1&lt;&lt;k)-1]; } 点权最小 $f(i,S)\\leftarrow \\min(f(i,S),f(i,T)+f(i,S-T)-a_i)$ 。由于此处合并时同一个点 $a_i$ ，会被加两次，所以减去。 $f(i,S)\\leftarrow \\min(f(i,S),f(j,S)+w(j,i))$ 。 路径输出 代码 void dfs(int u, int s){ if(!pre[u][s].second) return; // print if(pre[u][s].first == u) dfs(u, s^pre[u][s].second); dfs(pre[u][s].first, pre[u][s].second); } 树上背包时间复杂度 $O(n^2)$ 代码 void dfs(int u) { num[u] = 1; for (int &amp;v : e[u]) { dfs(v); for (int i = min(m, num[u]+num[v]); j; --j) { for (int j = max(0, i-num[u]); j &lt;= min(num[v], i); ++j) { // i-j &gt;= num[u] dp[u][i] = max(dp[u][i], dp[u][i-j]+dp[v][j]); } } num[u] += num[v]; } } 仙人掌两点之间最短路 代码 namespace Cactus { #define log(x) (31-__builtin_clz(x)) typedef long long ll; typedef pair&lt;int, ll&gt; pil; const int NN = (int)log2(N)+3; int n, _dfn, cnt; int f[N&lt;&lt;1][NN], dep[N&lt;&lt;1], dfn[N], from[N]; // od 为仙人掌上距离, dis 为圆方树上距离, cir 为环上边权和 ll od[N], dis[N&lt;&lt;1], cir[N]; vector&lt;pil&gt; *e, ce[N&lt;&lt;1]; bool dfs(int u) { dfn[u] = ++_dfn; for (const pil &amp;edge : e[u]) { int v = edge.first; if (v == f[u][0]) continue; ll w = edge.second; if (!dfn[v]) { f[v][0] = u; dep[v] = dep[u]+1; od[v] = od[u]+w; if (!dfs(v)) return false; if (!from[v]) ce[u].emplace_back(v, w); } else if (dfn[v] &lt; dfn[u]) { cir[++cnt] = od[u]-od[v]+w; ce[v].emplace_back(n+cnt, 0); for (int x = u; x != v; x = f[x][0]) { if (from[x]) return false; from[x] = cnt; ll ww = od[x]-od[v]; ce[n+cnt].emplace_back(x, min(ww, cir[cnt]-ww)); } } } return true; } // 带权倍增LCA void build_lca(int u) { for (int i = 1; (1&lt;&lt;i) &lt;= dep[u]; ++i) f[u][i] = f[f[u][i-1]][i-1]; for (const pil &amp;edge : ce[u]) { int v = edge.first; dep[v] = dep[u]+1; dis[v] = dis[u]+edge.second; f[v][0] = u; build_lca(v); } } bool build(int _n, vector&lt;pil&gt; *_e) { n = _n; e = _e; _dfn = cnt = 0; if (!dfs(1)) return false; dep[1] = 1; build_lca(1); return true; } ll query(int u, int v) { if (dep[u] &lt; dep[v]) swap(u, v); int x = u, y = v; while (dep[x] &gt; dep[y]) x = f[x][log(dep[x]-dep[y])]; if (x == y) return dis[u]-dis[v]; for (int i = log(dep[x]); i &gt;= 0; --i) if(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; if (f[x][0] &lt;= n) return dis[u]+dis[v]-2*dis[f[x][0]]; ll d = abs(od[x]-od[y]); return dis[u]-dis[x]+dis[v]-dis[y]+min(d, cir[f[x][0]-n]-d); } } /* namespace Cactus */ 仙人掌DP 代码 // from[i] 节点i与父亲的边所在环的编号 // tp[i]环i深度最小的节点编号, bm[i]环i深度最大的节点编号 int _dfn, cnt, fa[N], dfn[N], from[N], tp[N], bm[N]; bool dfs(int u) { dfn[u] = ++_dfn; for (const int &amp;v : e[u]) { if (v == fa[u]) continue; if (!dfn[v]) { fa[v] = u; dfs(v); // dp } else if (dfn[v] &lt; dfn[u]) { ++cnt; tp[cnt] = v; bm[cnt] = u; for (int x = u; x != v; x = fa[x]) { if (from[x]) return false; from[x] = cnt; } } } } 补图DFS 代码 void bfs(int S = 1) { static set&lt;int&gt; st[2]; // 存储未访问的点 static queue&lt;int&gt; q; memset(dis+1, -1, sizeof(int)*n); dis[S] = 0; q.push(S); st[0].clear(); st[1].clear(); for (int i = 1; i &lt;= n; ++i) if (i != S) st[0].insert(i); while (q.size()) { int u = q.front(); q.pop(); for (int v : e[u]) if (st[0].count(v)) { st[0].erase(v); st[1].insert(v); } for (auto v : st[0]) if (dis[v] == -1) { dis[v] = dis[u]+1; q.push(v); } swap(st[0], st[1]); st[1].clear(); } } 浅谈图模型上的随机游走问题网格图$$f(i)=\\begin{cases}p_1f(i-1,j)+p_2f(i,j-1)+p_3f(i+1,j)+p_4f(i,j+1)+1,i^2+j^2\\leq R \\\\0,i^2+j^2&lt;R\\end{cases}$$ 高斯消元 $O(R^6)$直接消元法 $O(R^4)$主元法 $O(R^3)$树分治点分治按树的重心分治 代码 namespace DFZ { int vis[N], siz[N], mxs[N], cnt[K]; vector&lt;int&gt; pset; void calc_size(int u, int fa = 0) { // 找重心 siz[u] = 1; mxs[u] = 0; pset.emplace_back(u); for (auto p : e[u]) { int v = p.first; if (v == fa || vis[v]) continue; calc_size(v, u); siz[u] += siz[v]; mxs[u] = max(mxs[u], siz[v]); } } void query(int u, int fa, int dis) { for (int i = 1; i &lt;= m; ++i) if (q[i] &gt;= dis) ans[i] |= cnt[q[i]-dis]; for (auto p : e[u]) { int v = p.first; if (v == fa || vis[v]) continue; query(v, u, dis+p.second); } } void update(int u, int fa, int dis, int k) { if (dis &lt; K) cnt[dis] += k; for (auto p : e[u]) { int v = p.first; if (v == fa || vis[v]) continue; update(v, u, dis+p.second, k); } } void dfz(int u = 1) { pset.clear(); calc_size(u); for (int v : pset) { // get centre mxs[v] = max(mxs[v], (int)pset.size()-siz[v]); if (mxs[v] &lt; mxs[u]) u = v; } cnt[0] = 1; for (auto p : e[u]) { int v = p.first; if (vis[v]) continue; query(v, u, p.second); update(v, u, p.second, 1); } update(u, 0, 0, -1); // clear vis[u] = 1; for (auto p : e[u]) { int v = p.first; if (vis[v]) continue; dfz(v); } } } // namespace 点分治 边分治欧拉图Hierholzer 算法复杂度 $O(n+m)$ 保存答案可以使用 stack ，因为如果找的不是回路的话必须将那一部分放在最后。 如 E{(1,2),(2,3),(3,4),(4,5),(5,3)} 代码 vector&lt;EDGE&gt; e[N]; vector&lt;EDGE&gt;::iterator beg[N]; void Hierholzer(int u) { for (auto &amp;it = beg[u]; it != e[u].end(); ) { if (vis[这条边]) { ++it; } else { int v = e[*it].x ^ e[*it].y ^ u; vis[这条边] = 1; ++it; Hierholzer(v); } } stk.push(u); } 数论快排 代码 void quick_sort(int l, int r) { if(l &gt;= r) return; swap(a[l], a[l+rand()%(r-l)]); int i = l, j = r, mid = a[l]; while(i &lt; j) { while(i &lt; j &amp;&amp; a[j] &gt;= mid) --j; swap(a[i], a[j]); while(i &lt; j &amp;&amp; a[i] &lt; mid) ++i; swap(a[i], a[j]); } quick_sort(l, i-1); quick_sort(i+1, r); } 求第K大数HDOJ 2665POJ 2104 代码 int kth_element(int l, int r, int k) { if(l == r) return a[l]; swap(a[l], a[l+rand()%(r-l)]); int mid = a[l], i = l, j = r; while(i &lt; j) { while(i &lt; j &amp;&amp; a[j] &gt;= mid) --j; swap(a[i], a[j]); while(i &lt; j &amp;&amp; a[i] &lt; mid) ++i; swap(a[i], a[j]); } a[i] = mid; if(i == k) return mid; else if(i &gt; k) return kth_element(l, i-1, k); else return kth_element(i+1, r, k); } STL (排序,无返回值) 代码 nth_element(a+1, a+k+1, a+n+1); bfprt 算法目前解决TOP-K问题最有效的算法即是BFPRT算法，又称为中位数的中位数算法，最坏时间复杂度为O(n)。 求逆序对(归并排序) 代码 void merge_sort(int l, int r) { if(l == r) return; int mid = (l+r)&gt;&gt;1; merge_sort(l, mid); merge_sort(mid+1, r); int i = l, j = mid+1, k = l; while(k &lt;= r) { if(j &lt;= r &amp;&amp; (i &gt; mid || a[j] &lt; a[i])) { ans += mid-i+1; b[k++] = a[j++]; } else b[k++] = a[i++]; } memcpy(a+l, b+l, sizeof(int)*(r-l+1)); } 线性基求最大值Luogu3812 求第k大数HDOJ3949 代码 template &lt;typename T&gt; struct LinearBase { int sz = sizeof(T)*8, zero; T tot; vector&lt;T&gt; b, rb, p; LinearBase(){ init(); } void init() { tot = zero = 0;; vector&lt;T&gt;(sz, 0).swap(b); vector&lt;T&gt;().swap(rb); vector&lt;T&gt;().swap(p); } template &lt;typename TT&gt; void build(TT a[], const int &amp;n) { init(); for (int i = 1; i &lt;= n; ++i) insert(a[i]); } void merge(const LinearBase xj) { for (int i : xj.b) if (i) insert(i); } void insert(T x) { for (int i = sz-1; i &gt;= 0; --i) if ((x&gt;&gt;i)&amp;1) { if (!b[i]) { b[i] = x; return; } x ^= b[i]; } zero = 1; } bool find(T x) { for (int i = sz-1; i &gt;= 0; --i) if ((x&gt;&gt;i)&amp;1) { if (!b[i]) { return false; } x ^= b[i]; } return true; } T max_xor() { T res = 0; for (int i = sz-1; i &gt;= 0; --i) if (~(res&gt;&gt;i)&amp;1) res ^= b[i]; // res = max(res, res^b[i]); return res; } T min_xor() { if (zero) return 0; for (int i = 0; i &lt; sz; ++i) if (b[i]) return b[i]; } void rebuild() { rb = b; vector&lt;T&gt;().swap(p); for (int i = sz-1; i &gt;= 0; --i) for (int j = i-1; j &gt;= 0; --j) if ((rb[i]&gt;&gt;j)&amp;1) rb[i] ^= rb[j]; for (int i = 0; i &lt; sz; ++i) if (rb[i]) p.emplace_back(rb[i]); tot = ((T)1&lt;&lt;p.size())+zero; } T kth_min(T k) { if (k &gt;= tot || k &lt; 1) return -1; if (zero &amp;&amp; k == 1) return 0; if (zero) --k; T res = 0; for (int i = (int)p.size()-1; i &gt;= 0; --i) if ((k&gt;&gt;i)&amp;1) res ^= p[i]; return res; } T kth_max(const T &amp;k) { return kth_min(tot-k); } }; 前缀和线性基vector跑贼鸡儿慢 代码 template &lt;class T&gt; struct PreSumLB { int tot, sz = sizeof(T)*8; vector&lt;T&gt; b[N]; vector&lt;int&gt; p[N]; PreSumLB() { init(); } void init() { tot = 0; vector&lt;T&gt;(sz, 0).swap(b[0]); vector&lt;int&gt;(sz, 0).swap(p[0]); } void append(T val) { int pos = ++tot; vector&lt;T&gt; &amp;bb = b[tot]; vector&lt;int&gt; &amp;pp = p[tot]; pp = p[tot-1]; bb = b[tot-1]; for (int i = sz-1; i &gt;= 0; --i) if ((val&gt;&gt;i)&amp;1) { if (bb[i]) { if (pos &gt; pp[i]) swap(pos, pp[i]), swap(val, bb[i]); val ^= bb[i]; } else { bb[i] = val; pp[i] = pos; return; } } } T query(const int &amp;l, const int &amp;r) { T res = 0; vector&lt;T&gt; &amp;bb = b[r]; vector&lt;int&gt; &amp;pp = p[r]; for (int i = sz-1; i &gt;= 0; --i) if (pp[i] &gt;= l) res = max(res, res^bb[i]); return res; } }; 矩阵矩阵快速幂矩阵求逆 代码 template &lt;typename T&gt; struct Martix { int n, m; T a[N][N]; Martix(){} Martix(const int &amp;_n) : n(_n), m(_n) { init(); } Martix(const int &amp;_n, const int &amp;_m) : n(_n), m(_m) { init(); } T* operator [] (const int &amp;i) { return a[i]; } void init(const int &amp;tag = 0) { for (int i = 1; i &lt;= n; ++i) memset(a[i], 0, sizeof(T)*(m+1)); if (tag) for (int i = 1; i &lt;= n; ++i) a[i][i] = tag; } friend Martix operator * (const Martix &amp;m1, const Martix &amp;m2) { Martix res(m1.n, m2.m); for (int i = 1; i &lt;= res.n; ++i) for (int j = 1; j &lt;= res.m; ++j) for (int k = 1; k &lt;= m1.m; ++k) res.a[i][j] = (res.a[i][j]+m1.a[i][k]*m2.a[k][j])%MOD; return res; } Martix&amp; operator *= (const Martix &amp;mx) { return *this = *this*mx; } Martix&amp; operator + (const Martix &amp;mx) const { Martix res(n, m); return res += mx; } Martix&amp; operator += (const Martix &amp;mx) { assert(n == mx.n &amp;&amp; m == mx.m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] += mx.a[i][j]; return *this; } Martix&amp; operator - (const Martix &amp;mx) const { Martix res(n, m); return res -= mx; } Martix&amp; operator -= (const Martix &amp;mx) { assert(n == mx.n &amp;&amp; m == mx.m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) a[i][j] -= mx.a[i][j]; return *this; } template &lt;typename TT&gt; Martix pow(const TT &amp;p) const { Martix res(n, m), a = *this; res.init(1); for (TT i = p; i; i &gt;&gt;= 1, a *= a) if (i&amp;1) res *= a; return res; } Martix inv() const { Martix res = *this; vector&lt;int&gt; is(n+1), js(n+1); for (int k = 1; k &lt;= n; ++k) { for (int i = k; i &lt;= n; ++i) for (int j = k; j &lt;= n; ++j) if (res.a[i][j]) { is[k] = i; js[k] = j; break; } for (int i = 1; i &lt;= n; ++i) swap(res.a[k][i], res.a[is[k]][i]); for (int i = 1; i &lt;= n; ++i) swap(res.a[i][k], res.a[i][js[k]]); if (!res.a[k][k]) return Martix(0); res.a[k][k] = mul_inverse(res.a[k][k]); // get inv of number for (int j = 1; j &lt;= n; ++j) if (j != k) res.a[k][j] = res.a[k][j]*res.a[k][k]%MOD; for (int i = 1; i &lt;= n; ++i) if (i != k) for (int j = 1; j &lt;= n; ++j) if (j != k) res.a[i][j] = (res.a[i][j]+MOD-res.a[i][k]*res.a[k][j]%MOD)%MOD; for (int i = 1; i &lt;= n; ++i) if (i != k) res.a[i][k] = (MOD-res.a[i][k]*res.a[k][k]%MOD)%MOD; } for (int k = n; k; --k) { for (int i = 1; i &lt;= n; ++i) swap(res.a[js[k]][i], res.a[k][i]); for (int i = 1; i &lt;= n; ++i) swap(res.a[i][is[k]], res.a[i][k]); } return res; } T det() { long long res = 1; Martix cpy = *this; for (int i = 1; i &lt;= n; ++i) { for (int j = i+1; j &lt;= n; ++j) while (cpy.a[j][i]) { long long t = cpy.a[i][i]/cpy.a[j][i]; for (int k = i; k &lt;= n; ++k) cpy.a[i][k] = (cpy.a[i][k]+MOD-t*cpy.a[j][k]%MOD)%MOD; swap(cpy.a[i], cpy.a[j]); res = -res; } res = res*cpy.a[i][i]%MOD; } return (res+MOD)%MOD; } friend ostream&amp; operator &lt;&lt; (ostream &amp;os, const Martix&lt;T&gt; &amp;mx) { for (int i = 1; i &lt;= mx.n; ++i) for (int j = 1; j &lt;= mx.m; ++j) os &lt;&lt; mx.a[i][j] &lt;&lt; \" \\n\"[j==mx.m]; return os; } }; 伍德伯里矩阵恒等式|Woodbury matrix identity解决矩阵修改求逆问题 hdoj6994 $(A+UCV)^{-1}=A^{-1}-A^{-1}U(C^{-1}+VA^{-1}U)^{-1}VA^{-1}$ $A\\in \\R^{n\\times n},U\\in \\R^{n\\times k},C\\in \\R^{k\\times k},V\\in \\R^{k\\times n}$ 矩阵求逆 $O(n^3)$, 单次修改 $O(n^2)$ 例如给矩阵 $A$ 的第 $i$ 行第 $j$ 列增加 $\\Delta$ , 若 $A_{3*3}, (i,j)=(2,3)$ $$UCV=\\begin{bmatrix}{0}&amp;{0}&amp;{0}\\\\{0}&amp;{0}&amp;{\\Delta}\\\\{0}&amp;{0}&amp;{0}\\end{bmatrix}$$ 则有 $U_{n\\times 1}=\\begin{bmatrix}{0}&amp;{1}&amp;{0}\\end{bmatrix}^T,U_i=1$ $C_{1\\times 1}=\\begin{bmatrix}{\\Delta}\\end{bmatrix}$ $V_{1\\times n}=\\begin{bmatrix}{0}&amp;{0}&amp;{1}\\end{bmatrix},V_j=1$ 注意运算顺序$(A^{-1}U)(C^{-1}+VA^{-1}U)^{-1}(VA^{-1})$ 高斯消元 代码 struct GaussElimination { double a[N][N]; void init() { memset(a, 0, sizeof a); } void init(const int &amp;n) { for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n+1; ++j) a[i][j] = 0; } // ans is a[i][n+1] bool solve(const int &amp;n) { for (int i = 1, j, k; i &lt;= n; ++i) { for (j = i+1, k = i; j &lt;= n; ++j) if (abs(a[j][i]) &gt; abs(a[k][i])) k = j; if (abs(a[k][i]) &lt; eps) return false; swap(a[k], a[i]); for (j = 1; j &lt;= n; ++j) if (i != j) { double d = a[j][i]/a[i][i]; for (k = i+1; k &lt;= n+1; ++k) a[j][k] -= d*a[i][k]; } } for (int i = 1; i &lt;= n; ++i) a[i][n+1] /= a[i][i]; return true; } }; 异或方程组luogu 2962 a[i][j] 第i个是否对j有影响 a[i][n+1] 第i个最后被翻转与否 代码 // -1 : no solution, 0 : multi , 1 : one template &lt;typename T&gt; int XorGauss(T a[N], const int &amp;n) { for (int i = 1, j, k; i &lt;= n; ++i) { for (k = i; !a[k][i] &amp;&amp; k &lt;= n; ++k) {} if (k &lt;= n) swap(a[k], a[i]); for (j = 1; j &lt;= n; ++j) if (i != j &amp;&amp; a[j][i]) for (k = i; k &lt;= n+1; ++k) a[j][k] ^= a[i][k]; // a[j] ^= a[i]; // bitset&lt;N&gt; a[N] } for (int i = 1; i &lt;= n; ++i) if (!a[i][i] &amp;&amp; a[i][n+1]) return -1; for (int i = 1; i &lt;= n; ++i) if (!a[i][i]) return 0; return 1; } // dfs(n, 0) void dfs(const int &amp;u, const int &amp;num) { if (num &gt;= res) return; if (u &lt;= 0) { res = num; return; } if (a[u][u]) { int t = a[u][n+1]; for (int i = u+1; i &lt;= n; ++i) { if (a[u][i]) t ^= used[i]; } dfs(u-1, num+t); } else { // 自由元 dfs(u-1, num); used[u] = 1; dfs(u-1, num+1); used[u] = 0; } } 拉格朗日插值 代码 template &lt;typename T, typename H, typename P&gt; long long Largrange(const T &amp;k, const int &amp;n, const H x[], const P y[]) { k %= MOD; long long res = 0, s1 = 1, s2 = 1; for (int i = 1; i &lt;= n; ++i, s1 = s2 = 1) { for (int j = 1; j &lt;= n; ++j) if (i != j) { s1 = s1*(x[i]-x[j]+MOD)%MOD; s2 = s2*(k-x[j]+MOD)%MOD; } res = (res+y[i]*s2%MOD*mul_inverse(s1)%MOD)%MOD; } return res; } 代码 template &lt;typename T, typename P&gt; // x[i] = i -&gt; y[i] = f(i) long long Largrange(const T &amp;k, const int &amp;n, const P y[]) { if (k &lt;= n) return y[k]; static long long pre[N], suf[N]; long long res = 0; k %= MOD; pre[0] = suf[n+1] = 1; for (int i = 1; i &lt;= n; ++i) pre[i] = pre[i-1]*(k-i)%MOD; for (int i = n; i &gt;= 1; --i) suf[i] = suf[i+1]*(k-i)%MOD; for (int i = 1; i &lt;= n; ++i) { res = (res+y[i]*(pre[i-1]*suf[i+1]%MOD)%MOD *mul_inverse(((n-i)&amp;1 ? -1 : 1)*fac[i-1]*fac[n-i]%MOD)%MOD)%MOD; } return (res+MOD)%MOD; } 快速幂 代码 template &lt;typename T, typename H&gt; inline T qpow(const T &amp;a, const H &amp;p, const int &amp;mo = MOD) { long long res = 1, x = a; for (H i = p; i; i &gt;&gt;= 1, x = x*x%mo) if (i&amp;1) res = res*x%mo; return static_cast&lt;T&gt;(res); } 快速乘 代码 inline long long qmul(long long x, long long y, long long mo) { long long res = 0; while (y) { if (y&amp;1) res = (res+x)%mo; x = (x&lt;&lt;1)%mo; y &gt;&gt;= 1; } return res; } 代码 inline long long qmul(long long x, long long y, long long mo) { return (long long)((__int128)x*y%mo); } 代码 inline long long qmul(long long x, long long y, long long mo) { // x*y - floor(x*y/mo)*mo typedef unsigned long long ull; typedef long double ld; return ((ull)x*y-(ull)((ld)x/mo*y)*mo+mo)%mo; } 复数 代码 struct comp { typedef double T; // maybe long double ? T real, imag; comp (const double &amp;_real = 0, const double &amp;_imag = 0) : real(_real), imag(_imag) {} friend comp operator + (const comp &amp;c1, const comp &amp;c2) { return comp(c1.real+c2.real, c1.imag+c2.imag); } friend comp operator - (const comp &amp;c1, const comp &amp;c2) { return comp(c1.real-c2.real, c1.imag-c2.imag); } friend comp operator * (const comp &amp;c1, const comp &amp;c2) { return comp(c1.real*c2.real-c1.imag*c2.imag, c1.real*c2.imag+c1.imag*c2.real); } comp&amp; operator += (const comp &amp;c) { return *this = *this+c; } comp&amp; operator -= (const comp &amp;c) { return *this = *this-c; } comp&amp; operator *= (const comp &amp;c) { return *this = *this*c; } friend istream&amp; operator &gt;&gt; (istream &amp;is, comp &amp;c) { return is &gt;&gt; c.real &gt;&gt; c.imag; } friend ostream&amp; operator &lt;&lt; (ostream &amp;os, comp &amp;c) { return os &lt;&lt; c.real &lt;&lt; setiosflags(ios::showpos) &lt;&lt; c.imag &lt;&lt; \"i\";} comp conjugate() { return comp(real, -imag); } friend comp conjugate(const comp &amp;c) { return comp(c.real, -c.imag); } }; 快速傅里叶变换|FFT 代码 namespace FFT { // array [0, n) const int SIZE = (1&lt;&lt;18)+3; int len, bit; int rev[SIZE]; // #define comp complex&lt;long double&gt; void fft(comp a[], int flag = 1) { for (int i = 0; i &lt; len; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int base = 1; base &lt; len; base &lt;&lt;= 1) { comp w, wn = {cos(PI/base), flag*sin(PI/base)}; for (int i = 0; i &lt; len; i += base*2) { w = { 1.0, 0.0 }; for (int j = 0; j &lt; base; ++j) { comp x = a[i+j], y = w*a[i+j+base]; a[i+j] = x+y; a[i+j+base] = x-y; w *= wn; } } } } void work(comp f[], const int &amp;n, comp g[], const int &amp;m) { len = 1; bit = 0; while (len &lt; n+m) len &lt;&lt;= 1, ++bit; // multi-testcase for (int i = n; i &lt; len; ++i) f[i] = 0; for (int i = m; i &lt; len; ++i) g[i] = 0; for (int i = 0; i &lt; len; ++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); fft(f, 1); fft(g, 1); for (int i = 0; i &lt; len; ++i) f[i] *= g[i]; fft(f, -1); for (int i = 0; i &lt; n+m; ++i) f[i].real /= len; } } // namespace FFT /* template &lt;class T&gt; void work(T a[], const int &amp;n) { static comp f[SIZE]; len = 1; bit = 0; while (len &lt; n+n) len &lt;&lt;= 1, ++bit; // multi-testcase for (int i = 0; i &lt; n; ++i) f[i] = a[i]; for (int i = n; i &lt; len; ++i) f[i] = 0; for (int i = 0; i &lt; len; ++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); fft(f, 1); for (int i = 0; i &lt;= len; ++i) f[i] *= f[i]; fft(f, -1); for (int i = 0; i &lt; n+n; ++i) a[i] = static_cast&lt;T&gt;(f[i].real/len+.5); } */ 快速数论变换|NTT 代码 namespace NTT { // array [0, n) const int SIZE = (1&lt;&lt;18)+3; const int G = 3; int len, bit; int rev[SIZE]; long long f[SIZE], g[SIZE]; template &lt;class T&gt; void ntt(T a[], int flag = 1) { for (int i = 0; i &lt; len; ++i) if (i &lt; rev[i]) swap(a[i], a[rev[i]]); for (int base = 1; base &lt; len; base &lt;&lt;= 1) { long long wn = qpow(G, (MOD-1)/(base*2)), w; if (flag == -1) wn = qpow(wn, MOD-2); for (int i = 0; i &lt; len; i += base*2) { w = 1; for (int j = 0; j &lt; base; ++j) { long long x = a[i+j], y = w*a[i+j+base]%MOD; a[i+j] = (x+y)%MOD; a[i+j+base] = (x-y+MOD)%MOD; w = w*wn%MOD; } } } } template &lt;class T&gt; void work(T a[], const int &amp;n, T b[], const int &amp;m) { len = 1; bit = 0; while (len &lt; n+m) len &lt;&lt;= 1, ++bit; for (int i = 0; i &lt; n; ++i) f[i] = a[i]; for (int i = n; i &lt; len; ++i) f[i] = 0; for (int i = 0; i &lt; m; ++i) g[i] = b[i]; for (int i = m; i &lt; len; ++i) g[i] = 0; for (int i = 0; i &lt; len; ++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); ntt(f, 1); ntt(g, 1); for (int i = 0; i &lt; len; ++i) f[i] = f[i]*g[i]%MOD; ntt(f, -1); long long inv = qpow(len, MOD-2); for (int i = 0; i &lt; n+m-1; ++i) f[i] = f[i]*inv%MOD; } } // namespace NTT 任意模数NTT|MTT 代码 namespace MTT { const int SIZE = (1&lt;&lt;18)+7; const int Mod = MOD; comp w[SIZE]; int bitrev[SIZE]; long long f[SIZE]; void fft(comp *a, const int &amp;n) { for (int i = 0; i &lt; n; ++i) if (i &lt; bitrev[i]) swap(a[i], a[bitrev[i]]); for (int i = 2, lyc = n &gt;&gt; 1; i &lt;= n; i &lt;&lt;= 1, lyc &gt;&gt;= 1) for (int j = 0; j &lt; n; j += i) { comp *l = a + j, *r = a + j + (i &gt;&gt; 1), *p = w; for (int k = 0; k &lt; i&gt;&gt;1; ++k) { comp tmp = *r * *p; *r = *l - tmp, *l = *l + tmp; ++l, ++r, p += lyc; } } } template &lt;class T&gt; inline void work(T *x, const int &amp;n, T *y, const int &amp;m) { static int bit, L; static comp a[SIZE], b[SIZE]; static comp dfta[SIZE], dftb[SIZE]; for (L = 1, bit = 0; L &lt; n+m-1; ++bit, L &lt;&lt;= 1); for (int i = 0; i &lt; L; ++i) bitrev[i] = bitrev[i &gt;&gt; 1] &gt;&gt; 1 | ((i &amp; 1) &lt;&lt; (bit - 1)); for (int i = 0; i &lt; L; ++i) w[i] = comp(cos(2 * PI * i / L), sin(2 * PI * i / L)); for (int i = 0; i &lt; n; ++i) (x[i] += Mod) %= Mod, a[i] = comp(x[i] &amp; 32767, x[i] &gt;&gt; 15); for (int i = n; i &lt; L; ++i) a[i] = 0; for (int i = 0; i &lt; m; ++i) (y[i] += Mod) %= Mod, b[i] = comp(y[i] &amp; 32767, y[i] &gt;&gt; 15); for (int i = m; i &lt; L; ++i) b[i] = 0; fft(a, L), fft(b, L); for (int i = 0; i &lt; L; ++i) { int j = (L - i) &amp; (L - 1); static comp da, db, dc, dd; da = (a[i] + conjugate(a[j])) * comp(.5, 0); db = (a[i] - conjugate(a[j])) * comp(0, -.5); dc = (b[i] + conjugate(b[j])) * comp(.5, 0); dd = (b[i] - conjugate(b[j])) * comp(0, -.5); dfta[j] = da*dc + da*dd*comp(0, 1); dftb[j] = db*dc + db*dd*comp(0, 1); } for (int i = 0; i &lt; L; ++i) a[i] = dfta[i]; for (int i = 0; i &lt; L; ++i) b[i] = dftb[i]; fft(a, L), fft(b, L); for (int i = 0; i &lt; L; ++i) { int da = (long long)(a[i].real / L + 0.5) % Mod; int db = (long long)(a[i].imag / L + 0.5) % Mod; int dc = (long long)(b[i].real / L + 0.5) % Mod; int dd = (long long)(b[i].imag / L + 0.5) % Mod; f[i] = (da + ((long long)(db + dc) &lt;&lt; 15) + ((long long)dd &lt;&lt; 30)) % Mod; } for (int i = 0; i &lt; n+m-1; ++i) (f[i] += Mod) %= Mod; } } // namespace MTT 分治FFT 代码 // give g[1, n) ask f[0, n) // f[i] = sigma f[i-j]*g[j] (1 &lt;= j &lt;= i) template &lt;class T&gt; // [l, r] void cdq_fft(T f[], T g[], const int &amp;l, const int &amp;r) { if (r-l &lt;= 1) return; int mid = (l+r)&gt;&gt;1; cdq_fft(f, g, l, mid); NTT::work(f+l, mid-l, g, r-l); for (int i = mid; i &lt; r; ++i) (f[i] += NTT::f[i-l]) %= MOD; cdq_fft(f, g, mid, r); } // f[0] = 1; cdq_fft(f, g, 0, n); 快速沃尔什变换|FWT推导详解 公式参考 洛谷例题 复杂度 $O(n\\log n) | O(n2^n)$ $FWT(A\\pm B)=FWT(A)\\pm FWT(B)$ $FWT(cA)=cFWT(A)$ 定义 $\\bigoplus$ 为任意集合运算 $FWT(A\\bigoplus B)=FWT(A)\\times FWT(B)$ 求 $C_i = \\sum\\limits_{i=j\\bigoplus k}{a_j b_k}$ 或运算$FWT(A)[i] = \\sum\\limits_{j|i=i}{A[j]}$ $FWT(A) = [FWT(A_0),FWT(A_0+A_1)]$ $IFWT(A) = [IFWT(A_0),IFWT(A_1)-IFWT(A_0)]$ 与运算$FWT(A)[i] = \\sum\\limits_{i\\&amp;j=j}{A[j]}$ $FWT(A) = [FWT(A_0+A_1),FWT(A_1)]$ $IFWT(A) = [IFWT(A_0)-IFWT(A_1),IFWT(A_1)]$ 异或运算令 $d(x)$ 为 $x$ 在二进制下拥有的1的数量 $FWT(A)[i] = \\sum\\limits_{j}(-1)^{d(i\\&amp;j)}A[j]$ $FWT(A) = [FWT(A_0+A_1),FWT(A_0-A_1)]$ $IFWT(A) = [\\frac{IFWT(A_1-A_0)}{2},\\frac{IFWT(A_1+A_0)}{2}]$ code 代码 namespace FWT { #define forforfor for (int l = 2; l &lt;= len; l &lt;&lt;= 1)\\ for (int i = 0, k = l&gt;&gt;1; i &lt; len; i += l)\\ for (int j = 0; j &lt; k; ++j) const int SIZE = (1&lt;&lt;17)+3; int len; int f[SIZE], g[SIZE]; template &lt;class T&gt; void init(T a[], const int &amp;n, T b[], const int &amp;m) { len = 1; while (len &lt; max(n, m)) len &lt;&lt;= 1; for (int i = 0; i &lt; n; ++i) f[i] = a[i]; for (int i = n; i &lt; len; ++i) f[i] = 0; for (int i = 0; i &lt; m; ++i) g[i] = b[i]; for (int i = m; i &lt; len; ++i) g[i] = 0; } template &lt;class T&gt; void fwt_or(T a[], const int x = 1) { forforfor a[i+j+k] = (a[i+j+k]+1ll*a[i+j]*x)%MOD; } template &lt;class T&gt; void fwt_and(T a[], const int x = 1) { forforfor a[i+j] = (a[i+j]+1ll*a[i+j+k]*x)%MOD; } template &lt;class T&gt; void fwt_xor(T a[], const int x = 1) { forforfor { (a[i+j] += a[i+j+k]) %= MOD; a[i+j+k] = (a[i+j]-2*a[i+j+k]%MOD+MOD)%MOD; a[i+j] = 1ll*a[i+j]*x%MOD; a[i+j+k] = 1ll*a[i+j+k]*x%MOD; } } template &lt;class T&gt; void work_or(const T a[], const int &amp;n, const T b[], const int &amp;m) { init(a, n, b, m); fwt_or(f); fwt_or(g); for (int i = 0; i &lt; len; ++i) f[i] = 1ll*f[i]*g[i]%MOD; fwt_or(f, MOD-1); // fwt_or(x, -1) } template &lt;class T&gt; void work_and(const T a[], const int &amp;n, const T b[], const int &amp;m) { init(a, n, b, m); fwt_and(f); fwt_and(g); for (int i = 0; i &lt; len; ++i) f[i] = 1ll*f[i]*g[i]%MOD; fwt_and(f, MOD-1); // fwt_and(x, -1) } template &lt;class T&gt; void work_xor(const T a[], const int &amp;n, const T b[], const int &amp;m) { init(a, n, b, m); fwt_xor(f); fwt_xor(g); for (int i = 0; i &lt; len; ++i) f[i] = 1ll*f[i]*g[i]%MOD; fwt_xor(f, mul_inverse(2)); // fwt_xor(x, 1/2) } #undef forforfor } // namespace FWT 快速莫比乌斯变换|FMT据说 FWT 做的事情完全包含 FMT 且常数是一半(咕之 快速子集变换(子集卷积)|FST$C_k = \\sum\\limits_{i\\&amp;j=0,i|j=k}{A_i B_j}$ 复杂度 $O(n\\log^2 n) | O(n^22^n)$ 代码 namespace FST { const int W = 20; const int N = 1&lt;&lt;W; int len, bit; int f[W+1][N], g[W+1][N], h[W+1][N], res[N]; template &lt;class T&gt; void fwt(T a[], const int x = 1) { for (int l = 2; l &lt;= len; l &lt;&lt;= 1) for (int i = 0, k = l&gt;&gt;1; i &lt; len; i += l) for (int j = 0; j &lt; k; ++j) a[i+j+k] = (a[i+j+k]+1ll*a[i+j]*x)%MOD; } template &lt;class T&gt; void work(const T a[], const int &amp;n, const T b[], const int &amp;m) { len = 1; bit = 0; while (len &lt; max(n, m)) len &lt;&lt;= 1, ++bit; for (int i = 0; i &lt;= bit; ++i) for (int j = 0; j &lt; len; ++j) f[i][j] = g[i][j] = h[i][j] = 0; for (int i = 0; i &lt; n; ++i) f[__builtin_popcount(i)][i] = a[i]; for (int i = 0; i &lt; m; ++i) g[__builtin_popcount(i)][i] = b[i]; for (int i = 0; i &lt;= bit; ++i) { fwt(f[i]); fwt(g[i]); for (int j = 0; j &lt;= i; ++j) for (int k = 0; k &lt; len; ++k) h[i][k] = (h[i][k]+1ll*f[j][k]*g[i-j][k])%MOD; fwt(h[i], MOD-1); // fwt(h[i], -1) } for (int i = 0; i &lt; len; ++i) res[i] = h[__builtin_popcount(i)][i]; } } // namespace FST 分治FWT形同分治FFT 倍增子集卷积hdu6851 设多项式 $A = \\sum\\limits_{i=0}^{2^n-1}{a_i x^i},B=\\sum\\limits_{i=0}^{2^n-1}{b_i x^i}$ 求 $C = A*B = \\sum\\limits_{i=0}^{2^n-1}{x^i \\sum\\limits_{d\\subseteq i}{a_d b_{i-d} }}$ 按照每个状态的最高位进行分组，然后卷 $n$ 次 复杂度 $O(\\sum\\limits_{i=1}^{n}{i^2 2^i}) = O(n^2 2^n)$ 代码 template &lt;typename T&gt; void vip_fst(T a[], const int &amp;n) { // return a static int b[1&lt;&lt;B]; // warning: the type of b int len = 1; while (len &lt; n) len &lt;&lt;= 1; memcpy(b, a, sizeof(T)*len); memset(a, 0, sizeof(T)*len); a[0] = 1; for (int i = 1; i &lt; len; i &lt;&lt;= 1) { FST::work(a, i, b+i, i); for (int j = 0; j &lt; i; ++j) a[i+j] = FST::h[__builtin_popcount(j)][j]; } } 第二类斯特林数 代码 inline void stirling(const int &amp;n) { S[0][0] = 1; // 注意取模 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= i; ++j) S[i][j] = S[i-1][j-1]+S[i-1][j]*j; } 代码 void stirling(const int &amp;n) { inv[0] = inv[1] = 1; for(int i = 2; i &lt;= n; ++i) inv[i] = MOD-MOD/i*inv[MOD%i]%MOD; for (int i = 1; i &lt;= n; ++i) inv[i] = inv[i-1]*inv[i]%MOD; while (len &lt;= (n&lt;&lt;1)) len &lt;&lt;= 1, ++bit; for (int i = 0; i &lt; len; ++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for (int i = 0, one = 1; i &lt;= n; ++i, one = MOD-one) { f[i] = one*inv[i]%MOD; g[i] = qpow(i, n)*inv[i]%MOD; } NTT(f, 1); NTT(g, 1); for (int i = 0; i &lt; len; ++i) f[i] = f[i]*g[i]%MOD; NTT(f, -1); long long invv = qpow(len, MOD-2); for (int i = 0; i &lt;= n; ++i) printf(\"%lld%c\", f[i]*invv%MOD, \" \\n\"[i==n]); } 约瑟夫环O(n) 代码 int solve(int n, int v) { return n == 1 ? 0 : (solve(n-1, v)+v)%n; } // res = solve(num, step)+1 最大公因数 gcd 代码 __gcd(a, b); // &lt;algorithm&gt; int gcd(int a, int b) { return b ? gcd(b, a%b) : a; } inline int gcd(int a, int b) { while (b) a %= b, swap(a, b); return a; } 最小公倍数 lcm$LCM(\\frac{a}{b},\\frac{c}{d})=\\frac{LCM(a, c)}{GCD(b,d)}$ $LCM(\\frac{a_1}{b_1},\\frac{a_2}{b_2},…)=\\frac{LCM(a1, a2,…)}{GCD(b1, b2,…)}$ 代码 inline int lcm(int a, int b) { return a/gcd(a, b)*b; } 扩展欧几里得(同余方程) 代码 template &lt;typename T&gt; T exgcd(const T a, const T b, T &amp;x, T &amp;y) { if (!b) return x = 1, y = 0, a; T d = exgcd(b, a%b, y, x); y -= a/b*x; return d; } 乘法逆元拓展欧几里得 代码 template &lt;typename T&gt; inline T mul_inverse(const T &amp;a, const T &amp;mo = MOD) { T x, y; exgcd(a, mo, x, y); return (x%mo+mo)%mo; } 费马小定理 代码 template &lt;typename T&gt; inline T mul_inverse(const T &amp;a, const int &amp;mo = MOD) { return qpow(a, mo-2); } 线性递推 代码 template &lt;typename T&gt; inline void mul_inverse(T *inv, int mod = MOD) { inv[0] = inv[1] = 1; for(int i = 2; i &lt;= n; ++i) inv[i] = 1ll*(mod-mod/i)*inv[mod%i]%mod; } 中国剩余定理中国剩余定理CRT(m互质) 代码 inline long long CRT(int a[], int m[]) { long long res = 0, M = 1; for (int i = 1; i &lt;= n; ++i) M *= m[i]; for (int i = 1; i &lt;= n; ++i) res = (res + a[i]*(M/m[i])*mul_inverse(M/m[i], m[i]))%M; return (res+M)%M; } 扩展中国剩余定理EXCRT(m不互质) 代码 inline long long EXCRT(long long a[], long long m[]) { // M*x + m[i]*y = a[i]-res (mod m[i]) // res = res+x*M; long long M = m[1], res = a[1], x, y, c, d; for (int i = 2; i &lt;= n; ++i) { d = exgcd(M, m[i], x, y); c = (a[i]-res%m[i]+m[i])%m[i]; if (c%d != 0) return -1; x = (c/d)*x%(m[i]/d); res += x*M; M *= m[i]/d; res = (res%M+M)%M; } return res; } 排列组合 代码 struct Combination { int fac[N], inv[N]; Combination() {init(N-1); } void init(const int &amp;n) { fac[0] = inv[0] = fac[1] = inv[1] = 1; for (int i = 2; i &lt;= n; ++i) { fac[i] = 1ll*fac[i-1]*i%MOD; inv[i] = 1ll*(MOD-MOD/i)*inv[MOD%i]%MOD; } for (int i = 2; i &lt;= n; ++i) { inv[i] = 1ll*inv[i]*inv[i-1]%MOD; } } int A(const int &amp;p, const int &amp;q) { return p &gt;= q ? 1ll*fac[p]*inv[p-q]%MOD : 0; } int C(const int &amp;p, const int &amp;q) { return p &gt;= q ? 1ll*fac[p]*inv[q]%MOD*inv[p-q]%MOD : 0; } }; 奇偶性C(n,k) 当 n&amp;k == k 为奇数反之偶数 欧拉函数 代码 template &lt;typename T&gt; inline T phi(T x) { T res = x; for (T i = 2; i*i &lt;= x; ++i) { if (x%i) continue; res = res/i*(i-1); while (x%i == 0) x /= i; } if (x &gt; 1) res = res/x*(x-1); return res; } 筛法 代码 struct Euler { int phi[N], check[N]; vector&lt;int&gt; prime; void init(int sz) { for (int i = 1; i &lt;= sz; ++i) check[i] = 1; phi[1] = 1; check[1] = 0; for (int i = 2; i &lt;= sz; ++i) { if (check[i]) { prime.emplace_back(i); phi[i] = i-1; } for (int j : prime) { if (i*j &gt; sz) break; check[i*j] = 0; if (i%j) { phi[i*j] = (j-1)*phi[i]; } else { phi[i*j] = j*phi[i]; break; } } } } } E; 欧拉定理a 与 m 互质时，$a^{\\phi(m)} \\equiv 1 \\mod m$ 扩展欧拉定理无需 a,m 互质 $b &gt; \\phi(m),a^b \\equiv a^{(b \\mod \\phi(m))+\\phi(m)} \\mod m$ 莫比乌斯函数 代码 template &lt;typename T&gt; inline T miu(T x) { int t = 0; for (T i = 2, k; i*i &lt;= x; ++i) { if (x%i) continue; for (k = 0, ++t; x %i == 0; x /= i, ++k) {} if (k &gt;= 2) return 0; } if (x &gt; 1) ++t; return t&amp;1 ? -1 : 1; } 线性筛素数 代码 struct Euler { vector&lt;int&gt; prime, check; int&amp; operator [](const int &amp;i) { return check[i]; } void init(int n) { prime.clear(); check = vector&lt;int&gt;(n+1); for (int i = 2; i &lt;= n; ++i) { if (!check[i]) prime.emplace_back(i), check[i] = i; for (const int &amp;j : prime) { if (i*j &gt; n) break; check[i*j] = j; if (i%j == 0) break; } } } } E; 求所有因子 代码 vector&lt;int&gt; get_fac(int x) { vector&lt;int&gt; fac(1, 1), tmp; while (E[x]) { tmp = fac; for (int y = E[x]; x%y == 0; x /= y) { for (int &amp;i : tmp) i *= y; fac.insert(fac.end(), tmp.begin(), tmp.end()); } } return fac; } 判断素数(质数) 某较优方法 代码 inline bool is_prime(long long x) { if(x == 1) return false; if(x == 2 || x == 3) return true; if(x%6 != 1 &amp;&amp; x%6 != 5) return false; for(long long i = 5; i*i &lt;= x; i += 6) if(x%i == 0 || x%(i+2) == 0) return false; return true; } Miller-Rabin 素性测试 代码 inline bool MillerRabin(int x) { static const int test_time = 10; if (x &lt; 3) return x == 2; int a = x-1, b = 0; while (!(a&amp;1)) a &gt;&gt;= 1, ++b; for (int i = 1, j, v; i &lt;= test_time; ++i) { v = (qpow(rnd()%(x-2)+2, a, x)); if (v == 1 || v == x-1) continue; for (j = 0; j &lt; b &amp;&amp; v != x-1; ++j) v = static_cast&lt;int&gt;(1ll*v*v%x); if (j &gt;= b) return false; } return true; } 线性筛GCD 代码 inline void gcd_init(const int &amp;n) { for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (!g[i][j]) for (int k = 1; k &lt;= n/i; ++k) g[k*i][k*j] = k; } 分解质因数 代码 // x = pi^ki... for(int i = 2; i*i &lt;= x; ++i) if(x%i == 0) { p[++tot] = i; for(; x%i == 0; x /= i) k[tot]++; } if(x &gt; 1) p[++tot] = x, k[tot] = 1; BSGS求解关于 $t$ 的方程 $a^t \\equiv x(mod m),\\gcd(a, m) = 1$ 代码 inline long long BSGS(long long a, long long x, long long m) { // a^n = x static map&lt;long long, int&gt; mmp; mmp.clear(); long long t = sqrt(m)+1, b = 1, c = 1, res; for(int i = 0; i &lt; t; ++i, b = b*a%m) mmp[x*b%m] = i; for(int i = 0; i &lt;= t; ++i, c = c*b%m) { // b = a^t if(mmp.count(c)) { res = t*i-mmp[c]; if(res &gt; 0) return res; } } return -1; } 拓展BSGS$\\gcd(a, m) \\neq 1$ 代码 namespace EXBSGS { inline ll BSGS(ll a, ll b, ll mod, ll qaq){ unordered_map&lt;ll, int&gt; H; H.clear(); ll Q, p = ceil(sqrt(mod)), x, y; exgcd(qaq, mod, x, y), b = (b * x % mod + mod) % mod, Q = qpow(a, p, mod), exgcd(Q, mod, x, y), Q = (x % mod + mod) % mod ; for (ll i = 1, j = 0 ; j &lt;= p ; ++ j, i = i * a % mod) if (!H.count(i)) H[i] = j ; for (ll i = b, j = 0 ; j &lt;= p ; ++ j, i = i * Q % mod) if (H[i]) return j * p + H[i]; return -1 ; } inline ll exBSGS(ll N, ll P, ll M){ ll qaq = 1, k = 0, qwq = 1; if (M == 1) return 0 ; while ((qwq = __gcd(N, P)) &gt; 1) { if (M%qwq) return -1 ; ++k, M /= qwq, P /= qwq, qaq = qaq*(N/qwq)%P ; if (qaq == M) return k ; } return (qwq = BSGS(N, M, P, qaq)) == -1 ? -1 : qwq+k ; } } using EXBSGS::exBSGS; 错排$D_1 = 0$ $D_2 = 1$ $D_n = (n-1)(D_{n-1}+D_{n-2})$ 原根参考博客 复杂度 $O(\\sqrt{m}+g\\times\\log^2m)$ 代码 inline int getG(const int &amp;m) { static int q[100000+7]; int _phi = phi(m), x = _phi, tot = 0; for (int i = 2; i*i &lt;= _phi; ++i) { if (x%i) continue; q[++tot] = _phi/i; while (x%i == 0) x /= i; } if (x &gt; 1) x = q[++tot] = _phi/x; for (int g = 2, flag; ; ++g) { flag = 1; if (qpow(g, _phi, m) != 1) continue; for (int i = 1; i &lt;= tot; ++i) { if (qpow(g, q[i], m) == 1) { flag = 0; break; } } if (flag) return g; } } 单位根反演$[k|n]=\\frac{1}{k}\\sum\\limits_{i=0}^{k-1}w_{k}^{ni}$ $[a\\equiv b(\\mod n)]=[a-b \\equiv 0(\\mod n)]=\\frac{1}{n}\\sum\\limits_{i=0}^{n-1}w_n^{(a-b)k}=\\frac{1}{n}\\sum\\limits_{i=0}^{n-1}w_n^{ak}w_n^{-bk}$ 单位根卷积$\\sum\\limits_{i=0}^{n}[i\\%k=0]f(i)=\\sum\\limits_{i=0}^{n}\\frac{1}{k}\\sum\\limits_{j=0}^{k-1}(w_k^i)^jf(i)$ 大数阶乘分块打表 代码 namespace BigFac { #define lon long long lon a[110]={1,682498929,491101308,76479948,723816384,67347853,27368307, 625544428,199888908,888050723,927880474,281863274,661224977,623534362, 970055531,261384175,195888993,66404266,547665832,109838563,933245637, 724691727,368925948,268838846,136026497,112390913,135498044,217544623, 419363534,500780548,668123525,128487469,30977140,522049725,309058615, 386027524,189239124,148528617,940567523,917084264,429277690,996164327, 358655417,568392357,780072518,462639908,275105629,909210595,99199382, 703397904,733333339,97830135,608823837,256141983,141827977,696628828, 637939935,811575797,848924691,131772368,724464507,272814771,326159309, 456152084,903466878,92255682,769795511,373745190,606241871,825871994, 957939114,435887178,852304035,663307737,375297772,217598709,624148346, 671734977,624500515,748510389,203191898,423951674,629786193,672850561, 814362881,823845496,116667533,256473217,627655552,245795606,586445753, 172114298,193781724,778983779,83868974,315103615,965785236,492741665, 377329025,847549272,698611116}; lon fac(lon n, lon p = MOD) { if (n &gt;= p) { return 0; } else if (p==1000000007) { lon now=n/10000000; lon ans=a[now]; for(lon i=now*10000000+1;i&lt;=n;i++) ans=ans*i%p; return ans%p; } else { lon ans=1; for(int i=1;i&lt;=n;i++) ans=ans*i%p; return ans%p; } } } 全排列和逆序对根据逆序数推排列数已知一个n元排列的逆序数为m,这样的n元排列有多少种？ 对任意n&gt;=2且0&lt;=m&lt;=C(n,2)时f(n,m)&gt;=1；当m&gt;C(n,2)时,f(n,m)=0 f(n,m)=f(n,C(n,2)-m) f(n+1,m)=f(n,m)+f(n,m-1)+…+f(n,m-n) f(n,0)=f(n,C(n,2))=1 f(n,1)=f(n,C(n,2)-1)=n-1(n&gt;1) f(n,2)=f(n,C(n,2)-2)=C(n,2)-1(n&gt;2) 根据每个数的逆序数求出原排列根据逆序数求最小排列 对于n的全排列，在它完全倒序的时候（也就是n,n-1,…,2,1的时候）逆序数最多。 对于一个形如1,2,3,…,i-1,i,n,…i+1的排列q（如n=5时的1,2,5,4,3），即在数n前保证首项为1且严格以公差为1递增而数n之后排列任意的数列 当数n之后是递减的时候q的逆序数最多，为t=C(n-i,2)。 排列q是出现逆序数为t的最小排列。 在上一条所设定的排列q的基础上，我们将数n后面的第k小数与数n的前一个数（即i）交换，然后使数n后面保持逆序。这样得到的新排列所含的逆序数为t=C(n-i,2)+k，且这个排列是逆序数为t的最小排列。 第k个字典序每个数的逆序对 代码 // n个数排列的第k个(字典序)的逆序对 int f(int k) { int res = 0; for (int j = n; j; --j) { res += k/fac[j]; k %= fac[j]; } return res; } 二次剩余 代码 namespace Cipolla { int mod, _x0, _x1; long long I_mul_I; // 虚数单位的平方 struct complex { long long real, imag; complex(long long real = 0, long long imag = 0): real(real), imag(imag) { } }; inline bool operator == (complex x, complex y) { return x.real == y.real and x.imag == y.imag; } inline complex operator * (complex x, complex y) { return complex((x.real * y.real + I_mul_I * x.imag % mod * y.imag) % mod, (x.imag * y.real + x.real * y.imag) % mod); } complex power(complex x, int k) { complex res = 1; while(k) { if(k &amp; 1) res = res * x; x = x * x; k &gt;&gt;= 1; } return res; } bool check_if_residue(int x) { return power(x, (mod - 1) &gt;&gt; 1) == 1; } int solve(int n, int p, int &amp;x0 = _x0, int &amp;x1 = _x1) { mod = p; if (power(n, p&gt;&gt;1) == p-1) return x0 = -1; // 无解 if (power(n, p&gt;&gt;1) == 0) return x0 = x1 = 0; long long a = rand() % mod; while(!a or check_if_residue((a * a + mod - n) % mod)) a = rand() % mod; I_mul_I = (a * a + mod - n) % mod; x0 = int(power(complex(a, 1), (mod + 1) &gt;&gt; 1).real); x1 = mod - x0; return x0; } } // namespace Cipolla 动态规划 DP(我全都不会) 记忆化搜索线性DP最长上升子序列LIS 代码 for(int i = 1; i &lt;= n; ++i) { f[i] = 1; for(int j = 1; j &lt; i; ++j) if(a[i] &gt; a[j]) f[i] = max(f[i],f[j]+1); } 最长公共子序列LCS 代码 f[i][j] = max{ f[i-1][j], f[i][j-1], f[i-1][j-1]+1 (if A[i] == B[j])} 数字三角形区间DP树形DP状压DP枚举子集 代码 for (int i = s; i; i = (i-1)&amp;s) {} 枚举n个元素,大小为k的二进制子集 代码 int s=(1&lt;&lt;k)-1; while(s&lt;(1&lt;&lt;n)){ work(s); int x=s&amp;-s,y=s+x; s=((s&amp;~y)/x&gt;&gt;1)|y; //这里有一个位反~ } 背包问题01背包完全背包混合背包分组背包多重背包二进制拆分 代码 for(int i = 1, cnt, vi, wi, m; i &lt;= n; ++i) { scanf(\"%d%d%d\", &amp;vi, &amp;wi, &amp;m); cnt = 1; while(m-cnt &gt; 0) { m -= cnt; v.push_back(vi*cnt); w.push_back(wi*cnt); cnt &lt;&lt;= 1; } v.push_back(vi*m); w.push_back(wi*m); } for(int i = 0; i &lt; w.size(); ++i) for(int j = W; j &gt;= w[i]; --j) b[j] = max(b[j], b[j-w[i]]+v[i]); 单调队列 代码 for(int i = 1; i &lt;= n; ++i) { scanf(\"%d%d%d\", &amp;v, &amp;w, &amp;m); for(int u = 0; u &lt; w; ++u) { int maxp = (W-u)/w; head = 1; tail = 0; for(int k = maxp-1; k &gt;= max(0, maxp-m); --k) { while(head &lt;= tail &amp;&amp; calc(u, q[tail]) &lt;= calc(u, k)) tail--; q[++tail] = k; } for(int p = maxp; p &gt;= 0; --p) { while(head &lt;= tail &amp;&amp; q[head] &gt;= p) head++; if(head &lt;= tail) f[u+p*w] = max(f[u+p*w], p*v+calc(u, q[head])); if(p-m-1 &lt; 0) continue; while(head &lt;= tail &amp;&amp; calc(u, q[tail]) &lt;= calc(u, p-m-1)) tail--; q[++tail] = p-m-1; } } } int ans = 0; for(int i = 1; i &lt;= W; ++i) ans = max(ans, f[i]); SOS DPWQS二分|DP凸优化题目给了一个选物品的限制条件，要求刚好选m个，让你最大化（最小化）权值, 其特点是函数的斜率单调 例:给你一个N个点M条边无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有K条白色边的生成树。 记 $g(i)$ 是选了 $i$ 条白边的最小生成树值, 发现 $g(i)$ 斜率单调不增 $g(i)-g(i-1) \\leq g(i+1)-g(i)$ 则二分斜率 k, 求切点(截距最大) 设$f(x)$为我在没有固定选多少个点(但是我已经选了x个点)时的答案(也就是截距), $f(x)=g(x)-k*x$ 只要把每个数的$h(x)−=k$然后正常求一下在选任意个数的情况下最大$f(x)$是多少 $O(n\\log n)$ 斜率优化若dp方程为 $dp[i]=a[i] \\cdot b[j]+c[i]+d[j]$ 时,由于存在$a[i] \\cdot b[j]$ 这个既有 $i$ 又有 $j$ 的项,就需要使用斜率优化 「HNOI2008」玩具装箱 TOY$dp[i]=min(dp[j]+(sum[i]+i−sum[j]−j−L−1)^2)(j&lt;i)$ 令$a[i]=sum[i]+i,b[i]=sum[i]+i+L+1$ $dp[i]=dp[j]+(a[i]-b[j])^2$ $dp [ i ] = dp [ j ] + a [ i ] ^ 2 - 2 a [ i ] b [ j ] + b [ j ] ^ 2$ $2 a [ i ] b [ j ] + dp [ i ] - a [ i ] ^ 2 = dp [ j ] + b [ j ] ^ 2$ 将 $b[j]$ 看作 $x,dp[j]+b[j]^2$ 看作 $y$，这个式子就可以看作一条斜率为 $2 a[i]$ 的直线 而对于每个 $i$ 来说, $a[i]$ 都是确定的, 类似线性规划 $dp[i]$ 的含义转化为：当上述直线过点 $P(b[j],dp[j]+b[j]^2)$ 时，直线在 $y$ 轴的截距加上 $a[i]^2$ (一个定值) 而题目即为找这个截距的最小值 四边形不等式2D1D$f_{l,r}=\\min\\limits_{k=l}^{r-1} {f_{l,k}+f_{k+1,r}}+w(l,r) \\ \\ (1\\leq l \\leq r \\leq n)$ 当 $w(l,r)$ 满足特定性质 区间包含单调性 ：如果对于任意 $l\\leq l’ \\leq r’ \\leq r$ ，均有 $w(l’,r’)\\leq w(l,r)$ 成立，则称函数 $w$ 对于区间包含关系具有单调性。 四边形不等式 ：如果对于任意 $l_1 \\leq l_2 \\leq r_1 \\leq r_2$ ，均有 $w(l_1,r_1)+w(l_2,r_2) \\leq w(l_1,r_2)+w(l_2,r_1)$ 成立，则称函数 $w$ 满足四边形不等式（简记为“交叉小于包含”）。若等号永远成立，则称函数 $w$ 满足 四边形恒等式 。 引理 1 ：若满足关于区间包含的单调性的函数 $w(l,r)$ 满足四边形不等式，则状态 $f_{l,r}$ 也满足四边形不等式。 定理 1 ：若状态 $f$ 满足四边形不等式，记 $m_{l,r}=\\min{k:f_{l,r}=g_{k,l,r}}$ 表示最优决策点，则有 $m_{l,r-1} \\leq m_{l,r} \\leq m_{l+1,r}$ 1D1D$f_r = \\min\\limits_{l=1}^{r-1} {f_l+w(l,r)} \\ \\ (1\\leq r \\leq n)$ 定理 2 ：若函数 $w(l,r)$ 满足四边形不等式，记 $h_{l,r}=f_l+w(l,r)$ 表示从 $l$ 转移过来的状态 $r$ , $k_r=\\min{l|f_r=h_{l,r}}$ 表示最优决策点，则有 $\\forall r_1 \\leq r_2 : k_{r1} \\leq k_{r2}$ 代码 void DP(int l, int r, int k_l, int k_r) { int mid = (l + r) / 2, k = k_l; // 求状态f[mid]的最优决策点 for (int i = k_l; i &lt;= min(k_r, mid - 1); ++i) if (w(i, mid) &lt; w(k, mid)) k = i; f[mid] = w(k, mid); // 根据决策单调性得出左右两部分的决策区间，递归处理 if (l &lt; mid) DP(l, mid - 1, k_l, k); if (r &gt; mid) DP(mid + 1, r, k, k_r); } 满足四边形不等式的函数类 性质 1 ：若函数 $w_1(l,r),w_2(l,r)$ 均满足四边形不等式（或区间包含单调性），则对于任意 $c_1,c_2\\geq 0$ ，函数 $c_1w_1+c_2w_2$ 也满足四边形不等式（或区间包含单调性）。 性质 2 ：若存在函数 $f(x),g(x)$ 使得 $w(l,r) = f(r)-g(l)$ ，则函数 $w$ 满足四边形恒等式。当函数 $f,g$ 单调增加时，函数 $w$ 还满足区间包含单调性。 性质 3 ：设 $h(x)$ 是一个单调增加的凸函数，若函数 $w(l,r)$ 满足四边形不等式并且对区间包含关系具有单调性，则复合函数 $h(w(l,r))$ 也满足四边形不等式和区间包含单调性。 性质 4 ：设 $h(x)$ 是一个凸函数，若函数 $w(l,r)$ 满足四边形恒等式并且对区间包含关系具有单调性，则复合函数 $h(w(l,r))$ 也满足四边形不等式。 首先需要澄清一点，凸函数（Convex Function）的定义在国内教材中有分歧，此处的凸函数指的是（可微的）下凸函数，即一阶导数单调增加的函数。 插头DP|轮廓线DP一个闭合回路 代码 const int P = 299987; const int M = 1&lt;&lt;21; const int N = 15; int n, m; int a[N][N]; long long dp[2][M]; int head[2][P], nex[2][M], tot[2], ver[2][M]; // long long dp[2][P]; // int head[2][P], nex[2][P], tot[2], ver[2][P]; inline void clear(const int &amp;u) { for (int i = 1; i &lt;= tot[u]; ++i) { dp[u][i] = 0; // nex[u][i] = 0; // head[u][ver[u][i]%P] = 0; } tot[u] = 0; } template &lt;typename T, typename U&gt; inline void insert(const int &amp;u, const T &amp;x, const U &amp;v) { int p = x%P; for (int i = head[u][p]; i; i = nex[u][i]) { if (ver[u][i] == x) return dp[u][i] += v, void(); } ++tot[u]; assert(tot[u] &lt; M); ver[u][tot[u]] = x; nex[u][tot[u]] = head[u][p]; head[u][p] = tot[u]; dp[u][tot[u]] = v; } template &lt;typename T&gt; inline int get_val(const int &amp;u, const T &amp;x) { int p = x%P; for (int i = head[u][p]; i; i = nex[u][i]) { if (ver[u][i] == x) return dp[u][i]; } return 0; } inline long long solve() { int u = 0, base = (1&lt;&lt;m*2+2)-1; long long res = 0; clear(u); insert(u, 0, 1); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { clear(u ^= 1); for (int k = 1; k &lt;= tot[u^1]; ++k) { int state = ver[u^1][k]; long long val = dp[u^1][k]; if (j == 1) state = (state&lt;&lt;2)&amp;base; // b1 right b2 down // 0 no 1 left 2 right int b1 = (state&gt;&gt;j*2-2)%4, b2 = (state&gt;&gt;j*2)%4; if (!a[i][j]) { if (!b1 &amp;&amp; !b2) insert(u, state, val); } else if (!b1 &amp;&amp; !b2) { if (a[i+1][j] &amp;&amp; a[i][j+1]) insert(u, state+(1&lt;&lt;j*2-2)+(2&lt;&lt;j*2), val); } else if (!b1 &amp;&amp; b2) { if (a[i][j+1]) insert(u, state, val); if (a[i+1][j]) insert(u, state+(b2&lt;&lt;j*2-2)-(b2&lt;&lt;j*2), val); } else if (b1 &amp;&amp; !b2) { if (a[i+1][j]) insert(u, state, val); if (a[i][j+1]) insert(u, state-(b1&lt;&lt;j*2-2)+(b1&lt;&lt;j*2), val); } else if (b1 == 1 &amp;&amp; b2 == 1) { // find 2 turn to 1 for (int k = j+1, t = 1; k &lt;= m; ++k) { if ((state&gt;&gt;k*2)%4 == 1) ++t; if ((state&gt;&gt;k*2)%4 == 2) --t; if (!t) { insert(u, state-(1&lt;&lt;j*2-2)-(1&lt;&lt;j*2)-(1&lt;&lt;k*2), val); break; } } } else if (b1 == 2 &amp;&amp; b2 == 2) { // find 1 turn to 2 for (int k = j-2, t = 1; k &gt;= 0; --k) { if ((state&gt;&gt;k*2)%4 == 1) --t; if ((state&gt;&gt;k*2)%4 == 2) ++t; if (!t) { insert(u, state-(2&lt;&lt;j*2-2)-(2&lt;&lt;j*2)+(1&lt;&lt;k*2), val); break; } } } else if (b1 == 2 &amp;&amp; b2 == 1) { insert(u, state-(2&lt;&lt;j*2-2)-(1&lt;&lt;j*2), val); } else if (i == ex &amp;&amp; j == ey) { // b1 == 1, b2 == 2 res += val; } } } } return res; } 多个闭合回路 代码 else if (b1 == 1 &amp;&amp; b2 == 2) { if (i == ex &amp;&amp; j == ey) res += val; else dp[u][bit-(1&lt;&lt;j*2-2)-(1&lt;&lt;j*2+1)] += val; } 联通块 代码 int n, u, res = -INF; int a[N][N]; unordered_map&lt;int, int&gt; dp[2]; inline void decode(const int &amp;state, int *const s) { for (int i = 1; i &lt;= n; ++i) s[i] = (state&gt;&gt;i*3-3)%8; } inline void insert(const int *const s, const int &amp;val) { static int vis[N]; int state = 0, cnt = 0; memset(vis, 0, sizeof vis); for (int i = 1; i &lt;= n; ++i) { if (s[i] &amp;&amp; !vis[s[i]]) vis[s[i]] = ++cnt; state |= (vis[s[i]]&lt;&lt;i*3-3); } if (dp[u].count(state)) dp[u][state] = max(dp[u][state], val); else dp[u].insert({state, val}); if (cnt == 1) res = max(res, val); } inline void solve() { static int s[N]; dp[u = 0].clear(); dp[u][0] = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { dp[u ^= 1].clear(); for (const auto &amp;p : dp[u^1]) { decode(p.first, s); int b1 = s[j-1], b2 = s[j]; // not choose s[j] = 0; int cnt = 0; for (int k = 1; k &lt;= n; ++k) cnt += s[k] == b2; if (!b2 || cnt) insert(s, p.second); s[j] = b2; // choose if (!b1 &amp;&amp; !b2) { s[j] = 7; } else { if (b1 &gt; b2) swap(b1, b2); // in case b2 == 0 s[j] = b2; if (b1) for (int k = 1; k &lt;= n; ++k) if (s[k] == b1) s[k] = b2; } insert(s, p.second+a[i][j]); } } } cout &lt;&lt; res &lt;&lt; endl; } L型L 型地板：拐弯且仅拐弯一次。 发现没有，一个存在的插头只有两种状态：拐弯过和没拐弯过，因此我们这样定义插头： 0表没有插头，1表没拐过的插头，2表已经拐过的插头。b1代表当前点的右插头,b2代表当前点的下插头 DP套DP有 $dp_1, f[i]$ 为 $dp_1[n] = i$ 的方案数,求 $f$ 设 $dp_2[dp_1]$ 为 $dp_1$ 状态下的方案数 动态DP将 dp 转换为线段树可以求解的区间问题,动态维护 动态线性DP动态树形DP树链剖分,轻链暴力 STLunordered_map 重载 代码 struct Node { int a, b; // 重载 == friend bool operator == (const Node &amp;x, const Node &amp;y) { return x.a == y.a &amp;&amp; x.b == y.b; } }; // 方法一 namespace std { template &lt;&gt; struct hash&lt;Node&gt; { size_t operator () (const Node &amp;x) const { return hash&lt;int&gt;()(x.a)^hash&lt;int&gt;()(x.b); } }; } unordered_map&lt;Node, int&gt; mp; // 方法二 struct KeyHasher { size_t operator () (const Node &amp;x) const { return hash&lt;int&gt;()(x.a)^hash&lt;int&gt;()(x.b); } }; unordered_map&lt;Node, int, KeyHasher&gt; mmp; 定义函数 代码 function&lt;void(int&amp;, int)&gt; f = [&amp;](int &amp;x, int y) -&gt; void { x += y; }; 分数warning:未完全验证 代码 template &lt;class T&gt; struct Fraction { T a, b; void normalize() { if (a == 0) return (void)(b = 1); T g = __gcd(a, b); a /= g; b /= g; if (b &lt; 0) a = -a, b = -b; } Fraction(const T &amp;_a = 0, const T &amp;_b = 1) : a(_a), b(_b) { normalize(); } friend bool operator &lt; (const Fraction &amp;f1, const Fraction &amp;f2) { return f1.a*f2.b &lt; f2.a*f1.b; } friend bool operator &gt; (const Fraction &amp;f1, const Fraction &amp;f2) { return f1.a*f2.b &gt; f2.a*f1.b; } friend bool operator == (const Fraction &amp;f1, const Fraction &amp;f2) { return f1.a*f2.b == f2.a*f1.b; } friend bool operator != (const Fraction &amp;f1, const Fraction &amp;f2) { return f1.a*f2.b != f2.a*f1.b; } friend bool operator &lt;= (const Fraction &amp;f1, const Fraction &amp;f2) { return f1 &lt; f2 || f1 == f2; } friend bool operator &gt;= (const Fraction &amp;f1, const Fraction &amp;f2) { return f1 &gt; f2 || f1 == f2; } friend Fraction operator + (const Fraction &amp;f1, const Fraction &amp;f2) { return Fraction(f1.a*f2.b+f2.a*f1.b, f1.b*f2.b); } friend Fraction operator - (const Fraction &amp;f1, const Fraction &amp;f2) { return Fraction(f1.a*f2.b-f2.a*f1.b, f1.b*f2.b); } friend Fraction operator * (const Fraction &amp;f1, const Fraction &amp;f2) { return Fraction(f1.a*f2.a, f1.b*f2.b); } friend Fraction operator / (const Fraction &amp;f1, const Fraction &amp;f2) { return Fraction(f1.a*f2.b, f1.b*f2.a); } Fraction&amp; operator += (const Fraction &amp;f) { return *this = *this+f; } Fraction&amp; operator -= (const Fraction &amp;f) { return *this = *this-f; } Fraction&amp; operator *= (const Fraction &amp;f) { return *this = *this*f; } Fraction&amp; operator /= (const Fraction &amp;f) { return *this = *this/f; } friend istream&amp; operator &gt;&gt; (istream &amp;is, Fraction &amp;f) { is &gt;&gt; f.a &gt;&gt; f.b; f.normalize(); return is; } friend ostream&amp; operator &lt;&lt; (ostream &amp;os, const Fraction &amp;f) { if (f.b == 1) return os &lt;&lt; f.a; return os &lt;&lt; f.a &lt;&lt; \"/\" &lt;&lt; f.b; } }; using fraction = Fraction&lt;long long&gt;; 模数弟弟操作 代码 template &lt;int _MOD&gt; struct Mint { int v = 0; Mint() {} Mint(int _v) : v((_v%_MOD+_MOD)%_MOD) {} Mint(long long _v) : v(static_cast&lt;int&gt;((_v%_MOD+_MOD)%_MOD)) {} Mint operator = (const int &amp;_v) { return *this = Mint(_v); } Mint operator = (const long long &amp;_v) { return *this = Mint(_v); } bool operator ! () const { return !this-&gt;v; } bool operator &lt; (const Mint &amp;b) const { return v &lt; b.v; } bool operator &gt; (const Mint &amp;b) const { return v &gt; b.v; } bool operator == (const Mint &amp;b) const { return v == b.v; } bool operator != (const Mint &amp;b) const { return v != b.v; } bool operator &lt;= (const Mint &amp;b) const { return v &lt; b.v || v == b.v; } bool operator &gt;= (const Mint &amp;b) const { return v &gt; b.v || v == b.v; } Mint operator + (const Mint &amp;b) const { return Mint(v+b.v); } Mint operator - (const Mint &amp;b) const { return Mint(v-b.v); } Mint operator * (const Mint &amp;b) const { return Mint(1ll*v*b.v); } Mint operator / (const Mint &amp;b) const { return Mint(b.inv()*v); } Mint&amp; operator += (const Mint &amp;b) { return *this = *this+b; } Mint&amp; operator -= (const Mint &amp;b) { return *this = *this-b; } Mint&amp; operator *= (const Mint &amp;b) { return *this = *this*b; } Mint&amp; operator /= (const Mint &amp;b) { return *this = *this/b; } Mint operator - () const { return Mint(-v); } Mint&amp; operator ++ () { return *this += 1; } Mint&amp; operator -- () { return *this -= 1; } Mint operator ++ (int) { Mint tmp = *this; *this += 1; return tmp; } Mint operator -- (int) { Mint tmp = *this; *this -= 1; return tmp; } Mint pow(int p) const { Mint res(1), x(*this); while (p) { if (p&amp;1) res = res*x; x *= x; p &gt;&gt;= 1; } return res; } Mint inv() const { return pow(_MOD-2); } friend istream&amp; operator &gt;&gt; (istream &amp;is, Mint &amp;mt) { return is &gt;&gt; mt.v; } friend ostream&amp; operator &lt;&lt; (ostream &amp;os, const Mint &amp;mt) { return os &lt;&lt; mt.v; } }; using mint = Mint&lt;MOD&gt;; tourist的模板(用不来)某出处 注: #ifdef _WIN32部分可能导致 CE 代码 template &lt;typename T&gt; T inverse(T a, T m) { T u = 0, v = 1; while (a != 0) { T t = m / a; m -= t * a; swap(a, m); u -= t * v; swap(u, v); } assert(m == 1); return u; } template &lt;typename T&gt; class Modular { public: using Type = typename decay&lt;decltype(T::value)&gt;::type; constexpr Modular() : value() {} template &lt;typename U&gt; Modular(const U&amp; x) { value = normalize(x); } template &lt;typename U&gt; static Type normalize(const U&amp; x) { Type v; if (-mod() &lt;= x &amp;&amp; x &lt; mod()) v = static_cast&lt;Type&gt;(x); else v = static_cast&lt;Type&gt;(x % mod()); if (v &lt; 0) v += mod(); return v; } const Type&amp; operator()() const { return value; } template &lt;typename U&gt; explicit operator U() const { return static_cast&lt;U&gt;(value); } constexpr static Type mod() { return T::value; } Modular&amp; operator+=(const Modular&amp; other) { if ((value += other.value) &gt;= mod()) value -= mod(); return *this; } Modular&amp; operator-=(const Modular&amp; other) { if ((value -= other.value) &lt; 0) value += mod(); return *this; } template &lt;typename U&gt; Modular&amp; operator+=(const U&amp; other) { return *this += Modular(other); } template &lt;typename U&gt; Modular&amp; operator-=(const U&amp; other) { return *this -= Modular(other); } Modular&amp; operator++() { return *this += 1; } Modular&amp; operator--() { return *this -= 1; } Modular operator++(int) { Modular result(*this); *this += 1; return result; } Modular operator--(int) { Modular result(*this); *this -= 1; return result; } Modular operator-() const { return Modular(-value); } template &lt;typename U = T&gt; typename enable_if&lt;is_same&lt;typename Modular&lt;U&gt;::Type, int&gt;::value, Modular&gt;::type&amp; operator*=(const Modular&amp; rhs) { #ifdef _WIN32 uint64_t x = static_cast&lt;int64_t&gt;(value) * static_cast&lt;int64_t&gt;(rhs.value); uint32_t xh = static_cast&lt;uint32_t&gt;(x &gt;&gt; 32), xl = static_cast&lt;uint32_t&gt;(x), d, m; asm( \"divl %4; \\n\\t\" : \"=a\" (d), \"=d\" (m) : \"d\" (xh), \"a\" (xl), \"r\" (mod()) ); value = m; #else value = normalize(static_cast&lt;int64_t&gt;(value) * static_cast&lt;int64_t&gt;(rhs.value)); #endif return *this; } template &lt;typename U = T&gt; typename enable_if&lt;is_same&lt;typename Modular&lt;U&gt;::Type, int64_t&gt;::value, Modular&gt;::type&amp; operator*=(const Modular&amp; rhs) { int64_t q = static_cast&lt;int64_t&gt;(static_cast&lt;long double&gt;(value) * rhs.value / mod()); value = normalize(value * rhs.value - q * mod()); return *this; } template &lt;typename U = T&gt; typename enable_if&lt;!is_integral&lt;typename Modular&lt;U&gt;::Type&gt;::value, Modular&gt;::type&amp; operator*=(const Modular&amp; rhs) { value = normalize(value * rhs.value); return *this; } Modular&amp; operator/=(const Modular&amp; other) { return *this *= Modular(inverse(other.value, mod())); } template &lt;typename U&gt; friend const Modular&lt;U&gt;&amp; abs(const Modular&lt;U&gt;&amp; v) { return v; } template &lt;typename U&gt; friend bool operator==(const Modular&lt;U&gt;&amp; lhs, const Modular&lt;U&gt;&amp; rhs); template &lt;typename U&gt; friend bool operator&lt;(const Modular&lt;U&gt;&amp; lhs, const Modular&lt;U&gt;&amp; rhs); template &lt;typename U&gt; friend std::istream&amp; operator&gt;&gt;(std::istream&amp; stream, Modular&lt;U&gt;&amp; number); private: Type value; }; template &lt;typename T&gt; bool operator==(const Modular&lt;T&gt;&amp; lhs, const Modular&lt;T&gt;&amp; rhs) { return lhs.value == rhs.value; } template &lt;typename T, typename U&gt; bool operator==(const Modular&lt;T&gt;&amp; lhs, U rhs) { return lhs == Modular&lt;T&gt;(rhs); } template &lt;typename T, typename U&gt; bool operator==(U lhs, const Modular&lt;T&gt;&amp; rhs) { return Modular&lt;T&gt;(lhs) == rhs; } template &lt;typename T&gt; bool operator!=(const Modular&lt;T&gt;&amp; lhs, const Modular&lt;T&gt;&amp; rhs) { return !(lhs == rhs); } template &lt;typename T, typename U&gt; bool operator!=(const Modular&lt;T&gt;&amp; lhs, U rhs) { return !(lhs == rhs); } template &lt;typename T, typename U&gt; bool operator!=(U lhs, const Modular&lt;T&gt;&amp; rhs) { return !(lhs == rhs); } template &lt;typename T&gt; bool operator&lt;(const Modular&lt;T&gt;&amp; lhs, const Modular&lt;T&gt;&amp; rhs) { return lhs.value &lt; rhs.value; } template &lt;typename T&gt; Modular&lt;T&gt; operator+(const Modular&lt;T&gt;&amp; lhs, const Modular&lt;T&gt;&amp; rhs) { return Modular&lt;T&gt;(lhs) += rhs; } template &lt;typename T, typename U&gt; Modular&lt;T&gt; operator+(const Modular&lt;T&gt;&amp; lhs, U rhs) { return Modular&lt;T&gt;(lhs) += rhs; } template &lt;typename T, typename U&gt; Modular&lt;T&gt; operator+(U lhs, const Modular&lt;T&gt;&amp; rhs) { return Modular&lt;T&gt;(lhs) += rhs; } template &lt;typename T&gt; Modular&lt;T&gt; operator-(const Modular&lt;T&gt;&amp; lhs, const Modular&lt;T&gt;&amp; rhs) { return Modular&lt;T&gt;(lhs) -= rhs; } template &lt;typename T, typename U&gt; Modular&lt;T&gt; operator-(const Modular&lt;T&gt;&amp; lhs, U rhs) { return Modular&lt;T&gt;(lhs) -= rhs; } template &lt;typename T, typename U&gt; Modular&lt;T&gt; operator-(U lhs, const Modular&lt;T&gt;&amp; rhs) { return Modular&lt;T&gt;(lhs) -= rhs; } template &lt;typename T&gt; Modular&lt;T&gt; operator*(const Modular&lt;T&gt;&amp; lhs, const Modular&lt;T&gt;&amp; rhs) { return Modular&lt;T&gt;(lhs) *= rhs; } template &lt;typename T, typename U&gt; Modular&lt;T&gt; operator*(const Modular&lt;T&gt;&amp; lhs, U rhs) { return Modular&lt;T&gt;(lhs) *= rhs; } template &lt;typename T, typename U&gt; Modular&lt;T&gt; operator*(U lhs, const Modular&lt;T&gt;&amp; rhs) { return Modular&lt;T&gt;(lhs) *= rhs; } template &lt;typename T&gt; Modular&lt;T&gt; operator/(const Modular&lt;T&gt;&amp; lhs, const Modular&lt;T&gt;&amp; rhs) { return Modular&lt;T&gt;(lhs) /= rhs; } template &lt;typename T, typename U&gt; Modular&lt;T&gt; operator/(const Modular&lt;T&gt;&amp; lhs, U rhs) { return Modular&lt;T&gt;(lhs) /= rhs; } template &lt;typename T, typename U&gt; Modular&lt;T&gt; operator/(U lhs, const Modular&lt;T&gt;&amp; rhs) { return Modular&lt;T&gt;(lhs) /= rhs; } template&lt;typename T, typename U&gt; Modular&lt;T&gt; power(const Modular&lt;T&gt;&amp; a, const U&amp; b) { assert(b &gt;= 0); Modular&lt;T&gt; x = a, res = 1; U p = b; while (p &gt; 0) { if (p &amp; 1) res *= x; x *= x; p &gt;&gt;= 1; } return res; } template &lt;typename T&gt; bool IsZero(const Modular&lt;T&gt;&amp; number) { return number() == 0; } template &lt;typename T&gt; string to_string(const Modular&lt;T&gt;&amp; number) { return to_string(number()); } template &lt;typename T&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Modular&lt;T&gt;&amp; number) { return stream &lt;&lt; number(); } template &lt;typename T&gt; std::istream&amp; operator&gt;&gt;(std::istream&amp; stream, Modular&lt;T&gt;&amp; number) { typename common_type&lt;typename Modular&lt;T&gt;::Type, int64_t&gt;::type x; stream &gt;&gt; x; number.value = Modular&lt;T&gt;::normalize(x); return stream; } /* using ModType = int; struct VarMod { static ModType value; }; ModType VarMod::value; ModType&amp; md = VarMod::value; using Mint = Modular&lt;VarMod&gt;; */ constexpr int md = 998244353; using Mint = Modular&lt;std::integral_constant&lt;decay&lt;decltype(md)&gt;::type, md&gt;&gt;; 高精度食用前请必须注意位数是否足够! vector版本压位+vector+符号 版本 int[]版本一本通习题洛谷习题 此版本 压位+数组,支持cin,cout,string,long long转换,比较运算符,四则运算(包括高精度乘/除低精度,取模),支持带符号的减法运算,支持幂运算,开根运算 可以通过开根外所有习题 代码 struct BigInteger { static const int SIZE = 1e6; // 位数SIZE*4 static const int BASE = 1e4; // 压位 static const int WIDTH = 4; int v[SIZE], len; int tag; // 假装有正负符号 BigInteger(long long num = 0) { *this = num; } BigInteger(const string &amp;str) { *this = str; } // long long 转 BigInteger BigInteger operator = (long long num) { len = tag = 0; memset(v, 0, sizeof v); do { v[++len] = (int)(num%BASE); num /= BASE; } while (num &gt; 0); return *this; } // string 转 BigInteger BigInteger operator = (const string &amp;str) { string buf; int r = (int)str.length()-1, l = max(0, r-WIDTH+1); len = tag = 0; memset(v, 0, sizeof v); while (r &gt;= 0) { buf = str.substr(l, r-l+1); sscanf(buf.c_str(), \"%d\", &amp;v[++len]); r -= WIDTH; l = max(0, r-WIDTH+1); } return *this; } // 比较运算 bool operator &lt; (const BigInteger &amp;b) const { if(len != b.len) return len &lt; b.len; for(int i = len; i; --i) if(v[i] != b.v[i]) return v[i] &lt; b.v[i]; return false; } bool operator &gt; (const BigInteger &amp;b) const { return b &lt; *this; } bool operator &lt;= (const BigInteger &amp;b) const { return !(b &lt; *this); } bool operator &gt;= (const BigInteger &amp;b) const { return !(*this &lt; b); } bool operator != (const BigInteger &amp;b) const { return *this &lt; b || b &lt; *this; } bool operator == (const BigInteger &amp;b) const { return !(*this &lt; b) &amp;&amp; !(b &lt; *this); } // 四则运算 BigInteger operator + (const BigInteger &amp;b) const { BigInteger res = b; res.len = max(len, b.len); for(int i = 1; i &lt;= len; ++i) res.v[i] += v[i]; for(int i = 1; i &lt;= res.len; ++i) res.v[i+1] += res.v[i]/BASE, res.v[i] %= BASE; while(res.v[res.len+1] &gt; 0) res.len++; return res; } // 单目运算 BigInteger operator + () const { return *this; } BigInteger operator - () const { BigInteger res = *this; res.tag ^= 1; return res; } BigInteger operator - (const BigInteger &amp;b) const { if(*this &lt; b) return -(b-*this); BigInteger res = *this; for(int i = 1; i &lt;= b.len; ++i) res.v[i] -= b.v[i]; for(int i = 1; i &lt;= res.len; ++i) if(res.v[i] &lt; 0) res.v[i] += BASE, res.v[i+1]--; while(res.len &gt; 1 &amp;&amp; res.v[res.len] == 0) res.len--; return res; } // 高精度乘低精度 BigInteger operator * (int b) const { BigInteger res; long long tmp; res.len = len; for(int i = 1; i &lt;= len; ++i) { tmp = 1ll*b*v[i]; res.v[i] += (int)(tmp%BASE); res.v[i+1] += (int)(tmp/BASE+res.v[i]/BASE); res.v[i] %= BASE; } while(res.v[res.len+1] &gt; 0) res.len++; return res; } // 高精度乘高精度 BigInteger operator * (const BigInteger &amp;b) const { BigInteger res; res.len = len+b.len; for(int i = 1; i &lt;= len; ++i) for(int j = 1; j &lt;= b.len; ++j) { res.v[i+j-1] += v[i]*b.v[j]; res.v[i+j] += res.v[i+j-1]/BASE; res.v[i+j-1] %= BASE; } while(res.len &gt; 1 &amp;&amp; res.v[res.len] == 0) res.len--; return res; } // 高精度除低精度 BigInteger operator / (int b) const { long long divisor = 0; BigInteger res; for(int i = len; i; --i) { divisor = divisor*BASE+v[i]; if(divisor &lt; b) continue; res.v[i] = (int)(divisor/b); divisor %= b; res.len = max(res.len, i); } return res; } // 高精度除高精度 BigInteger operator / (const BigInteger &amp;b) const { BigInteger divisor, res; int l, r, mid; for(int i = len; i; --i) { divisor = divisor*BASE+v[i]; /* memcpy(divisor.v+1, divisor.v, sizeof(int)*(divisor.len+1)); while(divisor.v[divisor.len+1] &gt; 0) divisor.len++; divisor.v[1] = v[i]; */ if(divisor &lt; b) continue; l = 0; r = BASE-1; while(l &lt; r) { mid = (l+r+1)&gt;&gt;1; if(b*mid &lt;= divisor) l = mid; else r = mid-1; } divisor -= b*l; res.v[i] = l; res.len = max(res.len, i); } return res; } BigInteger operator % (const BigInteger &amp;b) const { return *this-*this/b*b; } BigInteger operator ++ () { return *this = *this+1; } BigInteger operator -- () { return *this = *this-1; } BigInteger&amp; operator += (const BigInteger &amp;b) { return *this = *this+b; } BigInteger&amp; operator -= (const BigInteger &amp;b) { return *this = *this-b; } BigInteger&amp; operator *= (const BigInteger &amp;b) { return *this = *this*b; } BigInteger&amp; operator /= (const BigInteger &amp;b) { return *this = *this/b; } BigInteger&amp; operator %= (const BigInteger &amp;b) { return *this = *this%b; } BigInteger&amp; operator *= (int b) { return *this = *this*b; } BigInteger&amp; operator /= (int b) { return *this = *this/b; } BigInteger&amp; operator %= (int b) { return *this = *this%b; } // 重载输入运算符 friend istream&amp; operator &gt;&gt; (istream &amp;is, BigInteger &amp;big) { string buf; if (is &gt;&gt; buf) big = buf; return is; } // 重载输出运算符 friend ostream&amp; operator &lt;&lt; (ostream &amp;os, const BigInteger &amp;big) { static char buf[10]; if (big.tag) os &lt;&lt; '-'; os &lt;&lt; big.v[big.len]; for (int i = big.len-1; i; --i) { sprintf(buf, \"%04d\", big.v[i]); for (int j = 0; j &lt; 4; ++j) os &lt;&lt; buf[j]; } return os; } // 幂 template &lt;typename T&gt; friend BigInteger pow (BigInteger a, T p) { if(p == 0) return 1; BigInteger res = 1; while(p) { if(p%2) res *= a; a *= a; p /= 2; } return res; } // 开根 friend BigInteger sqrt(const BigInteger &amp;a, const int p = 2) { BigInteger l, r = a, mid; while(l &lt; r) { mid = (l+r+1)/2; if(pow(mid, p) &lt;= a) l = mid; else r = mid-1; } return l; } friend BigInteger gcd(BigInteger a, BigInteger b) { while (b &gt; 0) a %= b, swap(a, b); return a; } friend BigInteger lcm(const BigInteger &amp;a, const BigInteger &amp;b) { return a/gcd(a, b)*b; } };","categories":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}],"tags":[],"keywords":[{"name":"ACM","slug":"ACM","permalink":"http://kaizynx.github.io/categories/ACM/"}]},{"title":"数列求和","slug":"Luogu-P4948","date":"2018-10-25T04:30:00.000Z","updated":"2022-04-10T07:52:45.141Z","comments":true,"path":"2018/10/25/Luogu-P4948/","link":"","permalink":"http://kaizynx.github.io/2018/10/25/Luogu-P4948/","excerpt":"Luogu P4948 数列求和一道究极的数列题前置知识点: 数列 排列组合 快速幂 乘法逆元","text":"Luogu P4948 数列求和一道究极的数列题前置知识点: 数列 排列组合 快速幂 乘法逆元 题面数列$b_i = i^k a^i$ 求 $b_i$ 的前 $n$ 项和 $T_n mod (10^9+7)$ 题解很大程度借鉴官方题解 暴力显然暴力可以搞个60分吧 数据点1,2 暴力枚举+快速幂 $O(n \\log k)$ 因为 $a^i$ 是可以递推的 数据点3 $k=0$ 此时 $b_i = a^i$ 等比数列求和 $\\frac{a(a^n-a)}{a-1}$ 加个乘法逆元 数据点4 $k=1$ 此时 $b_i = i a^i$ $T_n = 1a^1+2a^2+3a^3+…+na^n$ $aT_n = 1a^2+2a^3+3a^4+…+na^{n+1}$ $(a-1)T_n = na^{n+1}-a-\\sum\\limits_{i=2}^{n}a^i$ $(a-1)T_n = na^{n+1}-\\sum\\limits_{i=1}^{n}a^i$ $(a-1)T_n = na^{n+1}-\\frac{a(a^n-a)}{a-1}$ $T_n = \\frac{na^{n+1}-\\frac{a(a^n-a)}{a-1}}{a-1}$ 数据点5,6 $k=2$ 反正我推不来 40分代码#include &lt;bits/stdc++.h&gt; using namespace std; const int MOD = 1e9+7; long long n, ans; int a, k; void exgcd(int a, int b, int &amp;x, int &amp;y) { if(!b) { x = 1; y = 0; return; } exgcd(b, a%b, y, x); y -= a/b*x; } inline int mul_inverse(int a, int mo) { int x, y; exgcd(a, mo, x, y); return (x%mo+mo)%mo; } inline long long qpow(long long a, long long p, int mo) { long long res = 1; while(p) { if(p&amp;1) res = res*a%mo; a = a*a%mo; p &gt;&gt;= 1; } return res; } int main() { cin &gt;&gt; n &gt;&gt; a &gt;&gt; k; if(k == 0) ans = (qpow(a, n, MOD)-1)*a%MOD*mul_inverse(a-1, MOD)%MOD; else if(k == 1) { ans = (qpow(a, n, MOD)-1)*a%MOD*mul_inverse(a-1, MOD)%MOD; ans = mul_inverse(a-1, MOD)*(n%MOD*qpow(a, n+1, MOD)%MOD-ans+MOD)%MOD; } else { long long cur = 1; // cur = a^i for(int i = 1; i &lt;= n; ++i) { cur = cur*a%MOD; ans = (ans+qpow(i, k, MOD)*cur%MOD)%MOD; } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } 总之敲了暴力之后就有个感觉 关键肯定是 $i^k$ 满分做法设 $T_n(k) = \\sum\\limits_{i=1}^{n}i^k a^i$ $T_n(k) = 1^ka^1+2^ka^2+3^ka^3+…+n^ka^n$ $aT_n(k) = 1^ka^2+2^ka^3+3^ka^4+…+n^ka^{n+1}$ $(a-1)T_n(k) = n^ka^{n+1}-a+\\sum\\limits_{i=2}^{n}((i-1)^k-i^k)a^i$ 这时采用排列组合 $(i-1)^k = \\sum\\limits_{j=0}^{k}C_k^j \\times i^j\\times(-1)^{k-j}$ $(i-1)^k-i^k = \\sum\\limits_{j=0}^{k-1}C_k^j \\times i^j\\times(-1)^{k-j}$ 代回进去 $(a-1)T_n(k) = n^ka^{n+1}-a+\\sum\\limits_{i=2}^{n}\\sum\\limits_{j=0}^{k-1} i^j\\times a^i\\times C_k^j \\times (-1)^{k-j}$ 这时又惊奇得望向 $T_n(k) = \\sum\\limits_{i=1}^{n}i^k a^i$ $T_n(k)-a = \\sum\\limits_{i=2}^{n}i^k a^i$ $(a-1)T_n(k) = n^ka^{n+1}-a+\\sum\\limits_{j=0}^{k-1} [C_k^j \\times (-1)^{k-j} \\times (T_n(j)-a)]$ 由此就可以递推出最终结果是$T_n(k)$ 然后初始状态 $T_n(0) = a^1+a^2+a^3+… +a^n = \\frac{a(a^n-a)}{a-1}$ 我们可以预处理排列组合 $C_i^j,(i \\in [0, k], j\\in [0, i])$ $n^k$ 用递推 总的复杂度是$O(k^2)$ 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int Maxk = 2e3+7; const int MOD = 1e9+7; long long n; int a, k, inv; int C[Maxk][Maxk]; long long T[Maxk]; void exgcd(int a, int b, int &amp;x, int &amp;y) { if(!b) { x = 1; y = 0; return; } exgcd(b, a%b, y, x); y -= a/b*x; } inline int mul_inverse(int a, int mo) { int x, y; exgcd(a, mo, x, y); return (x%mo+mo)%mo; } inline long long qpow(long long a, long long p, int mo) { long long res = 1; a %= mo; while(p) { if(p&amp;1) res = res*a%mo; a = a*a%mo; p &gt;&gt;= 1; } return res; } inline void init() { for(int i = 0; i &lt;= k; ++i) { C[i][0] = C[i][i] = 1; for(int j = 1; j &lt;= i/2; ++j) C[i][j] = C[i][i-j] = (C[i-1][j-1]+C[i-1][j])%MOD; } inv = mul_inverse(a-1, MOD); T[0] = (qpow(a, n, MOD)-1+MOD)%MOD*a%MOD*inv%MOD; } int main() { cin &gt;&gt; n &gt;&gt; a &gt;&gt; k; init(); long long tmpn = n%MOD, // tmpn = n^i tmpa = qpow(a, n+1, MOD); for(int i = 1; i &lt;= k; ++i) { T[i] = (tmpn*tmpa%MOD-a+MOD)%MOD; tmpn = tmpn*(n%MOD)%MOD; for(int j = 0, flag; j &lt; i; ++j) { flag = (i-j)&amp;1 ? -1 : 1; T[i] = (T[i]+((T[j]-a+MOD)%MOD*C[i][j]%MOD*flag+MOD)%MOD)%MOD; } T[i] = T[i]*inv%MOD; } cout &lt;&lt; T[k] &lt;&lt; endl; return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://kaizynx.github.io/tags/乘法逆元/"},{"name":"快速幂","slug":"快速幂","permalink":"http://kaizynx.github.io/tags/快速幂/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"烹调方案","slug":"Luogu-P2261","date":"2018-10-18T08:30:00.000Z","updated":"2022-04-10T07:52:45.138Z","comments":true,"path":"2018/10/18/Luogu-P2261/","link":"","permalink":"http://kaizynx.github.io/2018/10/18/Luogu-P2261/","excerpt":"","text":"Luogu P2261 [CQOI2007]余数求和思路暴力用来验证答案 60 分,满卒 #include &lt;bits/stdc++.h&gt; using namespace std; int n; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 1; i &lt;= n; ++i) ans += k%i; printf(&quot;%lld\\n&quot;, ans); return 0; } 正经反正咋看看推不出什么玄学 O(1) 公式 先换一个不是那么直接的求膜法 $a \\% p = a - \\lfloor \\frac{a}{p} \\rfloor \\times p$ 所以答案可以先粗略看做(先不考虑n, k的大小关系) $\\sum\\limits_{i=1}^{n}(k-\\lfloor \\frac{k}{i} \\rfloor \\times i)$ $= n\\times k - \\sum\\limits_{i=1}^{k} \\lfloor \\frac{k}{i} \\rfloor \\times i$ 我们考虑优化后面那个式子 稍微借鉴了 Luogu P4863 JerryC Loves Driving 的思维方式 因为 $i$ 是每个不同的, 而 $\\lfloor \\frac{k}{i} \\rfloor$ 是可能相同的 不妨找到一个范围使得 $\\lfloor \\frac{k}{i} \\rfloor = x (i \\in [l, r]), x$ 是整数,定值 因为 $i$ 肯定是连续的,那么这些的和就是 $x \\times \\frac{(l+r)\\times (r-l+1)}{2}$ (求和公式) 再看怎么找范围,范围满足 $\\lfloor \\frac{k}{i} \\rfloor = x$ ,也就是 $x \\leq \\lfloor \\frac{k}{i} \\rfloor &lt; x+1$ 那么稍加思考就可以得出范围是 $[ \\lfloor \\frac{k}{x+1} \\rfloor +1, \\lfloor \\frac{k}{x} \\rfloor ]$ 不过虽然我们看似好厉害好厉害地玄学推理了一大推 实际复杂度任然堪忧,暴力是枚举 $i, O(n)$ ,而这里枚举 $x, O(k)$ 其实一样… 然后借鉴 Luogu T46446 矿脉开采 的降低数据大小的思路 我们不妨分别枚举 $i$ 和 $x$ 把 $k$ 分为 $\\sqrt{k}$ 的两份 复杂度为 $O(\\sqrt{k})$ 其实应该先想到这个大框架再去想到上面细致的处理 但我思路就是先玄学,再暴力,最后正规… 大体思路已经建成,还有很多细节要处理 首先是数据分割的问题 我想到 $k$ 是否是完全平方数,那么 $\\sqrt{k}$ 分哪边 其实没什么大纠结的,只是我比较蠢 关系是大致这样的 $k\\div i = x$ 假如我们先把 $[1, \\sqrt{k}]$ 分给 $i$ 那么 $k \\div i \\geq \\lfloor \\frac{k}{\\sqrt{k}} \\rfloor$ 所以 $x &lt;\\lfloor \\frac{k}{\\sqrt{k}} \\rfloor$ 所以就是这么分啦, 设$edge = \\sqrt{k}$ $i \\in [1, edge]$ $x \\in [1, k \\div edge)$ 就是开头忽略的 $n, k$ 的大小关系 首先很明显的就是 当 $n &gt; k$ 时 $k \\% n = k$,直接加上去就好了 另外 $n$ 过小就会影响到 $i$ 的取值范围进而又影响 $x$ $i$ 的取值范围很好调整, 调整为 $i \\in [1, \\min(n,edge)]$ 那么 $x$ 怎么调整,难道要玄学数学再推理一波? 其实聪明的我发现只要对枚举 $x$ 过程中的 $l, r$ 再做限制即可 小心爆 int 代码#include &lt;bits/stdc++.h&gt; using namespace std; int n, k; long long ans; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); ans = 1ll*n*k; int edge = sqrt(k); // k/i (i[1, edge]) &gt;= floor(k/edge) for(int i = 1; i &lt;= min(n, edge); ++i) ans -= k/i*i; // floor(k/j) = i, i &lt; floor(k/edge) for(int i = 1, l, r; i &lt; k/edge; ++i) { // floor(k/j) == i (j &lt;= n) // j [floor(k/(i+1))+1, floor(k/i)] l = k/(i+1)+1; r = k/i; r = min(r, n); if(l &gt; r) continue; ans -= 1ll*(r-l+1)*(l+r)/2*i; } printf(&quot;%lld\\n&quot;, ans); return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"膜法","slug":"膜法","permalink":"http://kaizynx.github.io/tags/膜法/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"博客进阶","slug":"Blog_advance","date":"2018-10-12T13:00:00.000Z","updated":"2022-04-10T07:52:45.124Z","comments":true,"path":"2018/10/12/Blog_advance/","link":"","permalink":"http://kaizynx.github.io/2018/10/12/Blog_advance/","excerpt":"","text":"进阶指南序自博客搭建初以来,就没什么时间进一步社会主义改造了 直到国庆期间(只有三天假期…),才有时间进行了一番大整改 主题选择真的,被之前的主题坑了太久 直到我迫不得已改成了 NexT 主题 这个一直倍受大家推崇和喜爱的号称 star 第一的主题 虽然形式简单,但已经集成了很多插件等玩意,比配置之前那个不知道方便多少 于是我弃坑了,现在的是 NexT 6.4.1 标配 NexTNexT 使用文档 这个还有中午,还有官网,多么好. 安照上面的一步步来应该没什么问题 高配 NexT百度 next 配置 其实就有很多其实相似度极高的配置教程 里面好玩的东西很多 坑点没怎么遇到过 插件安装和使用一般也就在最顶层文件夹输入类似下面的指令 npm install [插件名字] --save 如果要使得 Travis CI 上也能加载插件 只要在 .travis.yml 文件中的 install: 部分加上一行即可 # S: Build Lifecycle before_install: - npm install hexo-cli -g install: - npm install - npm install hexo-deployer-git --save - npm install [在这里] --save script: - hexo clean - hexo generate after_script: # 略略略 # End: Build LifeCycle 提一下自动部署这里丑化说在前头,还是老老实实本地 hexo deploy 比较好 自动部署坑太多,带来很多不必要的麻烦 因为你很难知道那边的环境到底哪里不同了 第三方集成服务其他主题配置都按照文档来就好 这里提一下,我们在主题的 _config.yml 配置文件中看到很多集成的插件,例如 # 分享条 # NeedMoreShare2 # Dependencies: https://github.com/theme-next/theme-next-needmoreshare2 # See: https://github.com/revir/need-more-share2 # Also see: https://github.com/DzmVasileusky/needShareButton # iconStyle: default | box # boxForm: horizontal | vertical # position: top / middle / bottom + Left / Center / Right # networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit, # Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot, # Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine, # Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailru needmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 把 enable: false 改成 enable: true 在按需求把剩下两个 false 改成 true 即可 其实不然,你点进去上面一些链接的 github 官网 (第三行的) 你要按照上面的代码操作,什么 cd 进某个目录再 git clone 就成功添加了 其实说的很清楚,按照上面的做就好 坑点 自动部署时还是没有! 因为你 clone 来的文件夹被 gitignore 掉了 修改在主题的文件夹里 \\主目录\\themes\\next\\ 的 .gitignore 文件 你会发现你克隆来的恰好在 \\source\\lib 完美被忽略,注释掉即可 我现在的 .gitignore 如下 .DS_Store .idea/ *.log *.iml yarn.lock package-lock.json node_modules/ # Ignore optional external libraries # 就是它,罪魁祸首 # source/lib/* # Track internal libraries &amp; Ignore unused verdors files source/lib/font-awesome/less/ source/lib/font-awesome/scss/ !source/lib/font-awesome/* !source/lib/jquery/ source/lib/ua-parser-js/* !source/lib/ua-parser-js/dist/ !source/lib/velocity/ 其实说实在的这个全部删掉都没大碍,不删反而出事了 你克隆来的文件夹包括 .git 你 git 提交时会报错 你在之前删掉这个文件夹就好了 如果你没删之间用了 git 呢 那你怕是再也加不上去了 骗你的 看这里 git rm --cached 那个文件夹 又可以了 自动部署图标无法显示以前自动部署时我的图标无法显示 就是首页啊归档啊那个旁边的图标 道理同上,被 .gitignore 掉了 这个图标系统的根应该在 \\themes\\next\\source\\lib\\font-awesome 至于图标来源,网上,一个叫做 fontawesome 的网页 其实不是这个 里的 我亲测应该是这个的中国版里的 至于具体用法,额…百度吧,我不太会 添加背景动画这个属于第三方集成服务 也是需要 clone 过来才能用的 光按百度上说法直接改 true 无效 # 背景动画 # Canvas-nest # 大部分都是这种,网络上应该能轻易找到样例 # Dependencies: https://github.com/theme-next/theme-next-canvas-nest canvas_nest: false # cpu占用太大 # JavaScript 3D library. # Dependencies: https://github.com/theme-next/theme-next-three # three_waves # 点点波浪(像海面)cpu占用极高 three_waves: false # canvas_lines # 点线几何体,占用最低(还是高) # 样例: https://notes.doublemine.me/ 其实我觉得这个最好看 canvas_lines: false # canvas_sphere # 球上凸点(柱?)占用高 canvas_sphere: false # 背景彩色线条,这个不占cpu但是只适合pisces主题(唉) # Only fit scheme Pisces # Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon # Canvas-ribbon # size: The width of the ribbon. # alpha: The transparency of the ribbon. # zIndex: The display level of the ribbon. canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1 我之所以没加这个特效是因为占用太大了 其实还是我不知道怎么魔改,看样例占用还行 添加 Valine 评论我找了找还是这个评论比较好,样式简单,支持匿名 配合 LeanCloud 额…找不到之前的教程了,自己找,满地都是 添加背景看这个 然后这里说说使用本地图片的方法 body { background:url(/images/bg.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; } 放到 /images 文件夹即可 那个你放头像啊图标啊各种东西的文件夹 未完待续吧主要还是百度骚配置 坑点大致如此","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kaizynx.github.io/tags/Blog/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"能量采集","slug":"Luogu-P1447","date":"2018-10-08T12:30:00.000Z","updated":"2022-04-10T07:52:45.137Z","comments":true,"path":"2018/10/08/Luogu-P1447/","link":"","permalink":"http://kaizynx.github.io/2018/10/08/Luogu-P1447/","excerpt":"","text":"Luogu P1447 [NOI2010]能量采集思路参考自题解 分析某个点的连接线段上有几个植物(包括本身) 设这个点的坐标是 $(i, j)$, 答案就是 $\\gcd (i, j)$ 采用离散化思想, 把 $(i, j)$ 离散成 $(\\frac{i}{\\gcd}, \\frac{j}{\\gcd})$ 不要再深入解释了吧… 方案就是 $i \\div \\frac{i}{\\gcd} = \\gcd$ 总结果是 $\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} 2\\times(\\gcd (i,j) - 1)+1$ $= 2 \\times \\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} (\\gcd (i,j)) - nm$ 然后暴力枚举, 80分 get… 我们设 $f[x]$ 是 gcd 为 x 的 (i, j) 的对数, 这个不好直接求 设 $g[x]$ 是包含 x 公因数的 (i, j) 对数 $g[x]$ 很好求, $g[x] = \\frac{n}{x} \\times \\frac{m}{x}$ 就是选择 x 倍数的长和 x 倍数的宽, 乘法定理… 两者什么关系呢, $g[x] = f[x] + f[2x] + f[3x] + …$ 所以根据容斥原理, $f[x] = g[x] - f[2x] - f[3x] - …$ 所以我们就可以逆着推出 $f[x]$ 时间复杂度$\\sum\\limits_{i=1}^{n} \\frac{n}{i} = n\\log n$ 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int Maxn = 1e5+7; int n, m; long long ans, f[Maxn]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = min(n, m); i; --i) { f[i] = 1ll*(n/i)*(m/i); for(long long j = i+i; j &lt;= min(n, m); j += i) f[i] -= f[j]; ans += f[i]*i; } cout &lt;&lt; ans*2-1ll*n*m &lt;&lt; endl; return 0; } 结尾其实本题的正确做法应该是 莫比乌斯反演,狄利克雷卷积 之类加上玄学推导数论题 但是我不会不会不会啊 就这种解释看得懂","categories":[{"name":"NOI","slug":"NOI","permalink":"http://kaizynx.github.io/categories/NOI/"}],"tags":[{"name":"容斥原理","slug":"容斥原理","permalink":"http://kaizynx.github.io/tags/容斥原理/"},{"name":"最大公约数","slug":"最大公约数","permalink":"http://kaizynx.github.io/tags/最大公约数/"}],"keywords":[{"name":"NOI","slug":"NOI","permalink":"http://kaizynx.github.io/categories/NOI/"}]},{"title":"播放列表的数量","slug":"LeetCode920","date":"2018-10-07T23:50:00.000Z","updated":"2022-04-10T07:52:45.136Z","comments":true,"path":"2018/10/08/LeetCode920/","link":"","permalink":"http://kaizynx.github.io/2018/10/08/LeetCode920/","excerpt":"","text":"LeetCode 920. 播放列表的数量题面你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表： 每首歌至少播放一次。 一首歌只有在其他 K 首歌播放完之后才能再次播放。 返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。 数据范围0 &lt;= K &lt; N &lt;= L &lt;= 100 样例示例 1：输入：N = 3, L = 3, K = 1 输出：6 解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1]. 示例 2：输入：N = 2, L = 3, K = 0 输出：6 解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2] 示例 3：输入：N = 2, L = 3, K = 1 输出：2 解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2] 示例 4：输入：N = 3, L = 3, K = 0 输出：6 我的思路假如我们第 i 个放的是 歌j 那么在第 i+1 到 i+K 都不能再放 歌j 我们可以用某种支持区间修改的数据结构来维护这个信息 以此可以求得第 i 个 可以选的歌的种类有几种 (我在这里用的是树状数组, 其实数据范围支持暴力求解) 再根据排列组合,就可以求出总的方案数 还有几个限制条件就是 N 首歌必须都 至少放一遍 此时方案是包括 N, N-1, N-2…等只要 K 能满足的情况 所以方案数还要减去没放完 N 首的 我们可以按照上述方法求出 N-1 首歌时的方案 那么求出来的就包括了 N-1, N-2, N-3 … 首歌的情况,减去即可 然后还有根据排列组合,我们求的 N-1 首歌的情况 那么这 N-1 首歌又是哪 N-1 首? —— $C_N^{N-1}$ 此时看运行 示例4 就会发现错了 错误原因是加上排列之后有重复的情况 假如 3 选 2,有 (1, 2), (2, 3), (1, 3) 那么 (1, 2) 包括了 (1, 2), (1), (2) (2, 3) 包括了 (2, 3), (2), (3) 发现了吗,多减了一部分 (2) 这个就是传说中的容斥原理 假设 $f[i]$ 是我们用上述方法求出的 i 首歌(包含 i-1, i-2…) 的方案数 那么综合容斥原理最后结果就是 $C_N^0\\times f[N] - C_N^1\\times f[N-1] + C_N^2\\times f[N-2] …$ 最后的范围, 一定是要歌的数量满足 K 的间隔还能放的 $= \\sum\\limits_{i=N}^{K+1} (C_N^i \\times f[i])$ ——(额这个 -1 懒得推) $= \\sum\\limits_{i=0}^{N-i &gt; K} (-1)^{i} \\times (C_N^{N-i} \\times f[N-i])$ 复杂度分析 区间修改 暴力 $O(N^2)$ 树状数组 $O(N \\log N)$ 排列组合 暴力 ,每遍都是 $O(N)$, 总的 $O(N^2)$ 数据太大还需要乘法逆元 观察发现所求的排列组合都是 $C_N^i$ 所以可以递推, 总的复杂度 $O(N)$ 容斥原理 上述分析的是计算一遍 $f[i]$ 的复杂度 现在乘上 $N$ 最后在大环境中, 发现瓶颈是在区间修改上(所以说排列组合…) 暴力 $O(N^3)$ , 优化 $O(N^2 \\log N)$ 代码暴力求排列组合,代码冗长class Solution { public: const int MOD = 1e9+7; int tr[107] = {0}; inline void add(int i, int x, int n) { for( ; i &lt;= n; i += i&amp;-i) tr[i] += x; } inline int query(int i) { int res = 0; for( ; i; i -= i&amp;-i) res += tr[i]; return res; } inline long long calc(int N, int L, int K) { memset(tr, 0, sizeof tr); long long res = 1; for(int i = 1, cur; i &lt;= L; ++i) { cur = N+query(i); if(cur &lt;= 0) return 0; res = res*cur%MOD; add(i+1, -1, L); add(i+K+1, 1, L); } return res; } inline long long qpow(long long a, int p) { long long res = 1; while(p) { if(p&amp;1) res = res*a%MOD; p &gt;&gt;= 1; a = a*a%MOD; } return res; } inline long long mul_reverse(long long x) { return qpow(x, MOD-2); } inline long long C(int p, int q) // C_p^q { if(q == p || q == 0) return 1; if(q == p-1 || q == 1) return p; long long P = 1, Q = 1; for(int i = 1; i &lt;= q; ++i) { P = P*(p-i+1)%MOD; Q = Q*i%MOD; } return P*mul_reverse(Q)%MOD; } int numMusicPlaylists(int N, int L, int K) { long long res = 0; for(int i = 0; N-i &gt; K; ++i) res = (res+(i&amp;1 ? -1 : 1)*C(N, N-i)*calc(N-i, L, K)%MOD+MOD)%MOD; return res; } }; 递推排列组合class Solution { public: const int MOD = 1e9+7; int tr[107] = {0}; long long C[107] = {0}, inv[107] = {0}; inline void add(int i, int x, int n) { for( ; i &lt;= n; i += i&amp;-i) tr[i] += x; } inline int query(int i) { int res = 0; for( ; i; i -= i&amp;-i) res += tr[i]; return res; } inline long long calc(int N, int L, int K) { memset(tr, 0, sizeof tr); long long res = 1; for(int i = 1, cur; i &lt;= L; ++i) { cur = N+query(i); if(cur &lt;= 0) return 0; res = res*cur%MOD; add(i+1, -1, L); add(i+K+1, 1, L); } return res; } inline void init(int N) { inv[1] = 1; for(int i = 2; i &lt; N; ++i) inv[i] = (MOD-MOD/i)*inv[MOD%i]%MOD; C[0] = C[N] = 1; for(int i = 1; i &lt; N; ++i) C[i] = C[N-i] = C[i-1]*(N-i+1)%MOD*inv[i]%MOD; } int numMusicPlaylists(int N, int L, int K) { init(N); long long res = 0; for(int i = 0; N-i &gt; K; ++i) res = (res+(i&amp;1 ? -1 : 1)*C[N-i]*calc(N-i, L, K)%MOD+MOD)%MOD; return res; } }; 大佬的想法每每看到大佬们的代码都要忍不住落泪了 他们都是用 DP 写的 $O(n^2)$ $dp[i][j]$ 表示用 j 种歌, 一共放了 i 首长度的方案数 初始条件 $dp[0][0] = 1$ 转移方程 $dp[i][j] += (N-j+1)\\times dp[i-1][j-1]$ 第 i 首放一首新的歌曲 (之前没放过) 那么这首新歌有 (N-j+1) 种选择 $dp[i][j] += max(j-K, 0) \\times dp[i-1][j]$ 如果第 i 首放的是老歌 (之前放过的) 但能不能放是个问题, 问题在于前面放过的歌有没有 K 冷却了 此时之前放过的 j 首歌中 第 i-1 首放的到第 i-K 首放的 还在冷却 所以此时有 j-K 种选择 大佬的代码让我陶醉class Solution { public: const int MOD = 1e9+7; long long dp[107][107]; int numMusicPlaylists(int N, int L, int K) { memset(dp, 0, sizeof dp); dp[0][0] = 1; for(int i = 1; i &lt;= L; ++i) for(int j = 1; j &lt;= N; ++j) dp[i][j] = ((N-j+1)*dp[i-1][j-1]%MOD + dp[i-1][j]*max(j-K, 0))%MOD; return dp[L][N]; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://kaizynx.github.io/tags/乘法逆元/"},{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://kaizynx.github.io/tags/容斥原理/"}],"keywords":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}]},{"title":"Scarlet的字符串不可能这么可爱","slug":"Luogu-T48749","date":"2018-10-07T13:10:00.000Z","updated":"2022-04-10T07:52:45.145Z","comments":true,"path":"2018/10/07/Luogu-T48749/","link":"","permalink":"http://kaizynx.github.io/2018/10/07/Luogu-T48749/","excerpt":"","text":"Luogu T48749 [1007]Scarlet的字符串不可能这么可爱来自比赛【LGR-053】洛谷10月月赛I 的 B 题 思路直接讲正解了 当一个字符串是回文字符串, 有两类情况 偶数回文字符串 奇数回文字符串 都是从中间开始对称 如果是暴力的找回文串算法 一定是以一个点为中心,往两边找,知道找到两边不相同的为止 那么首要条件是最开始对称的两个要相同 如果最中心的两个都不相同,那么后面再怎么回文也不是了 我们要做的就是扼杀在摇篮 要求 没有任何一个长度超过1的回文连续子串 偶数回文字符串 任意相邻两个不得相同 奇数回文字符串 任意三个连续的字符 $c_1, c_2, c_3$ 满足 $c_1 \\neq c_3$ 显然按上述条件扼杀掉萌芽之后就不会产生回文串 这样我们就可以求得总的方案数 假设没有任何约束条件,求 k 种字符构成,长度为 L 的 没有任何一个长度超过1的回文连续子串 的个数 (此处排列组合知识,类似全排列) 如果从头到尾开始构造 $c_1$ 有 k 种选择 $c_2$, 因为 $c_2 \\neq c_1$, 所以有 k-1 种选择 $c_3$, 因为 $c_3 \\neq c_2$ 且 $c_3 \\neq c_1$, 所以有 k-2 种选择 $c_4$, 因为 $c_4 \\neq c_3$ 且 $c_4 \\neq c_2$, 所以有 k-2 种选择 … $c_L$ 有 k-2 种 最后结果就是 $k\\times (k-1) \\times (k-2)^{L-2}$ 注意特判 $L \\geq 2$ 上面的就是核心的思路了, 知道上面的加上一点暴力就可以 80 了(哈哈哈) 好吧好吧我们考虑剩下的 20 分 当给你一个限制条件: s 位上必须是 w 由上面知道 w 具体是什么其实并没有什么关系 既然 s 位已经决定了, s 位会影响到 s-2, s-1, s+1, s+2 位上的选择数 所以我们不妨从 s 位开始从左往右找方案 先从 s 开始往左 s-1 位有 k-1 种 s-2 位有 k-2 种 s-3 位有 k-2 种 … 1 位有 k-2 种 共有 $(k-1)\\times (k-2)^{s-2}$ 这里也需要特判 $s \\geq 2$ 再从 s 开始往右 s+1 位受到 s-1(我们先找了左边) 和 s 位影响, 有 k-1 种 s+2 位有 k-2 种 s+3 位有 k-2 种 … L 位有 k-2 种 共有 $(k-2)^{L-s}$ 这里也需要特判 $L-s \\geq 0$ 最后还有特判+快速幂 代码#include &lt;bits/stdc++.h&gt; using namespace std; long long k, L, s, w, p, ans; inline long long qpow(long long a, long long x) { long long res = 1; while(x) { if(x&amp;1) res = res*a%p; x &gt;&gt;= 1; a = a*a%p; } return res; } int main() { cin &gt;&gt; k &gt;&gt; L &gt;&gt; p &gt;&gt; s; long long k_1 = (k-1)%p, k_2 = (k-2)%p; k %= p; if(s) { cin &gt;&gt; w; if(L == 1) ans = 1; else if(s == 1 || s == L) ans = k_1*qpow(k_2, L-2)%p; else { ans = k_1*qpow(k_2, s-2)%p; // left ans = ans*qpow(k_2, L-s)%p; // right } cout &lt;&lt; ans &lt;&lt; endl; } else { if(L == 1) ans = k; else ans = k*k_1%p*qpow(k_2, L-2)%p; cout &lt;&lt; ans &lt;&lt; endl; } return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"快速幂","slug":"快速幂","permalink":"http://kaizynx.github.io/tags/快速幂/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"帕秋莉的手环","slug":"Luogu-P4910","date":"2018-10-07T09:30:00.000Z","updated":"2022-04-10T07:52:45.140Z","comments":true,"path":"2018/10/07/Luogu-P4910/","link":"","permalink":"http://kaizynx.github.io/2018/10/07/Luogu-P4910/","excerpt":"","text":"Luogu P4910 帕秋莉的手环来自比赛东方国庆大赛 A 题 推荐某人的题解 思路大致题目所求的就是 黑白相间的珠子环 其中把白色当成间隔的话, 间隔的连续白色的数目不得超过2 (虽然题目没看出这个关系,但是根据样例可以得出) 我们不妨设白色状态为 0, 黑色状态为 1 忽略中间想了很久的过程 如果按线性递推的来 当前如果是白色, 那么前一个必定是heise 当前的如果是黑色, 那么前一个可以是黑色,也可以是白色 我们设 $f[i][0]$ 是第 i 个珠子为白色的方案数 $f[i][1]$ 是第 i 个珠子为黑色的方案数 那么 $f[i][0] = f[i-1][1]$ $f[i][1] = f[i-1][0]+f[i-1][1]$ 最后我们还得考虑环的情况 也就是首尾的情况 显然如果首尾都是白色, 是不可行的 那么我们就在 $f[n][0]+f[n][1]$ 的基础上减去首尾是白色的方案 如果按照递推的做法,出现首尾是白色的情况必定是当第二个和倒数第二个是黑的 那么除去首尾和第二倒数第二的 剩下 n-4 个满足要求的方案 此时不用再考虑这 n-4 个首尾是否为白色 就是 $f[n-4][0]+f[n-4][1]$ 最终结果就是 $f[n][0]+f[n][1]-f[n-4][0]-f[n-4][1]$ 如果你稍稍观察或手玩一下数据就会发现 这个是斐波那契数列 $i$ 1 2 3 4 5 $f[i][0]$ 1 1 2 3 5 $f[i][1]$ 1 2 3 5 8 sum 2 3 5 8 13 ans 1 3 4 7 11 所以结果是 $Fibo(n+2)-Fibo(n-2)$ 简单的斐波那契可以线性推导 我是记得有一个通项公式 $a_n = 1/\\sqrt{5}[\\frac{(1+\\sqrt{5})^n}{2}+\\frac{(1-\\sqrt{5})^n}{2}]$ 但是这个根号…处理不了 就是忘记了斐波那契还可以用矩阵快速幂算 还有前几个数据就特判吧 代码暴力 $O(n)$ #include &lt;bits/stdc++.h&gt; using namespace std; const int Maxn = 1e6+7; const int MOD = 1e9+7; int T, n; int f[Maxn]; inline void init() { f[0] = f[1] = 1; for(int i = 2; i &lt; Maxn; ++i) f[i] = (f[i-1]+f[i-2])%MOD; } int main() { init(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d&quot;, &amp;n); if(n == 1) puts(&quot;1&quot;); else if(n == 2) puts(&quot;3&quot;); else if(n == 3) puts(&quot;4&quot;); else if(n == 4) puts(&quot;7&quot;); else printf(&quot;%d\\n&quot;, (f[n+1]-f[n-3]+MOD)%MOD); } return 0; } 矩阵快速幂 $O(\\log n)$ #include &lt;bits/stdc++.h&gt; using namespace std; const int MOD = 1e9+7; int T; long long n; struct Match { long long m[3][3]; Match(){ memset(m, 0, sizeof m); } inline void init() { m[1][1] = m[2][2] = 1; m[1][2] = m[2][1] = 0; } inline void Fibo_init() { m[2][2] = 0; m[1][1] = m[1][2] = m[2][1] = 1; } Match operator * (const Match &amp;b) const { Match res; for(int i = 1; i &lt;= 2; ++i) for(int j = 1; j &lt;= 2; ++j) { long long &amp;cur = res.m[i][j]; for(int k = 1; k &lt;= 2; ++k) cur = (cur+m[i][k]*b.m[k][j])%MOD; } return res; } } a; inline Match qpow(Match a, long long p) { Match res; res.init(); while(p) { if(p&amp;1) res = res*a; p &gt;&gt;= 1; a = a*a; } return res; } inline int Fibo(long long x) { a.Fibo_init(); a = qpow(a, x); return (int)a.m[1][2]; } int main() { scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%lld&quot;, &amp;n); if(n == 1) puts(&quot;1&quot;); else if(n == 2) puts(&quot;3&quot;); else printf(&quot;%d\\n&quot;, (Fibo(n+2)-Fibo(n-2)+MOD)%MOD); } return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"斐波那契","slug":"斐波那契","permalink":"http://kaizynx.github.io/tags/斐波那契/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://kaizynx.github.io/tags/矩阵快速幂/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"情侣？给我烧了！","slug":"Luogu-T44341","date":"2018-10-06T09:30:00.000Z","updated":"2022-04-10T07:52:45.143Z","comments":true,"path":"2018/10/06/Luogu-T44341/","link":"","permalink":"http://kaizynx.github.io/2018/10/06/Luogu-T44341/","excerpt":"","text":"Luogu T44341 情侣？给我烧了！来自比赛迷途の家の水题大赛 B 题 思路假设 $i$ 对情侣两两互不配对的方案数是 $f[i]$ 那么当有 $k$ 对情侣配对的方案数是 选择 $k$ 对情侣 $C_n^k$ 选择 $k$ 个座位并可以按照任意顺序坐 $A_n^k$ 每对情侣两个人可以交换位置,共 $2^k$ 剩下的 $n-k$ 对情侣不能有坐在一起的 $f[n-k]$ 最终结果就是 $2^k \\times C_n^k \\times A_n^k \\times f[n-k]$ 之后的问题就是求解 $f[n-k]$ 正着推有点复杂 我推不出来 所以不妨逆着想 $f[i]$ 就是 $i$ 对人的所有排列减去 有任意对数情侣配对的 所以就可以得到一个递推式 注意此时所有人的排列是 $i$ 对人, 共 $2i$ 个人 $f[i] = A_{2i}^{2i} - \\sum\\limits_{j=1}^{i} (2^j \\times C_i^j \\times A_i^j \\times f[i-j])$ 都到这个地步了 只要预处理出 $A_i^j, C_i^j, f[i], 2^i$ 即可 预处理 $A_i^j$$A_i^j = \\prod\\limits_{j=i-j+1}^{i} j$ $A_i^j = A_i^{j-1} \\times (i-j+1)$ 预处理 $C_i^j$当然你可以线性推 但是因为取模,要用到乘法逆元 这个数据范围当然可以线性逆元 最终还是 $O(n^2)$ 不过不妨采用 $C_i^j = C_{i-1}^{j-1}+C_{i-1}^j$ 预处理 $f[i]$前面预处理的范围都只是 $n$ 但是这里要用到 $A_{2i}^{2i}$, 上限在 $2n$ 扩大 $A_i^j$ 的预处理范围未免太浪费 我们只需要预处理 $A_{2i}^{2i} = (2i)!$ 剩下好说 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int Maxn = 1e3+7; const int MOD = 998244353; int T, n; long long A[Maxn][Maxn], C[Maxn][Maxn], pow2[Maxn], f[Maxn], P[Maxn&lt;&lt;1]; inline void init(); inline void read(int&amp;); void write(int); int main() { init(); read(T); while(T--) { read(n); for(int i = 0; i &lt;= n; ++i) { long long res = A[n][i]*C[n][i]%MOD*pow2[i]%MOD*f[n-i]%MOD; write((int)res); putchar(&#39;\\n&#39;); } } return 0; } inline void init() { const int N = 1e3; pow2[0] = 1; for(int i = 1; i &lt;= N; ++i) pow2[i] = (pow2[i-1]&lt;&lt;1)%MOD; // P[i] = i! P[1] = 1; for(int i = 2; i &lt;= N*2; ++i) P[i] = P[i-1]*i%MOD; for(int i = 1; i &lt;= N; ++i) { A[i][0] = 1; A[i][1] = i; for(int j = 2; j &lt;= i; ++j) A[i][j] = A[i][j-1]*(i-j+1)%MOD; } for(int i = 1; i &lt;= N; ++i) { C[i][0] = C[i][i] = 1; for(int j = 1; j &lt;= i/2; ++j) C[i][j] = C[i][i-j] = (C[i-1][j-1]+C[i-1][j])%MOD; } // i队的不配对方案数 f[0] = 1; f[1] = 0; for(int i = 2; i &lt;= N; ++i) { // 有j队匹配 for(int j = 1; j &lt;= i; ++j) f[i] = (f[i]+C[i][j]*A[i][j]%MOD*pow2[j]%MOD * f[i-j]%MOD)%MOD; f[i] = (P[i*2]-f[i]+MOD)%MOD; } } inline void read(int &amp;x) { char c; while(!isdigit((c=getchar()))); x = c-&#39;0&#39;; while(isdigit((c=getchar()))) x = (x&lt;&lt;1)+(x&lt;&lt;3) + c-&#39;0&#39;; } void write(int x) { if(x/10) write(x/10); putchar(x%10+&#39;0&#39;); }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://kaizynx.github.io/tags/乘法逆元/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"日常","slug":"Luogu-T44250","date":"2018-10-06T08:10:00.000Z","updated":"2022-04-10T07:52:45.142Z","comments":true,"path":"2018/10/06/Luogu-T44250/","link":"","permalink":"http://kaizynx.github.io/2018/10/06/Luogu-T44250/","excerpt":"","text":"Luogu T44250 日常来自比赛 你的名字。 信息学奥林匹克 B题 本题官方题解 思路题目指向很明确 你只是需要点亮技能树而已 我们核心要求得是 n 个数中 k 个数错排的方案数 显然就是 从 n 个数中选出 k 个来错排 假设 $sf[k]$ 是 k 个数错排的方案数 那么结果就是 $C_n^{k} \\times sf[k]$ 排列组合的公式不必多说 但是直接求得复杂度达到 $O(n^2)$ 排列组合优化 参考P3811 【模板】乘法逆元 题解 我们可以用前缀和处理出 $s[k] = k!$ $C_n^k = \\frac{n!}{k! \\times (n-k)!}$ $C_n^i = s[i] \\times s[k]^{-1} \\times s[n-k]^{-1}$ (乘法逆元) 复杂度取决于你求乘法逆元的方法 费马小定理 $O(n \\log n)$ 解不定方程 欧几里得 不明… 观察发现我们要求得排列组合下标都是 $n$ 那么只要求出 $C_n^{i} ,i \\in (0, n)$ 那么我们可以采用另一种线性做法 $C_n^{k-1} = \\frac{n!}{(k-1)! \\times (n-k+1)!}$ $C_n^k = \\frac{n!}{k! \\times (n-k)!}$ 所以 $C_n^k = C_n^{k+1} \\times \\frac{n-k+1}{k}$ 进而再用乘法逆元 $C_n^k = C_n^{k+1} \\times (n-k+1) \\times k^{-1}$ 这时候需要的乘法逆元范围就是 $(1, n)$ 所以可以采用线性递推的方法求乘法逆元 最终复杂度优化为 $O(n)$ ps:乘法逆元线性递推有点迷啊 错排不知道的可以参考资料洛谷日报 #52 [Planet6174]小学生都能看懂的错排问题解析 我们可以考虑错排的递推公式 $sf[k] = (k-1) \\times (sf[k-1] + sf[k-2])$ 线性可求得 代码加入了快读快写优化,因而显得冗长 #include &lt;bits/stdc++.h&gt; using namespace std; const int Maxn = 1e6+7; const int MOD = 993244853; int n, ansi; long long C[Maxn], inv[Maxn], sf[Maxn], ansv; template &lt;typename T&gt; inline void read(T &amp;); void write(int); inline void init() { sf[0] = 1; sf[1] = 0; sf[2] = 1; for(int i = 3; i &lt;= n; ++i) sf[i] = (sf[i-1]+sf[i-2])%MOD*(i-1)%MOD; inv[1] = 1; for(int i = 2; i &lt;= n; ++i) inv[i]= (MOD-MOD/i)*inv[MOD%i]%MOD; C[0] = 1; for(int i = 1; i &lt;= n; ++i) C[i] = C[i-1]*(n-i+1)%MOD*inv[i]%MOD; } int main() { read(n); init(); for(int i = 0, c; i &lt;= n; ++i) { read(c); long long cur = sf[i]*C[i]%MOD*c%MOD; if(cur &gt; ansv) { ansi = i; ansv = cur; } } write((int)ansv); putchar(&#39;\\n&#39;); for(int i = 1; i &lt;= n-ansi; ++i) write(i), putchar(&#39; &#39;); for(int i = n-ansi+1, flag = 1; i &lt;= n-3*(ansi&amp;1); ++i, flag = -flag) write(i+flag), putchar(&#39; &#39;); if(ansi&amp;1) { write(n-1); putchar(&#39; &#39;); write(n); putchar(&#39; &#39;); write(n-2); } putchar(&#39;\\n&#39;); return 0; } template &lt;typename T&gt; inline void read(T &amp;x) { char c; T tag = 1; while(!isdigit((c=getchar()))) if(c == &#39;-&#39;) tag = -1; x = c-&#39;0&#39;; while(isdigit((c=getchar()))) x = (x&lt;&lt;1)+(x&lt;&lt;3) + c-&#39;0&#39;; x *= tag; } void write(int x) { if(x&gt;9) write(x/10); putchar(x%10+&#39;0&#39;); }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://kaizynx.github.io/tags/乘法逆元/"},{"name":"错排","slug":"错排","permalink":"http://kaizynx.github.io/tags/错排/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"Portal1","slug":"Luogu-U41569","date":"2018-10-05T06:00:00.000Z","updated":"2022-04-10T07:52:45.146Z","comments":true,"path":"2018/10/05/Luogu-U41569/","link":"","permalink":"http://kaizynx.github.io/2018/10/05/Luogu-U41569/","excerpt":"","text":"Luogu U41568 Portal1来自比赛 NOIP提高组模拟赛Day1 B题 思路大背景应该是背包问题 再加上各色各样的限制条件还要输出路径 我们假设 dp[k] 表示在时间 k 可以得到的最大资源 对于某个物品 i , 在 D[i] 时刻就不能用了 所以状态更新的范围,也就是时间 t 的范围是 [1, D[i]-1] 由背包问题可以显然得出 dp[i] = max(dp[i], dp[i-T[i]]+C[i] 只不过多了个条件 D[i] 嘛 至于顺序嘛(题目错了,不是按照编号,是按照Hack的顺序) 显然按照 D[i] 从小到大输出 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int Maxn = 107; const int Maxt = 25; const int Maxd = 2e3+7; int n, D, cnt; int dp[Maxd], rk[Maxn], res[Maxn]; bitset&lt;Maxn&gt; choose[Maxd]; struct Portal { int t, d, c, id; bool operator &lt; (const Portal &amp;b) const { return d &lt; b.d; } } a[Maxn]; bool cmp(int x, int y) { return rk[x] &lt; rk[y]; } int main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;a[i].t, &amp;a[i].d, &amp;a[i].c); a[i].id = i; D = max(D, a[i].d); } sort(a+1, a+n+1); for(int i = 1; i &lt;= n; ++i) { rk[a[i].id] = i; // the time finish it for(int j = a[i].d-1; j &gt;= a[i].t; --j) { // dp[j] = max(dp[j], dp[j-a[i].t]+a[i].c); int tmp = dp[j-a[i].t]+a[i].c; if(tmp &gt; dp[j]) { dp[j] = tmp; choose[j] = choose[j-a[i].t]; choose[j][a[i].id] = 1; } } } int ans = 0; for(int i = 1; i &lt; D; ++i) if(dp[ans] &lt; dp[i]) ans = i; printf(&quot;%d\\n%d\\n&quot;, dp[ans], choose[ans].count()); if(choose[ans].count() == 0) return 0; for(int i = 1; i &lt;= n; ++i) if(choose[ans][i]) res[++cnt] = i; sort(res+1, res+cnt+1, cmp); for(int i = 1; i &lt; cnt; ++i) printf(&quot;%d &quot;, res[i]); printf(&quot;%d\\n&quot;, res[cnt]); return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"},{"name":"背包","slug":"背包","permalink":"http://kaizynx.github.io/tags/背包/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"线索","slug":"Luogu-T44252","date":"2018-10-05T05:30:00.000Z","updated":"2022-04-10T07:52:45.143Z","comments":true,"path":"2018/10/05/Luogu-T44252/","link":"","permalink":"http://kaizynx.github.io/2018/10/05/Luogu-T44252/","excerpt":"","text":"Luogu T44252 线索来自比赛 你的名字。 信息学奥林匹克 A题 思路一道新颖的区间修改 我是用 线段树+并查集 做的 总的来说不难 核心的一点是颜色修改时 后修改的要覆盖前修改的 也就是前修改的不能覆盖后修改的 这点线段树的 lazy tag 就不太好了 处理方法是 添加一个时间标记 只有当时间大于之前的时间时才修改 至于操作2的并查集,也不难 对于某个点的操作,就等价于对该点的父亲节点的操作 总之,就是代码有点长,思考+调试 共花去1小时 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int Maxn = 1e5+7; int n, m; int fa[Maxn], sz[Maxn]; struct Color { int c, t; } a[Maxn]; struct Tree { int l, r, c, t; } tr[Maxn&lt;&lt;2]; inline int ls(int x) { return x&lt;&lt;1; } inline int rs(int x) { return x&lt;&lt;1|1; } int getf(int s) { return s == fa[s] ? s : fa[s] = getf(fa[s]); } void connect(int l, int r, int x, int t) { int fl = getf(l), fr = getf(r); if(fl != fr) { fa[fl] = fr; sz[fr] += sz[fl]; } a[fr].c = x; a[fr].t = t; } void push_down(int i) { int l = ls(i), r = rs(i); if(tr[l].t &lt; tr[i].t) { tr[l].t = tr[i].t; tr[l].c = tr[i].c; } if(tr[r].t &lt; tr[i].t) { tr[r].t = tr[i].t; tr[r].c = tr[i].c; } } void build_tree(int i, int l, int r) { tr[i].l = l; tr[i].r = r; if(l == r) return; int mid = (l+r)&gt;&gt;1; build_tree(ls(i), l, mid); build_tree(rs(i), mid+1, r); } void update_tree(int i, int l, int r, int x, int t) { if(l &lt;= tr[i].l &amp;&amp; r &gt;= tr[i].r) { tr[i].c = x; tr[i].t = t; return; } push_down(i); int mid = (tr[i].l+tr[i].r)&gt;&gt;1; if(l &lt;= mid) update_tree(ls(i), l, r, x, t); if(r &gt; mid) update_tree(rs(i), l, r, x, t); } void push_tree(int i) { if(tr[i].l == tr[i].r) { int f = getf(tr[i].l); if(tr[i].t &gt; a[f].t) { a[f].t = tr[i].t; a[f].c = tr[i].c; } return; } push_down(i); push_tree(ls(i)); push_tree(rs(i)); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); // init build_tree(1, 1, n); for(int i = 1; i &lt;= n; ++i) fa[i] = i, sz[i] = 1; for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i].c); for(int i = 1, op, l, r, x; i &lt;= m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;op, &amp;l, &amp;r, &amp;x); if(op == 1) update_tree(1, l, r, x, i); else connect(l, r, x, i); } // calc the ans push_tree(1); for(int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, a[getf(i)].c); printf(&quot;%d\\n&quot;, a[getf(n)].c); for(int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, sz[getf(i)]-1); printf(&quot;%d\\n&quot;, sz[getf(n)]-1); return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://kaizynx.github.io/tags/并查集/"},{"name":"线段树","slug":"线段树","permalink":"http://kaizynx.github.io/tags/线段树/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"Agent1","slug":"Luogu-U41568","date":"2018-10-05T05:10:00.000Z","updated":"2022-04-10T07:52:45.146Z","comments":true,"path":"2018/10/05/Luogu-U41568/","link":"","permalink":"http://kaizynx.github.io/2018/10/05/Luogu-U41568/","excerpt":"","text":"Luogu U41568 Agent1来自比赛 NOIP提高组模拟赛Day1 A题 思路因为 $\\forall A_i &lt; B_i$ 所以我们要选择 A, B 不妨在把 N 划分成左右两个部分 A 从左边选任意个($\\geq 1$) B 同上 具体做法呢,为了防止重复的东西 我们假设中间的是 $i$ 且 A 必须选 $i$ ($1 \\leq i &lt; N$) $i$ 的左边还有 i-1 个,从中选择 0~i-1个 所以 A 的方案有 $\\sum\\limits_{j=0}^{i-1} {C_{i-1}^{j}} = 2^{i-1}$ 那么考虑 B $i$ 的右边还有 n-i 个 因为 B 不为空 所以 B 的方案有 $\\sum\\limits_{j=1}^{n-i} {C_{n-i}^{j}} = 2^{n-i}-1$ 综上, 当中间的是 $i$ 时 方案有 $2^{i-1} \\times (2^{n-i}-1) = 2^{n-1}-2^{i-1}$ 最终结果为 $\\sum\\limits_{i=1}^{n-1} (2^{n-1}-2^{i-1})$ $= (n-1)\\times 2^{n-1} - \\sum\\limits_{i=1}^{n-1} 2^{i-1}$ 后面那个用等比数列的求和公式可以得到 $\\sum\\limits_{i=1}^{n-1} 2^{i-1} = 2^0 \\times \\frac{1-2^{n-1}}{1-2} = 2^{n-1}-1$ 所以最终结果为 $(n-2)\\times 2^{n-1} + 1$ 用快速幂即可求解 时间复杂度 $O(\\log n)$ 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int MOD = 1e9+7; int n; inline long long quickm(long long a, int p) { long long res = 1; while(p) { if(p&amp;1) res = res*a%MOD; p &gt;&gt;= 1; a = a*a%MOD; } return res; } int main() { cin &gt;&gt; n; cout &lt;&lt; (quickm(2, n-1)*(n-2)+1)%MOD &lt;&lt; endl; return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"快速幂","slug":"快速幂","permalink":"http://kaizynx.github.io/tags/快速幂/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"作业","slug":"Luogu-T47092","date":"2018-10-02T07:50:00.000Z","updated":"2022-04-10T07:52:45.145Z","comments":true,"path":"2018/10/02/Luogu-T47092/","link":"","permalink":"http://kaizynx.github.io/2018/10/02/Luogu-T47092/","excerpt":"","text":"Luogu T47092 作业来自比赛ARFA 教堂的第一次洗礼 思路看着数据范围,大概就是 O(2^n) 暴力枚举了 一开始就想着怎么二进制骚操作,但一些地方就是不知道怎么处理 最后还是先打了一遍暴力看看 暴力就是用 dfs 大致如下 // cur 用二进制表示当前选了哪些, last表示上一个选的 void dfs(int cur, int last) { for(int i = 0; i &lt; n; ++i) { // this one had not been chosen and satisfy the request of a[] if((cur&amp;(1&lt;&lt;i)) == 0 &amp;&amp; a[i] &gt;= a[last]) { int cnt = 0; // 处理 b[] 的条件 for(int j = last+1; j &lt; i; ++j) if((cur&amp;(1&lt;&lt;j)) == 0) ++cnt; if(cnt &gt; b[last]) continue; if(++dp[cur|(1&lt;&lt;i)] &gt;= MOD) dp[cur|(1&lt;&lt;i)] %= MOD; dfs(cur|(1&lt;&lt;i), i); } } } 上面代码中处理 b 的条件时候写错了 因为不一定 上一个选的小于现在选的 这个小错误曾困扰了我通往满分 然后事实上这样的暴力已经可以拿 70~90 分了 （我拿了70分,因为上述错误WA了2个,T了一个.但是根据作者说,他卡了3个) 再看看二进制枚举时候的难点吧 总体思路是 枚举当前做了的作业数量x 枚举做了 x 份作业的方案(究竟是哪 x 份) 找到下一份满足要求的作业,更新状态 语无伦次 看赛场上的丑陋代码 #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 19; const int MOD = 4921057; // dp[i][j] 表示状态 i(二进制)下最后一个选了 j 的方案数 int n, a[Maxn], b[Maxn], dp[1&lt;&lt;Maxn][Maxn], m[1&lt;&lt;Maxn]; int main() { // 输入 scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a+i); for(int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, b+i); // 求最大值 // 注释 ① for(int i = 1; i &lt; (1&lt;&lt;n); ++i) for(int j = 0; j &lt; n; ++j) if(i&amp;(1&lt;&lt;j)) { m[i] = max(a[j], m[i^(1&lt;&lt;j)]); break; } // 初始化,第一份作业写了啥 for(int i = 0; i &lt; n; ++i) dp[1&lt;&lt;i][i] = 1; // 枚举写了几份作业 for(int i = 1; i &lt; (1&lt;&lt;(n-1)); i = i&lt;&lt;1|1) { int cur = i, x, y; while(cur &lt; (1&lt;&lt;n)) { // 选择下一个要写的作业 for(int j = 0; j &lt; n; ++j) // 第 j 份作业没写并且满足 a[] 递增 // 因为递增,后选的 a[] 一定比之前选的都大 if(!(cur&amp;(1&lt;&lt;j)) &amp;&amp; a[j] &gt;= m[cur]) // 找当前(cur)最后一个选的 for(int k = 0; k &lt; n; ++k) // 因为递增,最后一个选的一定是当前(cur)最大的 if(cur&amp;(1&lt;&lt;k) &amp;&amp; a[k] == m[cur]) { // 判断是否满足 b[] 的要求 int cnt = 0; if(k &lt; j) for(int p = k+1; p &lt; j; ++p) { if(!(cur&amp;(1&lt;&lt;p))) ++cnt; } else for(int p = j+1; p &lt; k; ++p) { if(!(cur&amp;(1&lt;&lt;p))) ++cnt; } // 状态转移 if(cnt &lt;= b[k]) dp[cur|(1&lt;&lt;j)][j] = (dp[cur][k]+dp[cur|(1&lt;&lt;j)][j])%MOD; } // 写了这[几]份作业的下一种方案(这[几]种,那[几]种) // 注释 ② x = cur&amp;-cur; y = cur+x; cur = ((cur&amp;~y)/x&gt;&gt;1)|y; } } // 最后只要满足要求,可以是任意一个作为 最后选的 int ans = 0; for(int i = 0; i &lt; n; ++i) if(a[i] == m[(1&lt;&lt;n)-1]) ans = (ans+dp[(1&lt;&lt;n)-1][i])%MOD; printf(&quot;%d\\n&quot;, ans); return 0; } 详细的解释一下代码 注释 ① for(int i = 1; i &lt; (1&lt;&lt;n); ++i) for(int j = 0; j &lt; n; ++j) if(i&amp;(1&lt;&lt;j)) { m[i] = max(a[j], m[i^(1&lt;&lt;j)]); break; } 这里是处理最大值 因为我们排出的 a[] 是单调递增的,所以求出最大值有利于判断那个啥的 当前做了的作业是 i (二进制表示) 随便找一个做了的作业 i&amp;(1&lt;&lt;j) == 1 i^(1&lt;&lt;j) 就是去掉这份作业 (基础的二进制骚操作) 然后这个状态的最大值就是 max(a[j], i去掉j的最大值) 可以显而易证明 因为 i 是从小到大枚举的, 但 i 少了一个 1 之后的状态 一定是之前已经处理过的,所以转移没有问题 当然我现在想到一种不用那么麻烦的想法 那就是直接去掉 lowbit 这样省去了一重枚举,复杂度降低了一维 对整体复杂度还是无影响 注释 ② 这可能是最骚的操作了 二进制的一种骚操作 用来枚举集合中 选固定个数的 所有子集 借鉴自 《挑战程序设计竞赛(第二版)》 P156 专栏 集合的整数表示 枚举 集合 中所包含的所有 大小为 k 的子集 的方法 int comb = (1 &lt;&lt; k) - 1; while (comb &lt; 1 &lt;&lt; n) { int x = comb &amp; - comb, y = comb + x; comb = ((comb &amp; ~y) / x &gt;&gt; 1) | y; } 思路大致如下: 求出最低为的 1 开始的连续的 1 的区间 (0100 1110 -&gt; 0000 1110) 将这一区间全部变为 0, 并且区间左侧的那个 0 变为 1 (0100 1110 -&gt; 0101 0000) 将第(1)步里取出的区间右移, 直到剩下的 1 的个数减少了 1 个 (0000 1110 -&gt; 0000 0011) 将第(2)步和第(3)步的结果按位取或 (0101 0000 | 0000 0011 -&gt; 0101 0011) 解释代码 x = comb &amp; - comb 是 lowbit, 也就是最低位上的 1 y = comb + x 最低位加上1,最低位进位 那么假如最后是连续的1,就会一直进位,进位至末尾全部连续的1 就是将 comb 从最低为的 1 开始的连续的 1 都置 0 了 y 取反再和 comb 按位与 就得到最低为 1 开始的连续区间 / x 是个很神奇的操作 这个操作使得 y 的 1 右移到最低位 再 &gt;&gt; 1 就完成了步骤 3 然后就没然后了","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"},{"name":"位运算","slug":"位运算","permalink":"http://kaizynx.github.io/tags/位运算/"},{"name":"状压DP","slug":"状压DP","permalink":"http://kaizynx.github.io/tags/状压DP/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"矿脉开采","slug":"Luogu-T46446","date":"2018-10-01T13:46:00.000Z","updated":"2022-04-10T07:52:45.144Z","comments":true,"path":"2018/10/01/Luogu-T46446/","link":"","permalink":"http://kaizynx.github.io/2018/10/01/Luogu-T46446/","excerpt":"","text":"Luogu T46446 矿脉开采来自洛谷比赛 ETO的公开赛 的 A 题 思路看这个数据范围像暴力啊 交了个 $O(2^n)$ 的算法(难道这不是正确算法?) 妥妥 T 了一个点,故意的吧 虽然只有一个点,但是出题人恶心得设成了 这道题是“签到”题，故开启计分策略，通过所有测试点方可得分（大佬其实可以跳过） 这几分对于蒟蒻的我来说怎么放得下!!! 再看这个数据范围 46 如果减去一半,那么 $O(2^n)$ 就可以了 这个技巧还是应该有碰到过的 就是把 n 分成两份 分别进行 $O(2^n)$ 算法,再合起来 问题就在于怎么合起来了 其实就是分成两份 每一份求出可以平凑出的利润 遍历某一份中的利润 假设当前这份中有个利润为 $v_i$ 那么在另外一份中找到最大的那个 $\\leq S - v_i$ 的 这样保证两者结合最接近 $S$ 这个过程可以用排序再二分优化 所以总的复杂度就是 $O(2^{\\frac{N}{2}} \\log 2^{\\frac{N}{2}})$ 还有一个优化就是 过程中出现 $\\geq S$ 的值直接舍去 代码`cpp #include &lt;bits/stdc++.h&gt; using namespace std; const int Maxn = 50;const int Maxm = (1&lt;&lt;23)+1; int n, tot;long long S, a[Maxn], ans;long long b[2][Maxm]; void solve(int cur, int tail, long long sum, long long *arr){ if(sum == S) { cout &lt;&lt; S &lt;&lt; endl; exit(0); } if(cur &gt; tail) { ans = max(ans, sum); return; } if(sum+a[cur] &lt;= S) { arr[++arr[0]] = sum+a[cur]; solve(cur+1, tail, sum+a[cur], arr); } solve(cur+1, tail, sum, arr);} int main(){ cin &gt;&gt; S &gt;&gt; n; for(int i = 1, v, w; i &lt;= n; ++i) { cin &gt;&gt; w &gt;&gt; v; a[++tot] = w; for(int i = 2; i &lt;= v; ++i) a[tot] *= w; if(a[tot] &gt; S) tot–; if(a[tot] == S) { cout &lt;&lt; S &lt;&lt; endl; return 0; } } solve(1, tot/2, 0, b[0]); solve(tot/2+1, tot, 0, b[1]); if(!b[0][0] || !b[1][0]) { cout &lt;&lt; ans &lt;&lt; endl; return 0; } sort(b[0]+1, b[0]+b[0][0]+1); sort(b[1]+1, b[1]+b[1][0]+1); b[0][0] = unique(b[0]+1, b[0]+b[0][0]+1)-(b[0]+1); b[1][0] = unique(b[1]+1, b[1]+b[1][0]+1)-(b[1]+1); for(int i = 1; i &lt;= b[0][0]; ++i) { // b[1][pos] &gt; S-b[0][i] // b[1][pos-1] &lt;= S-b[0][i] // b[0][i]+b[1][pos-1] &lt;= S int pos = upper_bound(b[1]+1, b[1]+b[1][0]+1, S-b[0][i])-b[1]; if(pos &gt; 1) ans = max(ans, b[0][i]+b[1][pos-1]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}`cpp","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"暴力优化","slug":"暴力优化","permalink":"http://kaizynx.github.io/tags/暴力优化/"},{"name":"搜索","slug":"搜索","permalink":"http://kaizynx.github.io/tags/搜索/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"评论开通","slug":"notice001","date":"2018-10-01T08:36:00.000Z","updated":"2022-04-10T07:52:45.153Z","comments":true,"path":"2018/10/01/notice001/","link":"","permalink":"http://kaizynx.github.io/2018/10/01/notice001/","excerpt":"评论系统今日起开通 Powered By Valine v1.3.3 头像由 Gravatar 全球公认的头像 提供","text":"评论系统今日起开通 Powered By Valine v1.3.3 头像由 Gravatar 全球公认的头像 提供 默认头像就是 Gravatar (蓝色背景加一个大写的 G ) 如果需要个性头像,需要在 Gravatar 邮箱注册并上传头像 评论的时候只需写明邮箱地址,即可显示头像 至于昵称,可以随意填写,对头像无影响 默认的昵称是 Anonymous (匿名) 当然我希望你尽量不要匿名 至于网址属性…也不知道是干什么用的 祝大家玩得开心,过的愉快","categories":[{"name":"System","slug":"System","permalink":"http://kaizynx.github.io/categories/System/"}],"tags":[],"keywords":[{"name":"System","slug":"System","permalink":"http://kaizynx.github.io/categories/System/"}]},{"title":"Plasticine zebra","slug":"Codeforces1025C","date":"2018-09-30T05:35:00.000Z","updated":"2022-04-10T07:52:45.126Z","comments":true,"path":"2018/09/30/Codeforces1025C/","link":"","permalink":"http://kaizynx.github.io/2018/09/30/Codeforces1025C/","excerpt":"","text":"CodeForces 1025C Plasticine zebra题意有一个由 $b,w$ 组成的串 可以进行 0 或任意次这样的操作: 从某个地方开始把串分成两部分 再把每一部分各自翻转 如 bwbbw -&gt; bw|bbw -&gt; wb|wbb -&gt; wbwbb 使得最后串中 $wbwbwbwb$ 这样 $bw$ 交替的串的长度最大 样例输入bwwwbwwbw 输出5 说明bwwwbww|bw→w|wbwwwbwb→wbwbwwwbw 加粗部分长度为 5 思路一开始觉得要DP吧 反正就是写不来 下面翻译自题解 假如我们把这个串看成一个环 那么一次操作类似下面 对整个环不造成影响 再把环展开的话 其实就相当于换了端点 那么问题就是从这个环上哪个点开始 符合要求的串最长 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; int ans = 1; string str; int main() { cin &gt;&gt; str; str += str; for(int i = 1, cnt = 1; i &lt; str.length(); ++i) { if(str[i] != str[i-1]) { ans = max(ans, ++cnt); if(ans == str.length()/2) break; } else cnt = 1; } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"玄学","slug":"玄学","permalink":"http://kaizynx.github.io/tags/玄学/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"Vasya and Cornfield","slug":"CodeforcesR512div2B","date":"2018-09-30T05:20:00.000Z","updated":"2022-04-10T07:52:45.133Z","comments":true,"path":"2018/09/30/CodeforcesR512div2B/","link":"","permalink":"http://kaizynx.github.io/2018/09/30/CodeforcesR512div2B/","excerpt":"","text":"Codeforces Round 512 Vasya and Cornfield题意给 $n,d$ 以 $(0,d),(d,0),(n,n-d),(n-d,n)$ 为定点的矩形 $m$ 次询问, 每次输入 $(x_i,y_i)$ 求这个点是否在矩形内 样例输入7 2 4 2 4 4 1 6 3 4 5 输出YES NO NO YES 说明 思路暴力求解完全数学化 两点确定一条直线 所以可以求出这四条边的方程 记作ax+by-k=0 利用点到直线的距离 dis = (ax+by-k)/sqrt(a^2+b^2) 当点在矩形内的时候 点到两条宽的距离和就是长 到两条长的距离和就是宽 把握一下精度应该就可以了 代码#include &lt;bits/stdc++.h&gt; using namespace std; const double eps = 1e-5; int d, n, m; struct Line { int a, b, k; // ax+by+k = 0 inline void init(int x1, int y1, int x2, int y2) { int dx = x1-x2, dy = y1-y2; // y - y1 = (dx/dy)(x-x1) // dy*y-dy*y1 = dx*x-dx*x1 // dx*x-dy*y-dx*x1+dy*y1 = 0 a = dx; b = -dy; k = dy*y1-dx*x1; int gcd = __gcd(__gcd(a, b), k); a /= gcd; b /= gcd; k /= gcd; } inline double dis(int x, int y) { return abs((a*x+b*y+k))/sqrt(a*a+b*b); } } l[4]; inline double point_dis(int x1, int y1, int x2, int y2) { return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;d, &amp;m); l[0].init(0, d, d, 0); l[1].init(n, n-d, n-d, n); l[2].init(0, d, n-d, n); l[3].init(d, 0, n, n-d); double len01 = point_dis(0, d, n-d, n), len23 = point_dis(0, d, d, 0); while(m--) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if(abs(l[0].dis(x, y)+l[1].dis(x, y)-len01) &lt; eps &amp;&amp; abs(l[2].dis(x, y)+l[3].dis(x, y)-len23) &lt; eps) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; } 观察优化通过观察看题解发现 其实这四条边的斜率是一定的! 于是可以这么表示 紧接着用线性规划 $$\\begin{cases}x+y \\geq d \\x+y \\leq 2n-d \\x-y \\geq -d \\x-y \\leq d\\end{cases}$$ 代码#include &lt;bits/stdc++.h&gt; using namespace std; int n, d, m, x, y; int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;d, &amp;m); while(m--) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if(x+y &gt;= d &amp;&amp; x+y &lt;= 2*n-d &amp;&amp; x-y &gt;= -d &amp;&amp; x-y &lt;= d) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; }","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"几何","slug":"几何","permalink":"http://kaizynx.github.io/tags/几何/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"子序列宽度之和","slug":"LeetCode891","date":"2018-09-29T03:30:00.000Z","updated":"2022-04-10T07:52:45.135Z","comments":true,"path":"2018/09/29/LeetCode891/","link":"","permalink":"http://kaizynx.github.io/2018/09/29/LeetCode891/","excerpt":"","text":"LeetCode 891 子序列宽度之和题面给定一个整数数组 A ，考虑 A 的所有非空子序列。 对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。 返回 A 的所有子序列的宽度之和。 由于答案可能非常大，请返回答案模 10^9+7。 示例输入[2,1,3] 输出6 解释子序列为 [1]，[2]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 相应的宽度是 0，0，0，1，1，2，2 这些宽度之和是 6 数据范围1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= 20000 思路$O(n^2)$算法显然暴力枚举是不可能的,这辈子都不可能的 首先从样例可以看出,所谓的子序列是自由组合的 所以先排序一下有助于我们思考 决定一个子序列宽度的是最大值和最小值 假如我们从这个,现在排序过的序列中任意找出几个 那么起决定作用的一定是首尾两个 所以我们的取法是先取首尾 $a_l, a_r$ 再从首尾间的数字中选任意个加入序列 这些序列的宽度均为 $a_r - a_l$ 那么我们要取这对的首尾能构成几个序列 显然首尾间还有 $r-l-1$ 个元素 那么就是排列组合问题了 设 $k = r-l-1$ 结果就是 $C_k^0+C_k^1+C_k^2…+C_k^k$ $\\sum\\limits_{i=0}^{k} C_k^i = 2^k$ 所以这样的序列宽度和就是 $2^k\\times (a_r-a_l)$ 那么能够想到的就是枚举首尾求结果了 而求 $2^k$ 复杂度是 $O(k)$ 用快速幂也是 $O(\\log k)$ 直接算可能会 $O(n^2 \\log n)$ 为何不开个数组 $O(n)$ 最后复杂度是 $O(n^2)$ 还是妥妥地 TLE 虽然抱着侥幸的心理 不过 $10^4$ 这样的数据范围真不三不四的样子 $O(n^2)$代码class Solution { public: const int MOD = 1e9+7; long long pow2[20005]; int sumSubseqWidths(vector&lt;int&gt;&amp; A) { sort(A.begin(), A.end()); // init pow2[0] = 1; for(int i = 1; i &lt;= A.size(); ++i) if((pow2[i] = pow2[i-1]&lt;&lt;1) &gt; MOD) pow2[i] %= MOD; // init long long res = 0; for(int i = 0; i &lt; A.size()-1; ++i) for(int j = i+1; j &lt; A.size(); ++j) res = (res+pow2[j-i-1]*(A[j]-A[i]))%MOD; return res; } }; $O(n)$直觉说肯定能优化到 $O(n)$ 因为 $a_i$ 是不确定的 但是 $2^k$ 是确定的 于是我就看看乘以 $2^k$ 的到底是那些 假设 $a$ 有 $n$ 项 $k = 0$ $(a_n-a_{n-1})+(a_{n-1}-a_{n-2})+…+(a_3-a_2)+(a_2-a_1)$ $k = 1$ $(a_n-a_{n-2})+(a_{n-1}-a_{n-3})+…+(a_4-a_2)+(a_3-a_1)$ $k = 2$ $(a_n-a_{n-5})+(a_{n-1}-a_{n-4})+…+(a_5-a_2)+(a_4-a_1)$ …… 所以是 $2^k\\times \\sum\\limits_{i=1+(k+1)}^{n}{a_i} - \\sum\\limits_{i=1}^{n-(k+1)}{a_i}$ 显然可以用前缀和来解决 最后结果就是 $\\sum\\limits_{k=1}^{n-2}(2^k\\times \\sum\\limits_{i=k+2}^{n}{a_i} - \\sum\\limits_{i=1}^{n-k-1}{a_i})$ 空间复杂度 $O(n)$ $O(n)$代码class Solution { public: const int MOD = 1e9+7; long long s[20007]; int sumSubseqWidths(vector&lt;int&gt;&amp; A) { sort(A.begin(), A.end()); int n = A.size(); long long pow2 = 1, res = 0; for(int i = 1; i &lt;= n; ++i) s[i] = s[i-1]+A[i-1]; for(int i = 0; i &lt;= n-2; ++i) { res = (res+(s[n]-s[i+1]-s[n-i-1])%MOD*pow2)%MOD; pow2 = (pow2&lt;&lt;1)%MOD; } return res; } }; 官方算法这是官方的答案 大致是 $\\sum a_r-\\sum a_l$ 定下来的是 $a_i$, 找它应该是加上或减去 2 的几次方 官方题解链接 最后结果是 $\\sum\\limits_{i=0}^{n-1}(2^i-2^{N-i-1})\\times a_i$ 如果牺牲空间换时间​,预处理 $2^k$ 时间复杂度 $O(n)$ 空间复杂度 $O(n)$ 如果牺牲时间换空间​,快速幂求 $2^k$ 时间复杂度 $O(n\\log n)$ 空间复杂度 $O(1)$ 官方没有C++代码// java class Solution { public int sumSubseqWidths(int[] A) { int MOD = 1_000_000_007; int N = A.length; Arrays.sort(A); long[] pow2 = new long[N]; pow2[0] = 1; for (int i = 1; i &lt; N; ++i) pow2[i] = pow2[i-1] * 2 % MOD; long ans = 0; for (int i = 0; i &lt; N; ++i) ans = (ans + (pow2[i] - pow2[N-1-i]) * A[i]) % MOD; return (int) ans; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}]},{"title":"创意吃鱼法","slug":"Luogu-P1736","date":"2018-09-27T13:05:00.000Z","updated":"2022-04-10T07:52:45.138Z","comments":true,"path":"2018/09/27/Luogu-P1736/","link":"","permalink":"http://kaizynx.github.io/2018/09/27/Luogu-P1736/","excerpt":"","text":"Luogu P1736 创意吃鱼法题意给出 n 列 m 行的 01 矩阵 求某一个正方形子矩阵 除了某条对角线是 1 其余都是 0 这个 1 的长度最大是多少 数据范围$n,m \\leq 2500$ 样例输入4 6 0 1 0 1 0 0 0 0 1 0 1 0 1 1 0 0 0 1 0 1 1 0 1 0 输出3 说明右上角 (1,4) 到 (3,6) 1 0 0 0 1 0 0 0 1 思路既然是DP题嘛(提前知道) 想想状态转移方程 对角线无非两种 1 0 0 0 1 0 0 0 1 0 0 1 0 1 0 1 0 0 设 $f[i][j]$ 是以 (i, j) 为右下角的矩阵的最大长度 那么 第一种 if(条件成立) f[i][j] = f[i-1][j-1]+1 第二种 if(条件成立) f[i][j] = f[i+1][j-1]+1 我们看条件,是这个矩阵其他地方都是 0 当状态转移时,我们只需要考虑矩阵新加的那部分 举第一种的栗子 如图所示绿色部分即为新增加的 怎么判断绿色部分全是 0 呢 只要绿色区间和为 0 即可 这里有两种方案 用一维前缀和 绿色区间 1 用记录每一列的前缀和 $sv[][]$ 绿色区间 2 用记录每一行的前缀和 $st[][]$ 对于第一种的情况实现代码大致如下 int tmp = f[i-1][j-1][0]; if(st[i][j-1]-st[i][j-tmp-1] == 0 &amp;&amp; sv[i-1][j]-sv[i-tmp-1][j] == 0) f[i][j][0] = tmp+1; 用二维前缀和 问题等价于当前这个矩阵 也就是上图整个矩阵内的 1 的个数恰好等于对角线长度 用 $s[i][j]$ 表示以 (0,0) 到 (i,j) 的矩阵区间和 那么以 (x,y) 为右下角,对角线长为 l 的矩阵的和就是 s[x][y]-s[x-l][y]-s[x][y-l]+s[x-l][y-l] 成立条件就是 s[x][y]-s[x-l][y]-s[x][y-l]+s[x-l][y-l] == l 复杂度 $O(n^2)$ 想到这里,我不禁狂笑一声,交了个 WA $O(n^2 \\log n)$算法当你遇到这种情况 如果按上述情况来 处理到 3 的时候 无法满足条件,此时的值变为 1 继而 4 的值是 2 但事实呢 发现 3 的值即使无法达到 3, 但还是可以达到 2 于是怎么办呢… 二分找到一个长度使得满足条件啊 这样复杂度就是 $O(n^2 \\log n)$ 最坏情况 $\\log n \\approx 10$ 但是除非特殊构造的图(只有对角线) 才可能到达这样的复杂度 而且当 当前格子上没有东西时是不进行计算的 所以可以显然得出这个多出来的 $\\log n$ 可以忽略不计 再者教科书上一秒 $10^6$ 已经过时了 所以盲目分析得到复杂度为 $O(kn^2),(k &lt;&lt; 10)$ 再来考虑是基于上述方案一还是方案二 如果是方案一 二分长度后 分别计算两个绿色部分是否满足 那如果是方案二呢 二分长度后 计算这样大小的正方形矩阵内是否只有那么多食物 代码#include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 2507; int n, m, ans; int a[Maxn][Maxn], s[Maxn][Maxn]; int f[Maxn][Maxn][2]; inline int calc(int x, int y, int l) { return s[x][y]-s[x-l][y]-s[x][y-l]+s[x-l][y-l]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) { scanf(&quot;%d&quot;, &amp;a[i][j]); s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]; } for(int j = 1, l, r, mid; j &lt;= m; ++j) { for(int i = 1; i &lt;= n; ++i) { if(a[i][j]) { l = 1; r = f[i-1][j-1][0]+1; while(l &lt; r) { mid = (l+r+1)&gt;&gt;1; if(calc(i, j, mid) == mid) l = mid; else r = mid-1; } f[i][j][0] = l; l = 1; r = f[i+1][j-1][1]+1; while(l &lt; r) { mid = (l+r+1)&gt;&gt;1; if(calc(i+mid-1, j, mid) == mid) l = mid; else r = mid-1; } f[i][j][1] = l; ans = max(ans, max(f[i][j][0], f[i][j][1])); } } } printf(&quot;%d\\n&quot;, ans); return 0; } $O(n^2)$算法我们再仔细一想看下题解 发现确实存在实打实的 $O(n^2)$ 算法 思路类比 P1387 最大正方形 再次拿出这张图 在上面我们采用的是二分答案再判断是否符合 其实我们可以预处理出 比如区间 1 最多可以满足多少 结果就是 min(区间1, 区间2, 对角线) 所谓的区间 1 最多能满足多少 其实就是 从右下角上一格(区间 1 最下端) 开始有几个连续的 0 这个很好预处理出来 由于空间限制,故没法同时进行两种对角线情况 代码如下 事实上这种算法运行起来比上面的 $O(n^2 \\log n)$ 慢 原因大概是常数比较大吧 侧面也可以说明 $O(n^2 \\log n)$ 其实远达不到上界 代码#include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 2507; int n, m, ans; int a[Maxn][Maxn], st[Maxn][Maxn], sv[Maxn][Maxn], f[Maxn][Maxn]; inline void read(int &amp;); inline int min3(int a, int b, int c) { return min(min(a, b), c); } int main() { read(n); read(m); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) { read(a[i][j]); if(a[i][j]) st[i][j] = sv[i][j] = 0; else st[i][j] = st[i][j-1]+1, sv[i][j] = sv[i-1][j]+1; } for(int j = 1; j &lt;= m; ++j) for(int i = 1; i &lt;= n; ++i) if(a[i][j]) ans = max(ans, f[i][j] = min3(f[i-1][j-1], st[i][j-1], sv[i-1][j])+1); for(int j = 1; j &lt;= m; ++j) for(int i = n; i; --i) if(a[i][j]) sv[i][j] = 0; else sv[i][j] = sv[i+1][j]+1; for(int j = 1; j &lt;= m; ++j) for(int i = 1; i &lt;= n; ++i) if(a[i][j]) ans = max(ans, f[i][j] = min3(f[i+1][j-1], st[i][j-1], sv[i+1][j])+1); printf(&quot;%d\\n&quot;, ans); return 0; } inline void read(int &amp;x) { char c; while((c=getchar()) &lt; &#39;0&#39; || c &gt; &#39;9&#39;); x = c-&#39;0&#39;; while((c=getchar()) &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) x = (x&lt;&lt;3)+(x&lt;&lt;1) + c-&#39;0&#39;; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://kaizynx.github.io/tags/二分/"},{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"},{"name":"前缀和","slug":"前缀和","permalink":"http://kaizynx.github.io/tags/前缀和/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"珈百璃堕落的开始","slug":"Luogu-P4832","date":"2018-09-25T13:10:00.000Z","updated":"2022-04-10T07:52:45.139Z","comments":true,"path":"2018/09/25/Luogu-P4832/","link":"","permalink":"http://kaizynx.github.io/2018/09/25/Luogu-P4832/","excerpt":"","text":"P4832 珈百璃堕落的开始题意给出 $n$ 个由 $s,+,c$ 组成式子 表示 $\\sin^2(x)$ 和 $\\cos^2(x)$ 的和 其中 $x = \\frac{\\pi}{7}$ 选择其中任意几个式子,使和恰好为整数 求最大整数 样例输入3 s+c s+c+s c 输出3 解释三个式子全部加起来为 3 数据范围$nm \\leq 5\\times 10^7$ $m \\leq 10^6$ 思路建议在做此题前完成以下两题 P2170 选学霸 P1282 多米诺骨牌 这三题的核心的DP思路类似,难度递增 首先肯定是字符串处理,处理成 $s$ 和 $c$ 的个数 继而我们知道 $\\sin^2(x) +\\cos^2(x) = 1$ 那么就是求某些式子的和 $s$ 的个数恰好等于 $c$ ,且最多 这里穿插一句,我想当然是这样,不过题解给出了严谨证明,如下: 证明 $\\sin^2(x),\\cos^2(x),(x=\\frac{\\pi}{7})$ 是无理数 设 $\\cos(x) = A$ 则 $\\cos(2x) = 2A^2-1$ 则 $\\cos(2x) = 8A^4-8A^2+1$ 又 $\\cos(3x)=4A^3-3A$ 所以 $\\cos(3x)+\\cos(4x)=0$ 所以 $8A^4+4A^3-8A^2-3A+1=0$ 下面那句没懂 根据整系数方程有理根判定定理，该方程没有理根 所以 $\\cos^2(x)(x=\\frac{\\pi}{7}$ 是无理数 同理 $\\sin^2(x)(x=\\frac{\\pi}{7}$ 是无理数 证毕 算了,这似乎并不是很重点 类比给出两道题的思路 我们不妨设 $s = 1, c = -1$ 每个式子就可以用数值表示 所以要找某些和为0的式子 这是前提,再是找值最大的 这个问题就像给你一些物品和一个值 $V$ 要求找一些物品使值得和接近 $V$ 就是 $abs(V-sum)$ 最小 分类讨论,一种是比 $V$ 小,接近 $V$ 另一种是比 $V$ 大,接近 $V$ 这样就有点熟悉了吧 01背包!!! 正过来的背包和反过来的背包 正着的是这样的 for(int i = 1; i &lt;= n; ++i) for(int j = V; j &gt;= minv; --j) if(j-v[i] &gt;= minv) dp[j] = max(dp[j], dp[j-v[i]]+w[i]); 反着也很容易 for(int i = 1; i &lt;= n; ++i) for(int j = V; j &lt;= maxw; ++j) if(j+v[i] &lt;= maxv) dp[j] = max(dp[j], dp[j+v[i]]+w[i]); 当然如果实在不好理解就开多维背包数组,不要搞什么骚操作 接下来先考虑怎么找到和为整数的 也就是和为0的 也就是 $V =0$ 这又需要一些技巧了 我们知道数组下标是不能为负的 那我们不妨重新定义 0 假如把 100 定为 0 那么 103 就是 3 98 就是 -2 这样负数的问题就解决了 那么此时能够找到和为整数的式子了 上述的就像是 背包只能装 $V$ 体积物品,每个物品体积 $v_i$ 求最多能装几个物品 而我们现在求的是 $V$ 的背包,每个物品有体积 $v_i$ ,价值 $w_i$ 求最大价值(加个条件背包装满) 所以我们考虑物品(式子)的状态,不仅要有体积(s,c相对个数),还要有价值 那么某个物品的价值就是 $s$ 和 $c$ 配对的个数 $w_i = \\min(s, c)$ 然后在状态转移的时候,如果有配对的,那么价值要增加 这里可以分很多类讨论… 这里简单介绍几类 $dp[j]$ 表示当前 $v=j$ 时的最大价值 (只介绍 $j &gt; 0$ 时的状况) 当前式子是 $v_i, w_i$ 显然选择这个式子的话价值会加上 $w_i$ $v_i &gt; 0$ 显然不会有增加的价值量 $v_i &lt; 0$ 就表明有 $s$ 和 $c$ 匹配了,要加上匹配来的价值 $j+v_i &gt;0$ 显然新匹配的价值量是 $-v_i$ $j+v_i &lt; 0$ 此时匹配后反而 $c$ 更多了 新匹配的价值量是 $j$ 大致就是这么三类 $j &lt; 0$ 时类似 代码#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; const int Maxm = 2e6+7; const int Zero = 1e6; int n; char s[Maxm]; int f[Maxm], v[Maxm], c[Maxm]; // f[i] s-c == i max value int main() { int upv, lov; memset(f, -1, sizeof f); f[Zero] = 0; upv = lov = Zero; scanf(&quot;%d&quot;, &amp;n); for(int i = 1, nums, numc; i &lt;= n; ++i) { nums = numc = 0; scanf(&quot;%s&quot;, s); for(int j = 0, len = strlen(s); j &lt; len; ++j) { if(s[j] == &#39;s&#39;) nums++; if(s[j] == &#39;c&#39;) numc++; } v[i] = min(nums, numc); c[i] = nums-numc; if(c[i] == 0) f[Zero] += v[i]; else if(c[i] &gt; 0) upv += c[i]; else if(c[i] &lt; 0) lov += c[i]; } for(int i = 1; i &lt;= n; ++i) { if(c[i] == 0) continue; if(c[i] &gt; 0) { for(int j = upv; j &gt;= lov+c[i]; --j) { if(f[j-c[i]] == -1) continue; if(j &gt;= c[i]) // plus the diff f[j] = max(f[j], f[j-c[i]]+v[i]); else if(j &lt;= 0) // minus the diff f[j] = max(f[j], f[j-c[i]]+v[i]+c[i]); else // (0, c[i]) f[j] = max(f[j], f[j-c[i]]+v[i]+(c[i]-j)); } } else if(c[i] &lt; 0) { for(int j = lov; j &lt;= upv+c[i]; ++j) { if(f[j-c[i]] == -1) continue; if(j &lt;= c[i]) // plus the diff f[j] = max(f[j], f[j-c[i]]+v[i]); else if(j &gt;= 0) // minus the diff f[j] = max(f[j], f[j-c[i]]+v[i]+(-c[i])); else // (c[i], 0) f[j] = max(f[j], f[j-c[i]]+v[i]+(j-c[i])); } } } printf(&quot;%d\\n&quot;, f[Zero]); return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"JerryC Loves Driving","slug":"Luogu-P4863","date":"2018-09-25T09:00:00.000Z","updated":"2022-04-10T07:52:45.139Z","comments":true,"path":"2018/09/25/Luogu-P4863/","link":"","permalink":"http://kaizynx.github.io/2018/09/25/Luogu-P4863/","excerpt":"","text":"Luogu P4863 JerryC Loves Driving题意给 $A,B$ 求 $\\sum\\limits_{i=A}^B \\sum\\limits_{j=1}^{i}\\lfloor \\frac{i}{j} \\rfloor \\times (-1)^j$ 数据范围$1⩽A⩽B⩽2\\times10^7$ 思路$O(n)$ 算法 $\\sum\\limits_{i=A}^B \\sum\\limits_{j=1}^{i}\\lfloor \\frac{i}{j} \\rfloor \\times (-1)^j$ $=\\sum\\limits_{j=1}^{i}\\sum\\limits_{i=A}^B \\lfloor \\frac{i}{j} \\rfloor \\times (-1)^j$ 这样就可以处理掉 $(-1)^j$ $=-\\sum\\limits_{i=A}^B \\lfloor \\frac{i}{1} \\rfloor + \\sum\\limits_{i=A}^B \\lfloor \\frac{i}{2} \\rfloor - \\sum\\limits_{i=A}^B \\lfloor \\frac{i}{3} \\rfloor …(-1)^B \\times \\sum\\limits_{i=A}^B \\lfloor \\frac{i}{B} \\rfloor$ 然后我们再想办法 $O(1)$ 求 $\\sum\\limits_{i=A}^B \\lfloor \\frac{i}{j} \\rfloor$ 向下取整是个神奇的东西,向下取整后结果就会变成形如 $k,k,k+1,k+1,k+1…..k+m,k+m,k+m$ 例如:当 $A=4,B=13,j=3$ i 4 5 6 7 8 9 10 11 12 13 $\\lfloor \\frac{i}{j} \\rfloor$ 1 1 2 2 2 3 3 3 4 4 设 $k=\\lfloor \\frac{i}{j} \\rfloor$ 那么 $\\lfloor \\frac{i}{j} \\rfloor$ 的 $i$ 的个数就有 $j$ 个 当然两端的是特殊状况 左端是 $\\lfloor \\frac{A}{j} \\rfloor$ ,我们记作 $a$ 左端是 $\\lfloor \\frac{B}{j} \\rfloor$ ,我们记作 $b$ 于是中间就是 $[a+1,b-1]$ 可以用等差数列求和公式算得 中间的和 $\\sum\\limits_{i=a+1}^{b-1} i \\times j = j \\times \\frac{(a+b)\\times (b-a-1)}{2}$ 我们再看两边的,不难看出 左边长度为 $((\\lfloor \\frac{A}{j} \\rfloor+1)\\times j) -A$ 右边长度为 $B-(\\lfloor \\frac{B}{j} \\rfloor \\times j) + 1$ 继续考虑细节问题 原式中是 $\\lfloor \\frac{i}{j} \\rfloor$ 不存在 $i &lt; j$ 当 $i &lt; j$ 时 $\\lfloor \\frac{i}{j} \\rfloor = 0$ 所以变式没有影响 但是!会对我们的求和操作造成影响 解决办法: 当 $j &gt; A$ 时, 令 $A = j$ 当 $\\lfloor \\frac{A}{j} \\rfloor = \\lfloor \\frac{B}{j} \\rfloor$ 时 我们会重负计算 故特判即可 当 $\\lfloor \\frac{A}{j} \\rfloor +1 = \\lfloor \\frac{B}{j} \\rfloor$ 时 不存在中间那部分 而这对求和造成影响 所以也需要特判 正负号很好判断 以防万一,开long long 但是开了会降速很多(变成大概2倍了吧) 但还是能过 稍微分析一下 运算过程中产生的最大中间量应该为 $j\\times \\frac {(a+b)\\times (b-a-1)}{2}$ 求和最大 $\\frac{B^2}{j^2}$ 所以结果大概是 $\\frac{B^2}{j}$ 就是会爆啊 代码#include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int A, B; long long ans; int main() { cin &gt;&gt; A &gt;&gt; B; for(int j = 1, a, b; j &lt;= B; ++j) { if(j &gt; A) A = j; long long tag = j&amp;1 ? -1 : 1; a = A/j, b = B/j; if(a == b) ans += tag*(B-A+1)*a; else { ans += tag*( ((a+1)*j-A)*a + (B-b*j+1)*b ); if(a+1 &lt; b) ans += tag*j*(a+b)*(b-a-1)/2; } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } 写在后面因为数据范围 $10^7, O(n)$ 算法苟过 其实还有 $\\sqrt{n}$ 的算法 有待研究","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"毒瘤的slay.three","slug":"Luogu-T44705","date":"2018-09-24T05:46:00.000Z","updated":"2022-04-10T07:52:45.144Z","comments":true,"path":"2018/09/24/Luogu-T44705/","link":"","permalink":"http://kaizynx.github.io/2018/09/24/Luogu-T44705/","excerpt":"","text":"T44705 【开学毒瘤赛T4】毒瘤的slay.three思路二分+DP 代码#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int n,a[20001],mx[20001],mn[20001],ans; int check(int x) { mn[1]=mx[1]=a[1]; for(int i=2;i&lt;=n;i++) mx[i]=min(a[i],a[1]-mn[i-1]),mn[i]=max(0,a[1]+a[i-1]+a[i]-mx[i-1]-x); if(!mn[n]) return 1; return 0; } int main() { int l=0,r=0; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),l=max(l,a[i]+a[i-1]); r=2*l+1; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; } printf(&quot;%d\\n&quot;,ans); return 0; } 以下错误解法,请勿模仿思路这个样例倒是太不贴心了 不过因此我们也可以发现当 $n \\leq 3$ 时 参数无法重复利用 暴力做法是: 对每一个直接填 按顺序下来 前两个比赛新增参数 假设选取参数1, 2, 3… 当进行到第 $i$ 个时 我们就把 $i-2$ 用过的参数重复利用了 用一个数组记录某个参数是否用过 就这样暴力循环找 最坏情况每一个都时新参数 就是 $\\sum a$ (也说明不可能没有方案) 看到数据范围一点都不友好 遂放弃 理智地思考 我们先考虑中间情况,暂时不考虑围成一个圈后什么首尾的 其实并不需要清楚选的是那些参数 只需要考虑参数的个数即可 当到了 $a_i$ 的时候 $a_{i-2}$ 中的全部参数是可以用的 如果 $a_{i-2} &lt; a_{i}$ 那么我们有 $a_{i-2}$ 个可以重复利用 还需要新增 $a_i - a_{i-2}$ 个 但如果 $a_{i-2} \\geq a_{i}$ 那么 $a_i$ 就不需要在新增参数 还可以多出 $a_{i-2} - a_i$ 个 注意 这多出来的几个还可以直接被 $a_{i+1}$ 利用 因此我们回到 $ai$ 重新考虑 $ai$ 可以重复利用的参数是 $a_{i-2}$ 刚腾出来的加上 $a_{i-1}$ 用剩下的 于是我们用 $b_i$ 记录第 $i$ 个用剩下的 所以: $a_i$ 可用: $a_{i-2} + b_{i-1}$ 如果 $a_i &gt;$ 可用,剩下 $b_i = 0$ 且需要新增 ($a_i -$当前可用)个参数 如果 $a_i \\leq$ 可用,剩下 $b_i =$ 可用 $- a_i$ 然后我们再来考虑特殊状态 $a_1, a_2$ 是必须要新增的 $b_1 = b_2 = 0$ 接着我们考虑到最后一个 $a_n$ $a_i$ 会影响 $a_{i-1}, a_{i+1}$ 因为是从前往后考虑 让 $a_i$ 适应 $a_{i-1}$ 再让 $a_{i+1}$ 适应 $a_i$ 故决策不会受到印象 而 $a_n$ 不仅受到 $a_{n-1}$ 影响 还受到 $a_1$ 影响 当然受到影响的前提是 $a_1$ 的参数被 $a_n$ 重复利用 也就是 $a_i$ 的参数存在于 $b_{i-1}$ 中 因为这种影响不是必然的,所以我想该如何避免这种情况 那么想为什么会出现这种情况,何时,怎么出现 想到是 $a_1$ 太大的,它留下的一直被延续利用至 $a_n$ 这么想有点夸张,不过在理 下面三行先当玩笑 那么我们就令最小的 $a$ 为 $a_1$ 吧 反正都是环 于是再不妨令 $a$ 的下标从0开始 代码#include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 2e4+7; int n, sum, sta, a[Maxn], b[Maxn]; int main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, a+i); sum += a[i]; if(a[i] &lt; a[sta]) sta = i; } if(n &lt;= 3) { printf(&quot;%d\\n&quot;, sum); return 0; } sum = a[sta]+a[(sta+1)%n]; for(int i = 2, rest, now; i &lt; n; ++i) { now = (sta+i)%n; rest = b[(now-1+n)%n]+a[(now-2+n)%n]; if(rest &gt;= a[now]) b[now] = rest-a[now]; else sum += a[now]-rest; } printf(&quot;%lld\\n&quot;, 3ll*sum); return 0; } ps当有这样一组数据 5 1 1 1 1 1 正确答案应该是9而我AC程序是6 埋下伏笔先 而且就算不用搞什么取最小也能A 正解是二分+DP","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://kaizynx.github.io/tags/二分/"},{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"kls与flag","slug":"Luogu-P4889","date":"2018-09-24T05:45:00.000Z","updated":"2022-04-10T07:52:45.140Z","comments":true,"path":"2018/09/24/Luogu-P4889/","link":"","permalink":"http://kaizynx.github.io/2018/09/24/Luogu-P4889/","excerpt":"","text":"Luogu P4889 kls与flag思路思路总是从暴力开始 暴力做法30分 两两枚举 条件是: 两杆的高度的和或者差等于两杆的坐标距离 70分 由数据范围可以猜测 $O(logN)$ 设第 $i$ 根杆的高度为 $h_i$ 每根杆子可以向左向右倒 向左倒尖端坐标 $i-h_i$ 向右倒尖端坐标 $i+h_i$ 也就是说在某个坐标如果有两根能倒到这里 就满足条件 如果有多个点(设有 $k$ 个)能倒到这里 那么就两两组合,共 $\\frac{ (1+k) \\times k}{2}$ 种 100分 还是在70分的基础上 发现数据范围太大了 不如离散化 记录每根杆能倒到的坐标 共有 $2n$ 个 排序后,就能轻易找到相同坐标点上的杆子个数 代码#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int Maxn = 2e5+7; int n, m, tot; long long ans, a[Maxn&lt;&lt;1]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1, x; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;x); a[++tot] = i-x; a[++tot] = i+x; } sort(a+1, a+1+tot); int cur = 1, cnt = 0; while(cur &lt;= tot) { cnt = 0; while(cur+1 &lt;= tot &amp;&amp; a[cur+1] == a[cur]) { ++cur; ++cnt; } ans += 1ll*cnt*(cnt+1)/2; ++cur; } printf(&quot;%lld\\n&quot;, ans); return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"离散化","slug":"离散化","permalink":"http://kaizynx.github.io/tags/离散化/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"小凯的数字","slug":"Luogu-U32670","date":"2018-09-24T05:00:00.000Z","updated":"2022-04-10T07:52:45.145Z","comments":true,"path":"2018/09/24/Luogu-U32670/","link":"","permalink":"http://kaizynx.github.io/2018/09/24/Luogu-U32670/","excerpt":"","text":"小凯的数字题意小凯写下一串数字 $l(l+1)(l+2)…(r-1)r$ 例如:l=2,r=5时，数字为:2345 l=8,r=12时数字为:89101112 求这个数 %9 的值 Q组询问 数据范围$Q \\leq 10^4$ $0 &lt; l \\leq r \\leq 10^{12}$ 思路其实可以类比除以3 先想想暴力的做法 要构造出这样的数字 就要把 l 乘上 10^k 在加上 l+1 依此进行下去 于是我们注意到 10^k 显然发现 $10^k \\div 9 = 111…111 余1$ 即 $10^k \\%9 = 1$ 所以 $( a \\times 10^k + b ) \\% 9$ $= ( a \\times 10^k ) \\% 9 + b \\% 9$ $= a \\% 9 \\times 10^k \\% 9 + b \\% 9$ $= a\\% 9 + b \\% 9$ 那么问题就转化成 $( \\sum\\limits _{i=l} ^r i )\\% 9$ 根据求和公式 $\\frac { (l+r) \\times (r-l+1) }{2} \\% 9$ 坑点就是中间运算可能会爆long long 代码#include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int Q; long long l, r; int main() { cin &gt;&gt; Q; while(Q--) { cin &gt;&gt; l &gt;&gt; r; long long a = l+r, b = r-l+1; if(a%2 == 0) a /= 2; else b /= 2; a %= 9; b %= 9; cout &lt;&lt; a*b%9 &lt;&lt; endl; } return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"AtCoder ABC110 D-Factorization","slug":"AtCoder-ABC110","date":"2018-09-24T03:14:29.000Z","updated":"2022-04-10T07:52:45.120Z","comments":true,"path":"2018/09/24/AtCoder-ABC110/","link":"","permalink":"http://kaizynx.github.io/2018/09/24/AtCoder-ABC110/","excerpt":"","text":"Factorization题意给你两个整数$N, M$ 问有多少个长度为 $N$ 的序列 $a$ 满足 $a_1 \\times a_2 \\times … \\times a_N = M$ 答案对 $10^9+7$ 取模 当存在任意个数 $i$ 使得 $a_i’ \\neq a_i’’$ 则两个序列不同 数据范围 所有的输入都是整数 $1 \\leq N \\leq 10^5$ $1 \\leq M \\leq 10^9$ 样例输入2 6 输出4 解释$(1,6),(2,3)(3,2),(6,1)$ 思路显然 $a_i$ 可以被 $M$ 整除 我们对 $M$ 进行分解质因数 $$M = p_1^{b_1} \\times p_2^{b_2} \\times … \\times p_k^{b_k} $$ 所以 $$ a_i = p_1^{c_{i1}} \\times p_2^{c_{i2}} \\times … \\times p_k^{c_{ik}} $$ 此时有 $$ \\prod\\limits_{i=1}^N a_i = \\prod\\limits_{i=1}^k p_i^{\\sum\\limits_{j=1}^N c_{ij}}$$ 其实不用看上面那个式子显然可得 $$ c_{1j} + c_{2j} + … + c_{Nj} = b_j $$ 因此问题就转化为了将 $b_i$ 划分成 $N$ 个部分(可以有0) 这里用到排列组合的知识 问题等价于在 $bi$ 中塞入 $N-1$ 个隔板 为了方便求解,不妨增添 $N-1$个物品再划分成 $N$ 个部分(此时每部分都 $\\geq 1$) 划分完后每部分减去1就变回了原来的问题 所以对 $bi$ 的划分方案数就是 $C_{bi+N-1}^{N-1}$ 又因为 $C_p^q = C_p^{p-q}$ 所以 $C_{bi+N-1}^{N-1} = C_{bi+N-1}^{bi}$ 计算时可以取 $C_{bi+N-1}^{\\min(N-1, bi)}$ 根据乘法原理,总的方案数就是 $$ \\prod\\limits_{i=1}^k C_{bi+N-1}^{b_i}$$ 接下来就是实现的问题了 质因数分解 我们只需要记录 $b_i$ 即可 inline void Prime_factorization(int x, vector&lt;int&gt; &amp;v) { for(int i = 2, cnt; i &lt;= x; ++i) { if(x%i) continue; cnt = 0; while(x%i == 0) { x /= i; cnt++; } v.emplace_back(cnt); } if(x &gt; 1) v.emplace_back(x); } 排列组合计算 $C_p^q = \\frac{p(p-1)(p-2)…(p-q+1)}{q!}$ 我们想想最坏的情况 $M = 2^b$ 如果 $M$ 可以分解成其他质因数 那么显然 $b_i$ 的和小于全是2的 那么最多有 $log_2 M$ 个质因数 也就是说我们计算 $C_{b+N-1}^b$ 时 最大会有 $C_{100000}^{30}$ 显然爆 int 爆 long long 那么考虑如何取模 此处涉及除法 第一念头想到了乘法逆元 第二念头仔细一想 除数最大有 $30!$ (阶乘) 这个好像……直接上高精度 于是我想到某暴力 因为 $C_p^q$ 最后时整数 就是说除数是能和被除数整除的 也就是说对除数和被除数分解质因数也是能约掉的 想想还是对的,没有错的! 但是我懒得这么做,真的麻烦 于是我就没分解开始约数 我们看的计算公式,上面有 $q$ 项 下面也有 $q$ 项,且是 1~q 而有根据鸽巢定理 连续的q个数中肯定有一个数能被q整除 于是我这么写 inline long long comb(int a, int b) // C_a^b { if(b == 0) return 1; vector&lt;int&gt; x, y; for(int i = a; i &gt; a-b; --i) x.emplace_back(i); for(int i = 2; i &lt;= b; ++i) y.emplace_back(i); for(int i = 0; i &lt; x.size(); ++i) for(int j = y.size()-1; j &gt;= 0; --j) { if(x[i]%y[j] == 0) { x[i] /= y[j]; y[j] = 1; } } long long res = 1; for(int i : x) res = res*i%Mo; return res; } 可惜不足的是偏偏 WA 了一个点 找不到什么坑,总之这个做法欠缺完美因为我的懒 解决方案 对除数被除数分别分解质因数再约 复杂度:高 利用鸽巢原理将 $q$ 个数字对应起来约掉 如何对应尚不明确…埋下巨坑 想必我的代码是因为某一个对应错了,导致没有约完 那么我们不妨考虑另一种做法参看大佬的代码 还是乘法逆元 那么我可能没想到 $a^{-1} = (a\\%p)^{-1}$ 假设用费马小定理求解逆元 $a^{-1} = a^{p-2}\\%p$ 而因为 $a^k = (a\\%p)^k$ 所以得证 $a^{-1} = (a\\%p)^{-1}$ 代码#include &lt;bits/stdc++.h&gt; using namespace std; const int Mo = 1e9+7; int n, m; vector&lt;int&gt; v; inline long long quickm(long long a, int p) // a^p%Mo { long long res = 1; while(p) { if(p&amp;1) res = res*a%Mo; a = a*a%Mo; p &gt;&gt;= 1; } return res; } inline long long mul_inverse(long long x) { return quickm(x, Mo-2); } inline void Prime_factorization(int x, vector&lt;int&gt; &amp;v) { for(int i = 2, cnt; i &lt;= x; ++i) { if(x%i) continue; cnt = 0; while(x%i == 0) { x /= i; cnt++; } v.emplace_back(cnt); } if(x &gt; 1) v.emplace_back(x); } inline long long comb(int a, int b) // C_a^b { if(b == 0) return 1; long long p = 1, q = 1; for(int i = 1; i &lt;= b; ++i) { p = p*a%Mo; a--; q = q*i%Mo; } return p*mul_inverse(q)%Mo; } int main() { cin &gt;&gt; n &gt;&gt; m; Prime_factorization(m, v); long long ans = 1; for(int i : v) ans = ans*comb(i+n-1, min(i, n-1))%Mo; cout &lt;&lt; ans &lt;&lt; endl; return 0; } 时间复杂度质因数分解 $O ( \\sqrt{M} )$ 质因数的个数( $b$ 最大值) $log M$ 乘法逆元 $O ( log 10^9)$ 与 $O ( log M)$ 等数量级 所以计算一次排列组合 $O ( b + log 10^9)$ 等价于 $O ( log M )$ 全部的排列组合 $O ( ( logM )^2 )$ 最终复杂度还是在分解质因数上 $O ( \\sqrt{M} )$ 好像和 $N$ 没扯上任何关系… 数量级上 $O ( \\sqrt{M} ) \\Longrightarrow O ( N )$","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"质因数分解","slug":"质因数分解","permalink":"http://kaizynx.github.io/tags/质因数分解/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://kaizynx.github.io/tags/乘法逆元/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"Codeforces Round 510 (Div. 2)","slug":"CodeforcesR510div2","date":"2018-09-18T05:04:00.000Z","updated":"2022-04-10T07:52:45.133Z","comments":true,"path":"2018/09/18/CodeforcesR510div2/","link":"","permalink":"http://kaizynx.github.io/2018/09/18/CodeforcesR510div2/","excerpt":"","text":"前言这是一场惨痛的翻车案 A. Benches题意有n个沙滩,第i个沙滩原本有ai个人 后来来了m个人,每人去往任意一个沙滩 最终所有人数最多的一个沙滩的人数记为k 求k的最小值和最大值 数据范围1 &lt;= n &lt;= 100 1 &lt;= m &lt;= 10000 1 &lt;= ai &lt;= 100 思路一眼看出的水题 最大的k就是m个人都去原本人最多的沙滩 $k_{max} = \\max (ai) + m$ 那么问题就是最少 我的第一想法就是均摊嘛 原本人少的多去几个,原本人多的少去几个 尽量让每个沙滩的人数平均 答案就是均摊量 设sum是ai的和,也就是原本沙滩上的总人数 k = (sum+m)/n+((sum+m)%n != 0)) 能均摊就(sum+m)/n 不能均摊就是(sum+m)/n+1 然后 就被Hack了 看这样一组数据: 输入 3 2 5 0 0 我的输出 3 7 正确答案 5 7 发现了并不一定能”均摊” 调整为k = max(maxa, (sum+m)/n+((sum+m)%n != 0)) 正确代码如下 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int n, m, sum, maxa, a; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a); maxa = max(a, maxa); sum += a; } printf(&quot;%d %d\\n&quot;, max(maxa, (sum+m)/n+((sum+m)%n != 0)), maxa+m); return 0; } B. Vitamins题意商店卖n种饮料,每种饮料有一种或多种维生素(A,B,C),价格为ci 问得到A,B,C三种最少要多少钱 ps:输入保证只出现A,B,C且每种最多出现一次 数据范围1 &lt;= n &lt;= 1000 1 &lt;= ci &lt;= 100000 思路这个看着其实挺简单的呀 用头想都知道怎么办 可是想敲代码又愣住了 怎么敲 还是暴力 想要ABC,可以有一下凑法 A+B+C AB+C AC+B BC+A ABC 假如A的饮料有k个 我们选的肯定是k个中价值最小的 所以只需要一个简单数组记录各种饮料的最低价格 再配凑出ABC 饮料的种类可分为以下几种 A B C AB AC BC ABC 很暴力了 但这样有些太过麻烦了 于是想到了二进制优化 假如把A,B,C看成以下数字 A == 1 B == 2 C == 4 这样形成的组合就不会有重复 那么1~7就能完美覆盖所有饮料的种类 以下是我的代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; const int INF = 1e8+7; int n, c[8]; string str; // a 1 b 2 c 4 // ab 3 ac 5 bc 6 abc 7 int main() { for(int i = 1; i &lt;= 7; ++i) c[i] = INF; cin &gt;&gt; n; for(int i = 1, tmp, k; i &lt;= n; ++i) { cin &gt;&gt; tmp &gt;&gt; str; k = 0; for(int i = 0; i &lt; str.length(); ++i) k += 1&lt;&lt;(str[i]-&#39;A&#39;); c[k] = min(c[k], tmp); } int res = c[7]; res = min(res, c[1]+c[2]+c[4]); res = min(res, c[3]+c[4]); res = min(res, c[5]+c[2]); res = min(res, c[6]+c[1]); res = min(res, c[3]+c[5]); res = min(res, c[3]+c[6]); res = min(res, c[5]+c[6]); printf(&quot;%d\\n&quot;, res == INF ? -1 : res); return 0; } 没错,你们发现有坑点了吗 想组合出ABC其实还有3种方法 AB+AC AB+BC AC+BC 而AB+AC+BC是显然不行的啦 就是因为忘了这三种我第一次提交错了 后来,没错,我的B题也被Hack了! 原因是我一开始INF定义为c的最大值1e5 如果有这样的饮料 A 1e5 B 1e5 C 1e5 按照我的做法得出答案1e5 其实是3e5 唉 C. Array Product这题无疑让我最头疼 题意给n个数字ai 操作1: 把aj = ai*aj,删去ai 操作2: 删去ai(只能进行一次) n-1次操作后只剩1个数字 求使最后数字最大的方案 数据范围2 &lt;= n &lt;= 2*10^5 -10^9 &lt;= ai &lt;= 10^9 思路思路还算简单 以下进行分类讨论 对于正数 反正全部乘起来就对了,因为都&gt;=1 所以对于任意个数的正数不做考虑 对于0(没有负数的情况) 我们知道任何数乘0得到0 所以如果有0,结果会是0小于正数 因此我们选择删去0(操作2) 而且无论任意数量的0 都可以两两相乘(操作1)得到1个0 对于负数(没有0) 假如有偶数个负数 因为负负得正 视为正数,无脑相乘 假如有奇数个负数 全部相乘一定为负 我第一次想法是两两相乘再删掉 其实正确做法是: 删去一个乘积就是正数 那么删去哪个呢 要使剩下偶数个乘起来最大 就要剩下的负数的绝对值最大 意思是删去绝对值最小的 因为是负数比较 等价于删去负数中值最大的 如果同时存在0和负数 这是我第三次提交了 之前两次是考虑错了这种情况 因为0可以看成一个0 负数有偶数个 相乘为正数,不特殊考虑 故删去0 负数有奇数个 第一想法是乘0和乘负数 嗯,删去负数 于是乎我就错了2次了 于是又仔细想想 发现可以这样操作 把0和多出的负数相乘得到0 再删去这个0 两全其美 我想这应该就是正确思路了 如上所示分类也挺麻烦的 因此代码也是相当暴力,敲的贼长,也贼烦 如果你们看了样例 那么在实践过程中还会发现 我们需要记录一下进行了几步,是否会超出n-1 这个超出特判是在进行操作2的时候 因为我们的方案像把0相乘到一个0再删去 如果数据全是0,那么最后结果就是相乘的一个0 并不需要删除操作 赛后我看AC代码,感觉也确实如此的思路吧 可我就是WA了 C题3WA滚粗(至此不知所错) 以下是我赛后稍加思考改进的代码 起码比赛时的超暴力好看些 注意:是不知所错的代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int Maxn = 2e5+7; // 00 1+ 2- int n, cnt[3], pos[3], step; pair&lt;int, int&gt; a[Maxn]; int main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i].first); a[i].second = i; if(a[i].first == 0) cnt[0]++; else if(a[i].first &gt; 0) cnt[1]++; else cnt[2]++; } sort(a+1, a+n+1); for(int i = 1; i &lt;= n; ++i) { if(a[i].first == 0 &amp;&amp; !pos[0]) pos[0] = i; else if(a[i].first &gt; 0 &amp;&amp; !pos[1]) pos[1] = i; else if(a[i].first &lt; 0 &amp;&amp; !pos[2]) pos[2] = i; } while(step &lt; n-1 &amp;&amp; cnt[0] &gt; 1) { printf(&quot;1 %d %d\\n&quot;, a[pos[0]].second, a[pos[0]+1].second); pos[0]++; cnt[0]--; step++; } // now cnt[0] &lt;= 1 if(step &lt; n-1 &amp;&amp; cnt[2]&amp;1) { if(cnt[0]) { printf(&quot;1 %d %d\\n&quot;, a[pos[0]].second, a[pos[2]+cnt[2]-1].second); cnt[2]--; step++; if(step &lt; n-1) { printf(&quot;2 %d\\n&quot;, a[pos[0]].second); cnt[0]--; step++; } } else { printf(&quot;2 %d\\n&quot;, a[pos[2]+cnt[2]-1].second); cnt[2]--; step++; } } // now cnt[2]&amp;1 == 0 if(step &lt; n-1 &amp;&amp; cnt[0]) { printf(&quot;2 %d\\n&quot;, a[pos[0]].second); cnt[0]--; step++; } // now cnt[0] == 0 while(step &lt; n-1 &amp;&amp; cnt[2] &gt; 1) { printf(&quot;1 %d %d\\n&quot;, a[pos[2]].second, a[pos[2]+1].second); pos[2]++; cnt[2]--; step++; } // now cnt[2] &lt;= 1 while(step &lt; n-1 &amp;&amp; cnt[1] &gt; 1) { printf(&quot;1 %d %d\\n&quot;, a[pos[1]].second, a[pos[1]+1].second); pos[1]++; cnt[1]--; step++; } // now cnt[0] == 0, cnt[1] &lt;= 1, cnt[2] &lt;= 1 if(step &lt; n-1) printf(&quot;1 %d %d\\n&quot;, a[pos[1]].second, a[pos[2]].second); return 0; } 再以下是我借鉴AC代码的代码 #include &lt;stack&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 2e5+7; const int INF = 1e9+7; int n, nega = -INF, negid, cnt, negn; stack&lt;int&gt; s, zero; int main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1, a; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a); if(a == 0) zero.push(i); else { if(a &lt; 0) negn++; if(a &lt; 0 &amp;&amp; a &gt; nega) { nega = a; negid = i; } s.push(i); } } int tmp; while(zero.size() &gt; 1) { tmp = zero.top(); zero.pop(); printf(&quot;1 %d %d\\n&quot;, tmp, zero.top()); cnt++; } if(negn&amp;1) { if(zero.size()) { printf(&quot;1 %d %d\\n&quot;, zero.top(), negid); cnt++; zero.pop(); } if(cnt &lt; n-1) { printf(&quot;2 %d\\n&quot;, negid); cnt++; } } if(cnt &lt; n-1 &amp;&amp; zero.size()) { printf(&quot;2 %d\\n&quot;, zero.top()); cnt++; } if(cnt &gt;= n-1) return 0; while(s.size() &gt; 1 &amp;&amp; cnt &lt; n-1) { tmp = s.top(); s.pop(); if(negn&amp;1 &amp;&amp; tmp == negid) { tmp = s.top(); s.pop(); } if(negn&amp;1 &amp;&amp; s.top() == negid) { s.pop(); } printf(&quot;1 %d %d\\n&quot;, tmp, s.top()); cnt++; } return 0; } D. Petya and Array这题别看我写出来了,其实是在群里py来的 我因被Hack被大佬看重 他从我这寻找Hack点 我交易得到D题代码 实在是有些罪过啊 题意有长度n的数组ai 求有多少个区间的区间和小于t 数据范围1 &lt;= n &lt;= 200000 |t| &lt;= 2*10^14 |ai| &lt;= 10^9 思路当时感到爆炸,而且精力还放在C题找错上 就抄了一遍代码交上去了 我们用sum[]表示前缀和 区间[i+1,j],(i&lt;j)和就是sum[j]-sum[i] 我们固定右端点为j 求sum[j]-sum[i] &lt; t 即sum[j]-t &lt; sum[i] 即求多少个i (0&lt;i&lt;j)的sum满足上述条件 我们用树状数组tr[x] 记录sum小于x的个数 每次扩大右端点j后,更新tr[] 即加入sum[j] 然后对于每个右端点j 查询&gt; sum[j]-t的个数即可 由于查询&gt;并不方便 不妨查询&lt;= sum[j]-t 求出不满足&lt; t的的区间个数 显然可得区间总数为n*(n+1)/2 另外由于数据范围贼大 需采用离散化 最终代码如下 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int Maxn = 2e5+7; int n, a[Maxn], tr[Maxn], tot; long long t, ans, sum[Maxn], dis[Maxn]; inline void update(int x) { for( ; x &lt;= n; x += x&amp;-x) tr[x]++; } inline int query(int x) { int res = 0; for( ; x; x -= x&amp;-x) res += tr[x]; return res; } int main() { scanf(&quot;%d%I64d&quot;, &amp;n, &amp;t); for(int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, a+i); dis[i] = sum[i] = sum[i-1]+a[i]; } dis[n] = 0; sort(dis+1, dis+n+1); tot = unique(dis+1, dis+n+1)-(dis+1); for(int i = 1, cur; i &lt;= n; ++i) { cur = lower_bound(dis+1, dis+tot+1, sum[i-1])-dis; update(cur); cur = upper_bound(dis+1, dis+tot+1, sum[i]-t)-(dis+1); ans += query(cur); } printf(&quot;%I64d\\n&quot;, ((n+1ll)*n)/2-ans); return 0; } 总之某种意义上说我是一题也没写出来 前两题的教训告诉我,不能太急 再者比赛16:05~18:05 光荣地牺牲了晚餐","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"树状数组","slug":"树状数组","permalink":"http://kaizynx.github.io/tags/树状数组/"},{"name":"枚举","slug":"枚举","permalink":"http://kaizynx.github.io/tags/枚举/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"Codeforces Round 509 (Div. 2)","slug":"CodeforcesR509div2","date":"2018-09-16T12:54:00.000Z","updated":"2022-04-10T07:52:45.132Z","comments":true,"path":"2018/09/16/CodeforcesR509div2/","link":"","permalink":"http://kaizynx.github.io/2018/09/16/CodeforcesR509div2/","excerpt":"","text":"A. Heist大水题 题意给n和数组ai(a1..an) 这个店的物品是编号从x开始的物品 x, x+1, x+2 … 遭贼了,剩下的物品编号是ai… 求一个x,使得被偷的物品最多 输出被偷的物品数量 数据范围1 &lt;= n &lt;= 10001 &lt;= ai &lt;= 10^9 思路题意不好懂啊(还是俄式英文) 反正读懂了之后就一下子想到 设物品是x~y(y-x+1个) ai有n个,所以被偷的的就是y-x+1-n个 即求y-x最小 因为ai肯定是x~y之间的 x &lt;= ai &lt;= y 求出ai的最小值和最大值就分别是x, y #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int n, a, maxa, mina; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;a); maxa = mina = a; for(int i = 2; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a); maxa = max(a, maxa); mina = min(a, mina); } printf(&quot;%d\\n&quot;, maxa-mina+1-n); return 0; } B. Buying a TV Set略水 题意输入a,b,x,y 买电视,需要这个电视长宽比是x:y 且长不超过a,宽不超过b 求满足的个数 数据范围1 &lt;= a,b,x,y &lt;= 10^18 思路很明显按照这个比例枚举 从最小的一直到长或者宽超出极限为止 从样例可以看出,x:y不是最简比 所以gcd约分一下,就是最小的了 设最小的是w, h 也就是w = x/gcd, h = y/gcd 枚举的数字是 w, 2w, 3w h, 2h, 3h 所以用a/w就是w在不超过a的情况下最大个数 同理到宽 最后得到结果是 min(a/w, b/w) #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; long long a, b, x, y; long long gcd(long long a, long long b) { return !b ? a : gcd(b, a%b); } int main() { cin &gt;&gt; a &gt;&gt; b &gt;&gt; x &gt;&gt; y; long long tmp = gcd(x, y); x /= tmp; y /= tmp; cout &lt;&lt; min(a/x, b/y) &lt;&lt; endl; return 0; } C. Coffee Break有难度的一题 题意某人一天有m分钟的工作时间 他想在n个ai时刻喝咖啡,没喝一次是1分钟 他喝每杯咖啡的间隔不得小于d 即要求aj - ai &gt; d 输入n,m,d, ai… 求需要分成几天喝完 并输入任意一个方案(ai在第几天喝) 这道题不好理解啊,我题意都感觉见不清楚 分析一下样例 样例输入4 5 3 3 5 1 2 输出3 3 1 1 2 解释day1:1, 5 day2:2 day3:3 那么可以理解了吧 就是把ai拆分成尽可能少的序列 使得每个序列中的元素两两之间差&gt;d 数据范围1 &lt;= n &lt;= 2*10^5n &lt;= m &lt;= 10^91 &lt;= d &lt;= m 思路就是贪心 假如这一天取了ai 那么下一个能取的是 &gt;= ai+d+1 如果有 aj &lt; ak 那么肯定先取aj,后面的选择余地才更大 这天选择的a才更多 然后…反正就是这样的贪心 总之先排序,然后 暴力贪心O(n^2) 就是一直取,选定第一个 往后找到第一个符合的加进来 知道这天安排不下 再取下一天 因为最多一天一杯咖啡 所以最多有n天 每天需要扫描n个 所以就是O(n^2) 妥妥TLE 并查集优化的暴力O(n^2) 我实在也没想到什么高超的方法 就着手优化了 容易发现上述暴力算法的累赘主要在扫描上 会有很多被选走了得进行不必要的扫描 于是用并查集 如果这个数被选走了 就把他(合并)指向它的下一个 这样就能快一些了吧 代码实现颇为复杂 然而我忽略的事实是主要的时间 还是花费在找合适的下一个值上 所以复杂度仍然接近O(n^2) 妥妥又TLE了 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int Maxn = 2e5+7; int n, m, d, res, cnt; int fa[Maxn], da[Maxn]; struct Coffee { int a, id; bool operator &lt; (const Coffee &amp;b) const { return a &lt; b.a; } } c[Maxn]; int getf(int s) { return fa[s] == s ? s : fa[s] = getf(fa[s]); } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;d); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].a), fa[i] = i, c[i].id = i; sort(c+1, c+n+1); while(cnt &lt; n) { int cur = getf(1), last; da[c[cur].id] = ++res; if(++cnt == n) break; last = cur; cur = fa[cur] = getf(cur+1); while(cur) { while(cur &amp;&amp; c[last].a+d &gt;= c[cur].a) cur = getf(cur+1); if(!cur) break; da[c[cur].id] = res; if(++cnt == n) break; last = cur; cur = fa[cur] = getf(cur+1); } } printf(&quot;%d\\n&quot;, res); for(int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, da[i]); printf(&quot;%d\\n&quot;, da[n]); return 0; } 优先队列O(n log n) 最后聪明的我还是想出了方法 稍微转换一下思路 对于每个aj,我们给它接到一个ai ai + d + 1 &lt;= aj 我们是从小到大安排aj的 那么找这个ai 根据贪心的原则 就得找最小的 怎么找最小的 优先队列 如果找不到,就另起一天 #include &lt;queue&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int Maxn = 2e5+7; int n, m, d, res; int da[Maxn]; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, greater&lt;pair&lt;int,int&gt; &gt; &gt; q; struct Coffee { int a, id; bool operator &lt; (const Coffee &amp;b) const { return a &lt; b.a; } } c[Maxn]; int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;d); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i].a), c[i].id = i; sort(c+1, c+n+1); da[c[1].id] = ++res; q.push(make_pair(c[1].a, 1)); pair&lt;int, int&gt; cur; for(int i = 2; i &lt;= n; ++i) { cur = q.top(); if(cur.first+d+1 &gt; c[i].a) { da[c[i].id] = ++res; q.push(make_pair(c[i].a, res)); } else { q.pop(); da[c[i].id] = cur.second; q.push(make_pair(c[i].a, cur.second)); } } printf(&quot;%d\\n&quot;, res); for(int i = 1; i &lt; n; ++i) printf(&quot;%d &quot;, da[i]); printf(&quot;%d\\n&quot;, da[n]); return 0; } D. Glider题意人从高度h的飞机上跳下 每秒水平位移1(向右) 竖直位移1(向下) 然后在横坐标x1-x2的位置有上升气流 就是能让你在x1-x2竖直位移为0 (当你已经落到地上则气流无效了) 求从哪个x起点跳下去能获得最大水平位移 输出水平位移 样例输入 3 4 2 5 7 9 10 11 输出 10 解释 如果从x=1跳,如图蓝线所示 水平位移是1~10也就是9 如果从x=2开始跳,如图橘线所示 水平位移2~12也就是10 思路其实我是没在比赛结束前敲出来 大致就像是单调队列 首先清楚的一点是起点应该从某气流的左端 还能往前飞就往前飞,同时往下掉 如果不能飞了,把最前面那段气流的路程减去 把第一次下降的高度加回去 还是比较清晰的 就是如何实现我废了好久,于是没来得及 本来想把每段气流长度和气流的间隔预处理一下 后来发现难以实现,所以没来得及 再后来就朴素的每个气流的端点来 设端点a(i) 如果i是奇数,那么a(i)~a(i+1)是气流 如果i是偶数,那么a(i)~a(i+1)假自由落体 以下是原来的代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 2e5+7; int n, H, ans; int a[Maxn&lt;&lt;1]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;H); for(int i = 1; i &lt;= n*2; ++i) scanf(&quot;%d&quot;, a+i); int head = 1, tail = 1, curx = 0, curh = H, tmp; ans = H+a[2]-a[1]; while(tail &lt;= n*2) { while(tail &lt;= n*2) { if(tail&amp;1) { if(curh &lt;= 0) break; curx += a[tail+1]-a[tail]; tail++; } else { tmp = a[tail+1]-a[tail]; if(curh-tmp &gt;= 0) { curx += tmp; curh -= tmp; tail++; } else break; } ans = max(ans, curx+curh); } // can&#39;t move now // head is odd if(head &gt;= tail) break; curx -= a[head+1]-a[head]; head++; // head is even if(head &gt;= tail) break; curx -= a[head+1]-a[head]; curh += a[head+1]-a[head]; head++; } printf(&quot;%d\\n&quot;, ans); return 0; } 评测结束后交了一发WA 因为样例是对了不少,一定有什么没考虑到 错的那组数据我求出来的值比答案小了很多 于是emmm 我稍加思考,冷静分析 发现一个坑就是:可能存在两段气流的间隔大于h 导致不管怎么回退之前掉落得高度也无法迈过这道坎 于是没有找完所有情况 如这组情况 输入 4 4 2 5 7 9 10 11 20 100 我的答案 10 正确答案 84 那么,也只需要稍加修改,就AC了 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 2e5+7; int n, H, ans; int a[Maxn&lt;&lt;1]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;H); for(int i = 1; i &lt;= n*2; ++i) scanf(&quot;%d&quot;, a+i); int head = 1, tail = 1, curx = 0, curh = H, tmp; ans = H+a[2]-a[1]; while(tail &lt;= n*2) { while(head &lt;= tail) { while(tail &lt;= n*2) { if(tail&amp;1) { if(curh &lt;= 0) break; curx += a[tail+1]-a[tail]; tail++; } else { tmp = a[tail+1]-a[tail]; if(curh-tmp &gt;= 0) { curx += tmp; curh -= tmp; tail++; } else break; } ans = max(ans, curx+curh); } // can&#39;t move now // head is odd if(head &gt;= tail) break; curx -= a[head+1]-a[head]; head++; // head is even if(head &gt;= tail) break; curx -= a[head+1]-a[head]; curh += a[head+1]-a[head]; head++; } // can&#39;t cross tail to tail+1 tail++; head++; curh = H; curx = 0; } printf(&quot;%d\\n&quot;, ans); return 0; } 最终结果是做出3/6 排名1796 上分1459+13=1472 因为这比赛在周日晚18:35~20:35 我是溜过来打的,比赛结束继续敲完了D题 再写写博客,又过了一小时 回去是几乎夜自修结束 从机房出来遇到办公室老是被数落一番 回到寝室班主任找上门 出发点应该是夜自修不在 于是又被数落一番 顺带又数落全寝 (三加一的一模成绩下午刚出来) 怎么说呢","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"贪心","slug":"贪心","permalink":"http://kaizynx.github.io/tags/贪心/"},{"name":"优先队列","slug":"优先队列","permalink":"http://kaizynx.github.io/tags/优先队列/"},{"name":"单调队列","slug":"单调队列","permalink":"http://kaizynx.github.io/tags/单调队列/"}],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://kaizynx.github.io/categories/Codeforces/"}]},{"title":"LeetCode Weekly Contest 102","slug":"LeetCodeWC102","date":"2018-09-16T03:30:00.000Z","updated":"2022-04-10T07:52:45.137Z","comments":true,"path":"2018/09/16/LeetCodeWC102/","link":"","permalink":"http://kaizynx.github.io/2018/09/16/LeetCodeWC102/","excerpt":"","text":"905. 按奇偶校验排序数组给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 数据范围： 1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 思路根本不用思考 class Solution { public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) { vector&lt;int&gt; tmp0, tmp1; for(auto i : A) { if(i&amp;1) tmp1.emplace_back(i); else tmp0.emplace_back(i); } tmp0.insert(tmp0.end(), tmp1.begin(), tmp1.end()); return tmp0; } }; 904. 水果成篮在一排树中，第 i 棵树产生 tree[i] 型的水果。 你可以从你选择的任何树开始，然后重复执行以下步骤： 把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。 移动到当前树右侧的下一棵树。如果右边没有树，就停下来。 请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。 你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。 用这个程序你能收集的水果总量是多少？ 数据范围 1 &lt;= tree.length &lt;= 40000 0 &lt;= tree[i] &lt; tree.length 思路一眼看穿:这不是某年NOIP初赛的完善程序吗? 就是找一段连续的子序列,子序列里面只有两种值 求这样子序列最长有多长 题面全是废话 看代码,如果看不懂那就是连NOIP初赛水准都没有 class Solution { public: int totalFruit(vector&lt;int&gt;&amp; tree) { int ans = 0, fr1 = tree[0], fr2 = -1, ct1 = 1, ct2 = 1, l = 0, r = 1; while(r &lt; tree.size() &amp;&amp; tree[r] == fr1) ct1++, r++; if(r == tree.size()) return ct1; fr2 = tree[r++]; while(r &lt; tree.size() &amp;&amp; tree[r] == fr2) ct2++, r++; ans = ct1+ct2; if(r == tree.size()) return ans; while(r &lt; tree.size()) { if(tree[r] == fr1) { ++ct1; ans = max(ans, ct1+ct2); } else if(tree[r] == fr2) { ++ct2; ans = max(ans, ct1+ct2); } else { int &amp;delt = tree[r-1] == fr1 ? ct2 : ct1; int &amp;delf = tree[r-1] == fr1 ? fr2 : fr1; while(delt &gt; 0) { if(tree[l] == fr1) ct1--; else ct2--; l++; } delf = tree[r]; delt = 1; } ++r; } return ans; } }; 907. 子数组的最小值之和给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。 由于答案可能很大，因此返回答案模 10^9 + 7。 数据范围 1 &lt;= A &lt;= 30000 1 &lt;= A[i] &lt;= 30000 思路在最后一刻(比赛结束了)做了出来T_T 这个从暴力开始推吧 超级暴力O(n^3) int fa(vector&lt;int&gt; &amp;A) { int res = 0; for(int l = 0; l &lt; A.size(); ++l) { for(int r = l; r &lt; A.size(); ++r) { int minv = 30001; for(int k = l; k &lt;= r; ++k) { minv = min(minv, A[k]); } res += minv; } } return res; } 暴力优化O(n^2) 发现当计算某个区间[l, r]时 [l, r]的最小值就是min{[l, r-1]最小值, a[r]} int fa(vector&lt;int&gt; &amp;A) { int res = 0, minv; for(int l = 0; l &lt; A.size(); ++l) { minv = A[l]; for(int r = l; r &lt; A.size(); ++r) { minv = min(minv, A[r]); res += minv; } } return res; } 盲目思考 这也是我一开始根本放弃暴力而采取的思维方式 设A[i]是数组中最小的值 那么包含A[i]的子序列里的最小值都是A[i] 所以res+=A[i]*包含A[i]的子序列个数 然后我想包括A[i]的子序列个数怎么求 如果以A[i]为左端点的子序列,有 i i, i+1 i, i+1, i+2 ... i, i+1, i+2, ... A[A.length()-1] 就有(A.length()-1)-i+1个 如果以A[i]为右端点 同理得有i-0+1个 再根据排列组合乘法原理 加上A[i]是序列中间某一点得时候 总共有((A.length()-1)-i+1)*(i-0+1)个 综上:res+=A[i]*((A.length()-1)-i+1)*(i-0+1) 然后第二小的emmmmm… 以上是启蒙思考… 总之重要得得出区间内子序列个数得求法 后来我就想到对于任意一个A[i] 以它为最小值得区间i往左找到最左边不小于它得位置 右边也一样找到最右边不小于它得位置 设l &lt;= i &lt;= r 使得[l,r]区间内A[i]为最小值 也即A[l-1] &lt; A[i], A[r+1] &lt; A[i] 所以就有res+=A[i]*((i-l+1)*(r-i+1)) 这真的是完美无缺! 但是谨慎得我仔细一想: 如果存在A[i] == A[j]就会有重复的 好吧,这也是启蒙思路… 然后我就卡如何去重好久了 于是回归了暴力的本质,想去试探O(30000^2)的边缘 妥妥的TLE,还发现上面的代码都忘了取模 暴力着暴力着就出思路了 应该是O(n)的解法 同样建立在寻找以A[i]为最小值的区间上 去重的方法,找到上文所示的l, r,微调 A[l-1] &lt; A[i], A[r+1] &lt;= A[i] 就是把重复的那部分包含到左边值一样的点 一时语塞,不知该怎么解释,先搁着 至于时间复杂度 每个元素不是都要向左向右找 难道不是O(n^2)? 不,如果A[i]是最小值,那么就会找完全部 如果A[i]是最大值,那么只会找左右各1个位置就结束了 虽然没能数学证明,但直觉论证 平均下来的时间复杂的应该为O(k*n) 这个常数k,嗯…我觉得是2~3 但是我们还说过两个值相同的情况 如果全部都一样,还是退化成了O(n^2) 不过这只是算法的最坏情况 平均情况还是O(n)得 题目数据A[i]得大小和个数范围一样 让人会误以为A[i]都不相同,其实没有这么说 反正我交上去是过了 class Solution { public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) { int res = 0, mo = 1e9+7, minv; for(int i = 0; i &lt; A.size(); ++i) { int l = i, r = i; while(--l &gt;= 0 &amp;&amp; A[l] &gt; A[i]); while(++r &lt; A.size() &amp;&amp; A[r] &gt;= A[i]); ++l; --r; res = (res+A[i]*(i-l+1)*(r-i+1))%mo; } return res; } }; ps:后来我测试了一下所谓得最差情况得数据 600ms惊了,难道这只是我的直觉出了问题吗","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaizynx.github.io/categories/LeetCode/"}]},{"title":"Candy Distribution Again","slug":"AtCoder-AGC027A","date":"2018-09-16T01:16:00.000Z","updated":"2022-04-10T07:52:45.122Z","comments":true,"path":"2018/09/16/AtCoder-AGC027A/","link":"","permalink":"http://kaizynx.github.io/2018/09/16/AtCoder-AGC027A/","excerpt":"","text":"只写出第一道签到题目 题意有N个人,x个物品分成N份 当且仅当第i人分到恰好ai个这个人才会高兴 问最多几个高兴 2 &lt;= N &lt;= 1001 &lt;= x &lt;= 10^91 &lt;= ai &lt;= 10^9 样例输入 3 70 20 30 10 输出 2 解释 One optimal way to distribute sweets is (20,30,20). 思路因为恰好,所以想到一个贪心的策略 首先满足需求小的,即ai小的 证明 设ai &lt; aj, aj = ai+k 如果满足j花去aj个物品 则一定存在方案满足i且多出k个物品来满足下一个人 保证了决策的最优性 证毕 所以按ai按升序排序 按顺序判断剩余物品能否满足 需要注意的就是最后一个人 如果剩下的物品&gt;an,是不行的 感觉这题的坑点就是N&lt;=100的范围让我始终不敢写啊 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int Maxn = 1e2+7; int n, x, ans; int a[Maxn]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;x); for(int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a+i); sort(a, a+n); for(int i = 0; i &lt; n &amp;&amp; x &gt;= a[i]; ++i) { x -= a[i]; // fit the last one if(i != n-1 || x == 0) ans++; } printf(&quot;%d\\n&quot;, ans); return 0; }","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"NOIP普及组2013 小朋友的数字","slug":"Luogu-P1982","date":"2018-09-13T13:33:36.000Z","updated":"2022-04-10T07:52:45.138Z","comments":true,"path":"2018/09/13/Luogu-P1982/","link":"","permalink":"http://kaizynx.github.io/2018/09/13/Luogu-P1982/","excerpt":"","text":"题意这题目描述真是有点为难我胖虎啊 有$n$个人,每个人手上有一个数字$a_i$(可正可负) 规定每个人的$b_i$为 他前面(包括他)连续若干人(至少一人)的a的和的最大值 即$b_k=max\\sum\\limits_{i=l}^ra_i(1\\leq l\\leq r \\leq k)$ 怎么编了个公式看上去更不懂了 再规定$m_i$ $m_1=b_1$ 当$i &gt; 1$ $m_i$是他前面(不包括他)的某一个人的$b_i+m_i$的最大值 即$m_k=max(m_i+b_i)(1 \\leq i &lt; k)$ 求$m$的最大值取模$p$ 数据范围: $1\\leq n \\leq 10^6, 1 \\leq p \\leq 10^9, abs(a_i) \\leq 10^9$ 思路$b_i$其实很好求得啦 就是求i之前的连续区间最大和的问题(是这么叫的吧?) 可以在O(n)求得,详情略 再看$m_i$ 是前面最大的某一个,因为只有一个 所以可以用记录下来,每次更新,也是O(n) 所以思路也是十分清晰明了 再分析一下数据范围: 假设是最坏的情况 $b_n=\\sum\\limits_{i=1}^{n}{a_i}\\leq10^6*10^9=10^{15}$ 因而可以用long long记录 这里有一个误区,我本来认为 既然$m_k=max(m_i+b_i)(1 \\leq i &lt; k)$ $b_i$在long long范围内,那么$m_i$也ojbk了 先上代码吧(80分,还有20分爆long long) #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 1e6+7; const long long INF = 1e16; int n, p; int a[Maxn]; long long b[Maxn], m[Maxn]; long long cur, maxsum, ans = -INF; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;p); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a+i); m[1] = maxsum = b[1] = cur = a[1]; if(cur &lt; 0) cur = 0; for(int i = 2; i &lt;= n; ++i) { cur += a[i]; b[i] = maxsum = max(maxsum, cur); if(cur &lt; 0) cur = 0; } for(int i = 2; i &lt;= n; ++i) { m[i] = ans = max(ans, m[i-1]+b[i-1]); } ans = max(ans, m[1]); printf(&quot;%d\\n&quot;, ans%p); return 0; } 我们进一步分析 证明: $b_i$是单调递增的 对于$b_i$就表示截取$[1, i]$的数组a的最大连续区间和 由于分治思想什么包容性 当$j=i+1$时$b_j=max(b_i, b_i+a_j,a_j)$ 即$j&gt;i$有$b_j=max(b_i ,[i+1, j]$的某个区间和, $[1, j]$的某个区间和$)$ 可以得出当$j&gt;i$时$b_j \\geq b_i$ 即$b_i$是单调递增的 证毕 再证明: $m_i$也是是单调递增的 设$i &lt; j,k=j+1$并且$m_j = m_i+b_i$ 即设$m_i+b_i$是$[1,j-1]$中最大的一项 当计算$m_k$时,求$[1,k-1]$即$[1,j]$中最大的 如果$m_j+b_j &gt; m_i+b_i$则选$j$ 反之因为$i$是$[1,j-1]$最大的,所哟选$i$ 而又因为$m_j = m_i+b_i$ 所以只要$b_j&gt;0$选$j$反之选$i$ 再如果选了$i$那么$m_k=m_i+b_i=m_j$ 如果选的是$j$那么$m_k=m_j+b_j=m_i+b_i+b_j$ 此时$b_j&gt;0$所以$m_k&gt;m_j=m_i+b_i$ 所以也可以说明$j&gt;i$时$m_j \\geq m_i$ 即$m_i$是单调递增的 证毕 终于经过一番玄学分析,题目才变成标签所示的DP $m_i=max(m_{i-1}, m_{i-1}+b_i)$ 显然$[2,n]$中$m_n$是最大的 但是$m_1$是个特判 我们有$m_1*2=m_2\\leq m_3\\leq …\\leq m_n$ 如果$m_1&gt;0$那么就是一直大下去 问题就在当$m_1&lt;0$时 $m_n \\geq m_2 = m_1+b_1=2*b_1$ 不难发现当存在$\\sum b_i&gt;abs(b_1)(2\\leq i &lt; n)$ 答案就是$m_n$否则为$m_1$ 有因为$m_1=b_1$所以$m_1$在long long范围内 因此这个判断可以在不爆long long的情况下进行 由于之前怕要比较大小关系之类的不敢轻易取模 现在看来没事了 其实不如直接上高精 讲是讲得很详细了,代码丑点不为过吧 这里用某些骚皮的操作把a数组和m数组省掉了 b也可以用滚动数组,不过懒 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 1e6+7; int n, p, a, flag; long long b[Maxn], m, cur, maxsum, maxsumb; int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;p, &amp;a); maxsum = b[1] = cur = a; if(a &gt; 0) flag = 1; if(cur &lt; 0) cur = 0; for(int i = 2; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a); cur += a; b[i] = maxsum = max(maxsum, cur); if(cur &lt; 0) cur = 0; if(i == 2) m = 2*b[1]; else if(b[i-1] &gt; 0) { m = (m+b[i-1])%p; if(!flag &amp;&amp; (maxsumb += b[i-1]) &gt;= -b[1]) flag = 1; } } if(flag) printf(&quot;%lld\\n&quot;, m); else printf(&quot;%lld\\n&quot;, b[1]%p); return 0; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://kaizynx.github.io/categories/NOIP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"},{"name":"NOIP","slug":"NOIP","permalink":"http://kaizynx.github.io/tags/NOIP/"}],"keywords":[{"name":"NOIP","slug":"NOIP","permalink":"http://kaizynx.github.io/categories/NOIP/"}]},{"title":"hby与tkw的基情","slug":"Luogu-P4881","date":"2018-09-13T02:17:00.000Z","updated":"2022-04-10T07:52:45.140Z","comments":true,"path":"2018/09/13/Luogu-P4881/","link":"","permalink":"http://kaizynx.github.io/2018/09/13/Luogu-P4881/","excerpt":"","text":"题目来源:洛谷P4881 hby与tkw的基情 前言解决本题所需要具备的知识 非战斗人员请即时撤离 快速幂 排列组合 高中数学之数列 除法取模(乘法逆元) 题意给出 T 组 n, 求 $Ans=\\sum\\limits_{i=1}^ni \\times s[i] \\times [i\\%2]$ 其中$s[i]$代表长度为 i 的回文串的个数(只考虑小写字母)，最后面是bool表达式 输出答案$\\%(10^9+7)$的值 $T\\leq5×10^5 ,n\\leq10^9$ 思路看到这个 n 的范围就整个人不太好了 肯定是把公式推导到 O(1) 吧 首先最简单的就是$[i\\%2]$ i为奇数是 1, i为偶数是 0 也就是说我们不需要考虑i为偶数的情况 再者我们思考$s[i]$ 对于回文字串, 上面已经推出长度i是奇数 也就是说我们要考虑1~⌈$\\frac{i}{2}$⌉位的字母 每一位上可以填a~z共26个字母, 一共就是$26^{⌈\\frac{i}{2}⌉}$种 这个不会重复不用说明吧 所以:$s[i]=26^{⌈\\frac{i}{2}⌉}$ 至此已经可以用O(n)的办法求解了 我们继续化简 整合得到: 设$f(i)$是$n=i$时的$Ans$ $f(i)=\\sum\\limits_{i=1}^ni \\times s[i] \\times [i\\%2]$ $=1 \\times 26^1+3 \\times 26^2+5 \\times 26^3+…$ 因此我们不妨把i除以2来把i为偶数的情况去掉 令$k={⌈\\frac{i}{2}⌉}$ $f(k)=1 \\times 26^1+3 \\times 26^2+5 \\times 26^3+…+(2 \\times k-1) \\times 26^k$ 这时我大为震惊,这竟然要用到高中数学的数列知识 $f(k)=1 \\times 26^1+3 \\times 26^2+5 \\times 26^3+…+(2 \\times k-1) \\times 26^k$ $26 \\times f(k)=1 \\times 26^2+3 \\times 26^3+5 \\times 26^4+…+(2 \\times k-1) \\times 26^{k+1}$ 下面减去上面的式子得到 $25 \\times f(k)=(2 \\times k-1) \\times 26^{k+1}-1 \\times 26^1-2 \\times (\\sum\\limits_{i=2}^{k} 26^i)$ 利用等比数列的求和公式得到 $25 \\times f(k)=(2 \\times k-1) \\times 26^{k+1}-26-2 \\times \\frac{26^2 \\times (1-26^{k-1})}{1-26}$ 化简步骤略略略 最后得到: $f(k)=\\frac{2 \\times k-1}{25} \\times 26^{k+1}-\\frac{26}{25}-\\frac{2}{25^2} \\times 26^{k+1}+\\frac{2}{25^2} \\times 26^2$ 其实已经完成了的,但是,答案很大还要取模 那么就不得不考虑除法的问题了 又一次感到了深深的恶意 乘法逆元!!! 通分得到: $f(k)=\\frac{1}{25^2}[(50 \\times k-27) \\times 26^{k+1}+702]$ 问题至此终于算的上是真正意义上的解决了 对于$26^{k+1}$用快速幂 因为取模后数字还可能有$10^9$那么大 而$n$也有$10^9$那么大 $(50 \\times k-27) \\times 26^{k+1}$就极有可能爆$int$ 反正遇到这种题无脑开long long不就行了 处理一下$26^2$也就是$625$的乘法逆元就可以了 关于 乘法逆元 除法取模 快速幂 的知识就不在此详细讲解 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const long long Mo = 1e9+7; int T; long long n; // 快速幂 inline long long quick_mo(long long x, long long p, long long mo) { long long res = 1; x %= mo; while(p) { if(p&amp;1) res = res*x%mo; x = x*x%mo; p &gt;&gt;= 1; } return res; } // 费马小定理计算乘法逆元 inline long long mul_inverse(int x) { return quick_mo(x, Mo-2, Mo); } int main() { scanf(&quot;%d&quot;, &amp;T); long long inverse = mul_inverse(625); while(T--) { scanf(&quot;%lld&quot;, &amp;n); n = (n+1)/2; // f(n) = (1/625)*((50*n-27)*26^(n+1)+702)%(1e9+7) long long res = ((50*n-27)%Mo*quick_mo(26, n+1, Mo)%Mo+702)%Mo*inverse%Mo; printf(&quot;%lld\\n&quot;, res); } return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://kaizynx.github.io/tags/排列组合/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://kaizynx.github.io/tags/乘法逆元/"},{"name":"快速幂","slug":"快速幂","permalink":"http://kaizynx.github.io/tags/快速幂/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"Oier们的幸运数字","slug":"Luogu-T42830","date":"2018-09-13T02:17:00.000Z","updated":"2022-04-10T07:52:45.142Z","comments":true,"path":"2018/09/13/Luogu-T42830/","link":"","permalink":"http://kaizynx.github.io/2018/09/13/Luogu-T42830/","excerpt":"","text":"题目来源:洛谷比赛Oier们的开学祭 转载来自题解 题意定义一个函数 $f(i)=i\\times\\sum_{j=1}^{i}[i\\bmod j]$ 即表示$f(i)$等于$i$乘以$i$的约数个数 给定$T$组$A,B$,判断$\\sum_{i=A}^{B}f(i)$是奇数还是偶数 数据范围: $100\\%$ 数据 $0\\leq T \\leq10^6, 1\\leq A_i \\leq B_i \\leq 10^{18}$ 思路暴力分还是有的,至于拿满分… 其实我是不会写的,题解转载来的 首先我们可以把那两个式子写成这样: $\\sum_{i=A}^B\\sum_{j|i} i$ 其中$j|i$表示$j$为$i$的约数. 如果我们设$d(i)$表示i的约数个数,那么就是这样的式子: $\\sum_{i=A}^B i*d(i)$ 三十分做法 直接暴力枚举.. 五十分做法 可以先$N\\sqrt{N}$ 来求出所有数的$i*d(i)$的值 然后求一个前缀和, 然后就可以O(1)处理每一个询问了.. 七十分做法 这里面的$d(i)$是一个很常见的积性函数 所以可以用线性筛预处理出所有的$d(i)$d 然后求出$i*d(i)$的前缀和,继续O(1)查询.. 满分做法 来推理一波.. 首先要让$\\sum_{i=A}^B i*d(i)$ $i∗d(i)$为奇数,我们在A~B中就需要有奇数个$i*d(i)$取值为奇数的值加起来 然后要让$i∗d(i)$取值为奇数,则需要$i$和$d(i)$都为奇数 如果要一个数的约数个数为奇数,显然需要是一个完全平方数 因为约数都是成对出现的$(i$和$\\sqrt{i})$ 所以只能构造出一对相同的数才能使约数个数为奇数 所以使$i*d(i)$取值为奇数的数都是完全平方奇数 现在问题就变成了求一个区间的完全平方奇数的个数是不是奇数了 这个就把两个端点开个方,左端点向上取整,右端点向下取整 然后算一下这中间的奇数有多少个就好了 #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int T; long long A, B, a, b, res; int main() { scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%lld%lld&quot;, &amp;A, &amp;B); a = ceil(sqrt(A)); b = floor(sqrt(B)); if(a &gt; b) res = 0; // the odd number between a and b else res = ((b-a+1)&gt;&gt;1)+(a&amp;1 &amp;&amp; b&amp;1); puts(res&amp;1 ? &quot;Yes&quot; : &quot;No&quot;); } return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"},{"name":"质因数分解","slug":"质因数分解","permalink":"http://kaizynx.github.io/tags/质因数分解/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]},{"title":"AtCoder-Triangular-Relationship","slug":"AtCoder-ABC108C","date":"2018-09-12T11:30:00.000Z","updated":"2022-04-10T07:52:45.120Z","comments":true,"path":"2018/09/12/AtCoder-ABC108C/","link":"","permalink":"http://kaizynx.github.io/2018/09/12/AtCoder-ABC108C/","excerpt":"","text":"AtCoder ABC 108 C - Triangular Relationship题意给出N，K，用1~N组成三元组(a, b, c) 使得a+b, b+c, a+c都是K的倍数 数据范围1≤N, K≤2e5 思路如果K为奇数, a, b, c为K的倍数 如果K为偶数, a, b, c为K/2的倍数 简单证明: 设a = na*K+x(na为自然数) 因为 a+b 是K的倍数 所以 b = nb*K-x(nb为自然数) 又因为 a+c 是K的倍数 所以 c = nc*K-x(nc为自然数) 又因为 b+c 也是K的倍数 所以 b+c = (nb+nc)K - 2x 即 2*x 是K的倍数 综上所述: 如果K为奇数, x是K的倍数 如果K为偶数, x是K/2的倍数 结论: 如果K为奇数, a, b, c为K的倍数 如果K为偶数, a, b, c为K/2的倍数 证毕 不妨设 a $\\geq$ b $\\geq$ c 当 a == b == c 时 只有一种排列组合 当 a == b &gt; c 时 有$C_3^1$种排列组合 当 a &gt; b == c 时 有$C_3^1$种排列组合 当 a &gt; b &gt; c 时 有$A_3^3$种排列组合 如果我们按 a $\\geq$ b $\\geq$ c 的顺序找下去 对于 a 取不同的值,容易证明这些排列组合不会重复 tip: 显然也可以看出K==1时候有N^3种，会爆int 超级暴力O(n^3) 枚举每种a, b, c的情况`cpp#include #include using namespace std; const int Maxn = 2e5+7; int n, k, add;long long ans; int main(){ scanf(“%d%d”, &amp;n, &amp;k); add = k&amp;1 ? k : k/2; for(int i = add; i &lt;= n; i += add) { for(int j = i; j &gt; 0; j -= k) { for(int j2 = j; j2 &gt; 0; j2 -= k) { if(i == j &amp;&amp; j == j2) ans++; else if(i == j || j == j2 || i == j2) ans += 3; else ans += 6; } } } printf(“%lld\\n”, ans); return 0;} --- 2. 简单优化至O(n^2) 当确定a, b的值时, 就已经可以确定c的值了 如果K为奇数, b 取 nb*K 那么c 就是 K ~ nb*K - 当 b == c 时 三种 - 当 b &gt; c 时， 即 c 在 K ~ (nb-1)*K 时，每类有6种 用一个简单的求和公式就可以求得总数为 $\\frac { ( 1+(nb-1) ) \\times ( nb-1 ) }{2} = \\frac { nb \\times (nb-1) } {2}$ 代码不在累赘 --- 3. 进一步计算得到O(n) 当 a 确定时, 即可计算出b, c的取值的方法总数 当 a 取 na*K - 当 a == b == c 时, 一种 - 当 a == b 时 c 取值 K ~ (na-1)*K, 故有3 * (na-1)种 - 当 b == c 时b,c取值 K ~ (na-1)*K, 也有3 * (na-1)种 - 当 a &gt; b &gt; c 时, 每种6个排列组合 当 b = (na-1)*K, c 有 na-2 种 当 b = (na-2)*K, c 有 na-3 种 ... 当 b = 2*K, c 有 1 种 就有$6*\\sum_{i=2}^{na-1}{i-1}$ 种 所以只需用一个数组保存一下这个前缀和 当时在比赛中就只想到这种地步了, 毕竟可以O(n)过了 数据也才10^5 (虽然有点奇怪怎么不是10^6) 然后我就把大部分时间花在处理K为奇偶数的问题上 还写了一个很骚皮的滚动数组 ```cpp #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 2e5+7; int n, k, cnt, add; long long ans; long long s[2][Maxn]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); if(k == 1) { printf(&quot;%lld\\n&quot;, 1ll*n*n*n); return 0; } add = k&amp;1 ? k : k/2; for(int i = add, cnt = 1; i &lt;= n; i += add, ++cnt) { // i i i ans++; // i i j &amp;&amp; i j j ans += (i/k-(i%k == 0))*3*2; s[0][cnt] = s[0][cnt-1]; s[1][cnt] = s[1][cnt-1]; s[i%k == 0][cnt] += i/k-(i%k == 0); // i j j2 ans += s[i%k == 0][cnt-1]*6; } printf(&quot;%lld\\n&quot;, ans); return 0; } 聪明的你不难发现 $\\sum_{i=2}^{na-1}{i-1}$ 是可以轻而易举求和的 $=\\sum_{i=1}^{na-2}{i} = \\frac{(nb-1) \\times (nb-2)}{2}$ 这连O(n)的辅助空间的省去了 数论奥秘之O(1) 以下就是比赛结束后我看见的大佬的代码 #include &lt;iostream&gt; using namespace std; long long cub(int x) { return 1ll * x * x * x; } int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; if (k &amp; 1) { cout &lt;&lt; cub(n/k) &lt;&lt; endl; } else { cout &lt;&lt; cub((n+k)/k) + cub(n/k) &lt;&lt; endl; } return 0; } 我琢磨了好几天终于搞明白了 就是在O(n)的基础上再数玄学推导 当 a 取 na*K 当 a == b == c 时, 一种 当 a == b 时 c 取值 K ~ (na-1)K, 故有3 (na-1)种 当 b == c 时b,c取值 K ~ (na-1)K, 也有3 (na-1)种 当 a &gt; b &gt; c 时, 每种6个排列组合 当 b = (na-1)*K, c 有 na-2 种 当 b = (na-2)*K, c 有 na-3 种 … 当 b = 2*K, c 有 1 种 就有$6 \\times \\sum_{i=2}^{na-1}{i-1}$ 种 $= 6 \\times \\sum_{i=1}^{na-2}{i}$ $= 6 \\times \\frac{(nb-1)*(nb-2)}{2}$ $= 3 \\times (nb-1) \\times (nb-2)$ 综上: 设$F{(i)}$是 a 取 i*K 时 $F(i) = 1+6 \\times (na-1)+3 \\times (nb-1)\\times (nb-2)$ $= 3 \\times {i^2} - 3 \\times i + 1$ 所以: 先设 a 的取值可以有 K ~ X*K $\\sum_{i=1}^{X}F(i)$ $= 3 \\times \\sum_{i=1}^{X}{i^2}+3 \\times \\sum_{i=1}^{X}{i}+3 \\times \\sum_{i=1}^{X}{1}$ 关于$\\sum_{i=1}^{X}{i^2}$其实我并不会, 百度可以查到的 $\\sum_{i=1}^{n}{i^2}=\\frac{n(n+1)(2n+1)}{6}$ 所以$\\sum_{i=1}^{X}F(i)$ $=一系列的化简略略略$ $=X^3$ 多么惊喜,多么意外 最后分类讨论 当 K 为奇数 显然有 X = ⌊$\\frac{N}{K}$⌋ 即 a = $K, 2K, 3K…⌊\\frac{N}{K}⌋*K$ 当 K 为偶数 a = $\\frac{1}{2}K, K,\\frac{3}{2}K…⌊\\frac{N}{\\frac{1}{2}K}⌋*K$ 我们可以分为 $K,2K…$ 和 $\\frac{1}{2}K,\\frac{3}{2}K…$ 前一类有 ⌊$\\frac{N}{K}$⌋个, 后一类就有 ⌊$\\frac{N+K}{K}$⌋ 后一类怎么出来的? 假设我们把 $\\frac{1}{2}K,\\frac{3}{2}K…$ 乘上2 就是 $K,3K,5K…$ 就是 $(0+1)K, (2+1)K, (4+1)K…$ 再把2除回去… 大致是这个意思吧… 证毕! 更新于2018-10-05 正解就在我得意地证明出了这一切 回头看了看官方的题解,瞬间爆炸 原文: K が奇数の時、 a,b,c を K で割ったあまりはすべて 0 である必要があります。 K が偶数の時、 a,b,c をK で割ったあまりはすべて 0 であるか、あるいはすべて K/2 である必要があります。このような組の個数は、 N 以下で K で割って 0 あまるものの個数と K/2 あまるものの個数から求めることができるので、この問題を解くことができました。 就是这么短,标程都懒得给了 意思大致是: 当 K 是奇数时 根据我上面的推理 a, b, c 可以选的是 K, 2K, 3K … 每个有 $\\frac{N}{K}$ 种选择 所以一共就有 $(\\frac{N}{K})^3$ 种 当 K 是偶数的时候 同理 注意此时是要分开算的 K 的整数倍还是有 $\\lfloor \\frac{N}{K} \\rfloor$ 种选择 K 的整数加半个倍的有 (这里想到一个简单理解的) 因为一共有 $\\lfloor \\frac{N}{K/2} \\rfloor$ 所以这个就是 $\\lfloor \\frac{N}{K/2} \\rfloor - \\lfloor \\frac{N}{K} \\rfloor$ 再现超短代码#include &lt;bits/stdc++.h&gt; using namespace std; int n, k; inline long long calc(int x) { return 1ll*x*x*x; } int main() { cin &gt;&gt; n &gt;&gt; k; if(k&amp;1) cout &lt;&lt; calc(n/k) &lt;&lt; endl; else cout &lt;&lt; calc(n/k)+calc(n/(k/2)-n/k) &lt;&lt; endl; return 0; }","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"AtCoder-ABC109","slug":"AtCoder-ABC109","date":"2018-09-08T14:05:29.000Z","updated":"2022-04-10T07:52:45.120Z","comments":true,"path":"2018/09/08/AtCoder-ABC109/","link":"","permalink":"http://kaizynx.github.io/2018/09/08/AtCoder-ABC109/","excerpt":"","text":"哈哈，又是每周一次的ABC这周只有ABC没有ARC，因此题目不是很难而我依然做不出来 A - ABC333超级水 题意给定A，B(1 &lt;= A, B &lt;= 3)，C在A，B之间(包含A, B)求是否有ABC为奇数 思路不妨设A &lt; B思路一： 打表法因为数据很小，总共只有6种情况(1, 1) (1, 2) (1, 3) (2, 2) (2, 3) (3, 3)手算一下都可以，很快的 思路二：辨证的思维因为在打表过程中发现自己打的和样例不符合因祸得福，发现了此题的真谛要求乘积为奇数，即乘积不是偶数而如果乘积为偶数，那么乘积可以被2整除因此三个数中不能出现偶数也就是不能有2因为A, B是确定的，两者间有2就肯定不行至于C嘛，判到C就说明A，B是没有2了C可选的为[A, B]，显然存在C==A或C==B那么C就可以取到奇数综上：只要A，B都不等于2，就是Yes， 否则为No #include &lt;iostream&gt; using namespace std; int a, b; int main() { cin &gt;&gt; a &gt;&gt; b; if(a == 2 || b == 2) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; return 0; } B - Shiritori也是很水的 题意：给N个单词,按顺序，要求前一个的末尾字符等于后一个首字符(即成语接龙),且这个单词之前没出现过 思路：真的是没有一点水准判断首尾很简单判断重复哈希表，用map轻松搞定 #include &lt;map&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 107; int n; char last; string str; map&lt;string, int&gt; m; int main() { cin &gt;&gt; n &gt;&gt; str; m.insert(make_pair(str, 1)); last = str[str.length()-1]; for(int i = 1; i &lt; n; ++i) { cin &gt;&gt; str; if(str[0] != last || m.count(str)) { cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0; } m.insert(make_pair(str, 1)); last = str[str.length()-1]; } cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; return 0; } C - Skip需要一点思考 题意给N个坐标轴上的点Xi以及起点X选择一个D，每次有两种移动方式① X+D ② X-D求D的最大值 思路一开始还觉得是二分根据样例可以找到一些规律的因为每步走的长度都一样，我们可以采用离散化的思想，把D看成单位长度1然后各个点之间的距离都离散一下可以发现如果有x1, x2, x3从小到大，且都能到达不存在这样的走法1-3-2, 也就是说要到3必须经过2，因为每步一样长因此把起点X和各个点Xi放在一起排序，相邻两点的距离一定可以被D整除那么就是gcd了 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int Maxn = 1e5+7; int n, ans, x[Maxn]; int gcd(int a, int b) { return b == 0 ? a : gcd(b, a%b); } int main() { scanf(&quot;%d%d&quot;, &amp;n, x); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, x+i); sort(x, x+n+1); ans = x[1]-x[0]; for(int i = 2; i &lt;= n; ++i) ans = gcd(ans, x[i]-x[i-1]); printf(&quot;%d\\n&quot;, ans); return 0; } D题没写出来，感觉挺简单可以写的，然而还是不会我一直不服，0不也是偶数吗 最后800名多点了，估计打ARC的都来ABC了，自我安慰","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"AtCoder-ABC108","slug":"AtCoder-ABC108","date":"2018-09-01T13:49:29.000Z","updated":"2022-04-10T07:52:45.119Z","comments":true,"path":"2018/09/01/AtCoder-ABC108/","link":"","permalink":"http://kaizynx.github.io/2018/09/01/AtCoder-ABC108/","excerpt":"","text":"今日九月一日晚，正是一年一度灾难开学日北京时间晚上八点整，正是一年一度的央视大型邪教教育片《开学第一课》的放映时间同时也是重要的AtCoder比赛开始的时间于是我毫不犹豫踌躇三分，最后开开心心忍痛割爱的抛弃了开学第一课，投入了ABC的怀抱 A - Pair大水题题意：给定整数N，求1~N中奇数和偶数的配对个数思路：如果N为偶数，奇数和偶数都为 N/2 个如果N为奇数，奇数有(N-1)/2个，即⌊N/2⌋个，偶数有(N+1)/2，即⌈N/2⌉个合并可得答案即为 ⌊N/2⌋*⌈N/2⌉由于C++ 的 int 向0取整的特性显然可得 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int k; int main() { scanf(&quot;%d&quot;, &amp;k); int a = k/2, b = (k+1)/2; printf(&quot;%d\\n&quot;, a*b); return 0; } B - Ruined Square水题题意：坐标轴上逆时针的正方形，四个点给出前两个求后两个思路：画一下就出来了，懒得数学推导，反正跟着一个样例的特殊的数字敲关系就出来了题目也许不水，被我水过了…… #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int x1, x2, x3, x4, y1, y2, y3, y4; int main() { scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); int a = x1-x2, b = y1-y2; x3 = x2+b; y3 = y2-a; x4 = x1+b; y4 = y1-a; printf(&quot;%d %d %d %d\\n&quot;, x3, y3, x4, y4); return 0; } tip：发现题目给得数据都是第二个点在第一个点右上方，怀疑有坑我把数据反过来输入，发现并无大碍 C - Triangular Relationship有点意思C题也就是ARC第一题了，如果去看ARC排名会发现一个有趣得现象七百多人参加，六十人写出三题从326到722都只写了第一题，就是C题想起上周参加ARC只写出一题的我，这次被迫来打ABC了哈哈 题意：给出N，K，用1~N组成三元组(a, b, c)使得a+b, b+c, a+c都是K的倍数数据范围1≤N,K≤2e5思路：看到数据范围就想着骚皮的做法了首先我想到假设三个数字一样，设为i, i, i,则显然成立如果把某个数字减去K(前提是能减),那么也显然还是成立那么要枚举这些情况，先定最大的为i，然后递减的枚举还想到如果K是偶数可以切一半怎样怎样的……最终没能做出来哈哈于是回归根本，写了个暴力的O(n^3)假设三个数单调递减发现三个数如果相同就一种排列两个相同就3种排列全不一样就有A(3,3)=6种排列tip: 显然也可以看出K==1时候有N^3种，会爆int #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 2e5+7; int n, k, add; long long ans; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); add = k&amp;1 ? k : k/2; for(int i = add; i &lt;= n; i += add) { for(int j = i; j &gt; 0; j -= k) { for(int j2 = j; j2 &gt; 0; j2 -= k) { if(i == j &amp;&amp; j == j2) ans++; else if(i == j || j == j2 || i == j2) ans += 3; else ans += 6; printf(&quot;%d %d %d %lld\\n&quot;, i, j, j2, ans); } } } printf(&quot;%lld\\n&quot;, ans); return 0; } 然后就可以进一步得出一些关系了根据数据范围，决定采用O(n)得算法对于递减得三个数i, j, j2 如果三个数相等只有一种 如果两个数相等要么 i == j 要么 j == j2 其中 i == j 得时候，j2 的选择有 i/k-(i%k == 0)种①如果 j2 是 k 的倍数，那么 j2 可选 k, 2k, 3k … i 有 i/k-1 种，-1是因为第一个为 0 不能取②如果j2 = n*k+k/2 那么就有 i/k种了 于是我聪明机智的得出了以上的式子 i/k-(i%k == 0) 如果三个数都不相等，假设递减，每种情况6种排列，但是有几对 j, j2呢如果 j == nk，j2就有 (n-1)k, (n-2)k … k如果 j == (n-1)k, j2 就有 (n-2)k, (n-3)k … k显然就是之前求得的 i/k-(i%k == 0) 式子的和了，我用 s[] 保存，就可以O(1)求出了但如果 j == nk+k/2 ，情况不同，但也类似，只是两种情况 s[] 要分开存赛场上我就凭借过人的机智想出了骚皮的滚动数组，详情见代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; const int Maxn = 2e5+7; int n, k, cnt, add; long long ans; long long s[2][Maxn]; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); if(k == 1) { printf(&quot;%lld\\n&quot;, 1ll*n*n*n); return 0; } add = k&amp;1 ? k : k/2; for(int i = add, cnt = 1; i &lt;= n; i += add, ++cnt) { // i i i ans++; // i i j &amp;&amp; i j j ans += (i/k-(i%k == 0))*3*2; s[0][cnt] = s[0][cnt-1]; s[1][cnt] = s[1][cnt-1]; s[i%k == 0][cnt] += i/k-(i%k == 0); // i j j2 ans += s[i%k == 0][cnt-1]*6; } printf(&quot;%lld\\n&quot;, ans); return 0; } 然后就A了，前两题用时20分钟，第三题想了一小时！最后剩下不到20分钟，最后一题就没写了(就算有时间也写不来)当时C题就这么草草过了，其实还有一些地方可以再推导赛后看了大佬的代码，颇为震惊，↓ #include &lt;iostream&gt; using namespace std; long long cub(int x) { return 1ll * x * x * x; } int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; if (k &amp; 1) { cout &lt;&lt; cub(n/k) &lt;&lt; endl; } else { k /= 2; cout &lt;&lt; cub((n+k)/k/2) + cub(n/k/2) &lt;&lt; endl; } return 0; } 有待思考 最后取得了第 300 名整的成绩，rating 74 –&gt; 309别管我为什么第一次才 74 …","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://kaizynx.github.io/tags/数学/"}],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"http://kaizynx.github.io/categories/AtCoder/"}]},{"title":"博客搭建","slug":"Blog_build","date":"2018-09-01T04:48:55.000Z","updated":"2022-04-10T07:52:45.125Z","comments":true,"path":"2018/09/01/Blog_build/","link":"","permalink":"http://kaizynx.github.io/2018/09/01/Blog_build/","excerpt":"","text":"序想做一个自己的博客，而网上的像CSDN之类广告太多，而且没法个性化设置，于是有了搭建自己博客的想法，恰巧在知乎上看到一个教程，免费，重点是能免费搞，于是乎……走上了一条不归路…… 声明本篇只是大致记录了一些我搭站过程中遇到的坑 至于博客搭建主体路线在别人的教程里 也就是说没什么事情看那些超链接就好… 起源就是这个 超详细Hexo+Github博客搭建小白教程 我看的第一篇教程，还是相当详细了，于是就按部就班开始了。 这里用的是 github 和 hexo 其中github可以用coding等代替，hexo可以用Jekyll代替 这里在给一篇用coding的文章 总之我是用github+hexo的，这套应该算是主流配置哈 之后就是一系列的坑了 建站安装hexo是用命令行装的，而用的指令是node.js的，所以要先装node.js这个问题不大 进入一个文件夹，要在里面 用下面的指令安装hexo npm install hexo-cli -g npm install hexo --save 然后我的那个文件夹里就有了一些不知什么东西 之后我就往下做 hexo init npm install 报错了，我以为正常的，其实错误的原因是文件夹不为空 解决方法：清空这个文件夹或新建一个文件夹 至于原本里面的东西，其实我也不知道什么用 这样之后就可以了 hexo g hexo s 就可以访问了，一切正常 再来是github与本地连接，因为我本来就是github用户，这个没什么问题，教程也有很详细的 我们在hexo init的文件夹第可以找到这样一个文件_config.yml这就是相当重要的配置文件了，文件末尾有这样的 deploy: type: 按照教程指示，改为 deploy: type: git repository: https://github.com/[你名字]/[你名字].github.io branch: master [你名字]就是你之前在github上建立的repository的名字 像type: git，type: 和 git之间一定要有空格 另外，repository:可以缩写为repo一些教程里用的是缩写，我差点没看懂 网址不要写错，我之前复制来的ssh是`git@github.com:KaizynX/KaizynX.github.io.git` 然后就报错了，中间的:应该改为/，不如自己敲吧 还有很重要的一点是之前建立github的respository的名字一定要和你gihub的用户名一样 比如我的github的用户名是KaizynX，respository的名字就是kaizynx.github.io，小写，我就是因为这个错误调了好久 在你gethub的respository的settings上会显示Your site is published at https://kaizynx.github.io/ 因为之前没有完全一致，会导致显示Your site is published at https://kaizynx.github.io/kaizyn.github.io 由此引发一些列不可估量的错误，虽然能访问，但是没法正常显示，如这位兄弟的情况 再者这篇教程中对于_config.yml的配置其实没讲清楚 看这里大概讲清楚了 url: http://[你名字].github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults: 其中有几行是这样的东西 你需要把第一行改一下 至此网站总算是可以用了hexo三部曲 hexo clean #清除缓存 hexo generate #生成 hexo deploy #部署 具体什么意思可以看百度之类，简写就是 hexo cl hexo g -d 部署之前应该要安装个git插件 npm install hexo-deployer-git --save 部署之后可能会跳出一个github的登陆窗口，也可能不会，没什么关系，然后你就可以访问你的网站了，如https://kaizynx.github.io注意是https 发布文章站是总算建好了，想起了我最初的目的——写博客 hexo new 名字 此时博客的目录结构大致如下 - node_modules - public - scaffolds - source - _posts - themes 都有什么用可以百度一下 在_posts中你就可以看到多了一个.md文件 这个就是你新建的博客，.md是markdown的格式 竟然是markdown格式，那总该有个IDE吧 推荐 当然得选一个可以本地编辑有客户端的 编辑完保存，再执行hexo三部曲，过一会你就可以看到你的博客更新了，至此似乎已经实现温饱了！ 20181029 还是vscode好,记一下语法就行了,没那么麻烦 但是怎么和我想的不太一样啊。 这套hexo+github的实质大概是你用markdown写一篇文章，hexo帮你生成html，部署到github上，是个静态的网页，你只能本地修改，本地上传 可我希望像CSDN那样在线发布的呀 革命尚未成功，同志仍需努力 更换主题其实我主题是很早就换了，默认的真是太丑了，换的早，坑也出现得早 因为换主题是步入小康社会，温饱还没解决的话就算了 至于教程，原来的那些教程就有，我觉得这篇比较好的 可以去官网找找，这篇推荐的也不错 推荐使用next主题，据说是人气最高的 为什么呢？我看上的是Tranquilpeak主题，结果踩了好多坑 一开始我用next，后来换那个，用next倒是啥事也没有，换了之后……唉 毕竟用的人多，bug改的快吧，而且出错了网上容易找参考文献 而我用的这个，几乎没有。好吧，就是没有一个直接的解决方案，有的都是擦边球 说说正文，安装方法，直接git clone到themes文件夹下就好，详情见教程 然后我们就可以在克隆来的主题文件夹中看到，里面的结构类似我们整个博客文件夹的结构 最重要的也是配置文件了_config.yml对，主题有属于它自己的配置 你可以在里面改一些，具体看对应文档吧 通过配置文件你可以改网页图标，背景图片等等之类的 这个就是深入改造了，现在还玩不起，总之不用改也能用 然后就来说说我选的这个主题的坑吧 会报错 ERROR Script load failed: themes/tranquilpeak/scripts/tags/tabbed_codeblock.js Error: Cannot find module &#39;jsdom&#39; 第一句不重要，第二句是关键，先不说怎么解决吧 当时第一次用这个主题，发现不能用，我多绝望了 看来看去就这个看的上眼呐 于是我回到它github的官网上寻求帮助，看看文档之类的 于是我换了一个安装方式(撤回我之前说的话) 这次我从releases下载了一个稳定版本，解压到themes文件夹 其实两个方法都可以 区别是我选了不同的版本，所以这次没问题了 插件安装 官网 其实我觉得并不需要什么额外插件就已经够用了 关于插件，其实我们之前做的 npm install hexo-deployer-git --save 就是在安装插件，而且我怀疑 npm install jsdom npm install jquery 也是插件，总上所述，安装插件还是一个相对简单的过程，一般也没什么配置 下面还是讲一下我的经历 后台管理 教程 这个插件是hexo admin 顾名思义就是你可以以管理员的身份登陆网站，并进行发布文章等操作 我一开始想实现我的伟大报复时，找到了这个 欣喜若狂的我迫不及待地装上了这个，且十分成功 就当我满怀希望觉得我能圆我美梦部署时 发现在github上无法进入admin界面 也就是说你只能在本地hexo s后，在本地爽爽 顿时失望透顶，原来也不过将hexo new ...换到了在网页上进行罢了 而且这个插件也没有markdown的语法帮助(虽然有预览) 据观察网上应该有界面更绚丽，功能更强大的插件 但由于无法实现我伟大报复，遂另寻其路 然后就有了下文的TravisCI大法 继续奋斗——TravisCI自动部署 参考一下这两篇文章① ② 讲的是借助 TravisCI 实现了只需git push就可以更新 也就是说在不同终端，不需要再装node.js和hexo，只要git (emmm) 虽然和设想差了一些(许多)不过勉强接受吧，毕竟静态网页，没钱买域名买服务器 具体实现讲得挺清楚了，虽然看着玄乎，两者结合着看也是弄下来了 首先要讲源代码存到github上，之前的是把hexo生成的html部署到github上 教程里做法没有说，于是出坑了。 首先到你的博客的文件夹，打开git bash然后git init一下 把remote加上。这个是git的基本操作，不说了 至于加那个remote，就原来那个好了，换个分枝 据说是可以再新建一个responsitory的，但是有点麻烦，也不知道有什么额外开销 git branch [新分枝名] 这个时候报错了 fatal: Not a valid object name: &#39;master&#39;. 可以参考这里解决 我是随便commit了一次就可以了 然后把所有的东西都发送到这个分枝 git三部曲 git add . git commit -m&quot;随便写些什么&quot; git push [remote的名字] [新分枝名] 再去看TravisCI，过一会就会有动静了，看见它正在帮你进行hexo三部曲 说明成功了(呸) 虽然换了个版本在自己电脑上通过了，但在TravisCI上出现了相同的问题 Error: Cannot find module &#39;jsdom&#39; 发现我的.travis.yml用的是这里的配置，感觉那两个不好用啊 然后在TravisCI上执行出来的又是没有格式的 我坚信不是我这里的锅了，本地依然完美，于是目光落到了 # 指定node_js版本 node_js: - 7.9.0 想想本地都可以的，本地版本10.8.0 换上似乎是有一定几率成功了 不过来说正解吧，解决问题的关键在于英语水平 错误：找不到模组’jsdom’ 姑且这么翻译吧，于是强行安装这个找不到的module 在我们的博客文件夹中打开命令行 npm install jsdom 就可以解决了，不过呢，修补完这个问题后还有一个，这次是 Error: Cannot find module &#39;jquery&#39; 同理 npm install jquery 之后git三部曲 TravisCI上就能顺利运行了，自动帮你hexo三部曲了 更新于2018-09-09 终于。。。又出错了 在TravisCI搞出来的也没有格式，哭了 一直也找不到什么原因，曾一度想放弃TravisCI大法过着安稳额hexo三部曲日子 直到我回到学校，试图把博客编辑总站迁移 前面可能说过吧，源代码都在那个文件夹，相当于这就是编辑总部 而不是像CSDN一样可以在网上发布 于是我从git上下载了 源代码 的分枝 在学校电脑上搭建了环境 进行了hexo二部曲，在本地打开服务器一看 竟然也是丢了格式 曾一度认为环境出了问题，转为只能在家工作的想法 不过还是找到问题所在了 原因是主题文件夹下面没有assert文件夹 因为什么头像啊背景啊图标啊之类的都在这个文件夹里面 而罪魁祸首竟然是.gitignore 是它把assert给忽略了！ 发现了这个让我感觉希望复燃，遂逐渐明白事件的来龙去脉 同理我在最高层文件夹检查了一下.gitignore，大致有个了解 .DS_Store #不知道，反正我没有 Thumbs.db #不知道，反正也没有 db.json #应该是和node.js有关的 *.log #各种日志 node_modules/ #node的模组? public/ #hexo g弄出的网页源代码 .deploy*/ #也没有，好像和什么节点有关 需要注意的3-6行吧 第5行估计就是本地能通过而在TravisCI上报错的原因了 在TravisCI上要重新安装node.js和hexo等 你在本地有的插件在那边不一定有 第6行就是网页源代码了吧，你发现git上master分枝的就是这里面的东西 所以TravisCI有一种写法是把public/的push到git的master分枝 而我用的则是在TravisCI上执行hexo d 最后给出我成功的.travis.yml代码 # 指定语言环境 language: node_js # 指定需要sudo权限 sudo: required # 指定node_js版本 node_js: - stable # 指定缓存模块，可选。缓存可加快编译速度。 #cache: # directories: # - node_modules branches: only: - source # S: Build Lifecycle before_install: - npm install hexo-cli -g install: - npm install - npm install hexo-deployer-git --save - npm install jsdom - npm install jquery # 执行清缓存，生成网页操作 script: - hexo clean - hexo generate # 设置git提交名，邮箱；替换真实token到_config.yml文件，最后depoy部署 after_script: - git config user.name &quot;KaizynX&quot; - git config user.email &quot;2291443901@qq.com&quot; # 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！ - sed -i &quot;s/gh_token/${GH_TOKEN}/g&quot; ./_config.yml - hexo deploy # End: Build LifeCycle # 方法一 #after_script: # - cd ./public # - git init # - git config user.name &quot;KaizynX&quot; # - git config user.email &quot;2291443901@qq.com&quot; # - git add . # - git commit -m &quot;Update Blog&quot; # - git push --force --quiet &quot;https://${GITHUB_TOKEN}@${GH_REF}&quot; master:master # E: Build LifeCycle #env: # global: # - GH_REF: github.com:KaizynX/KaizynX.github.io.git 我还遇到过的一个坑是在TravisCI连 npm install hexo-cli -g 都运行不了，报错，这个百度可以解决好像是什么缓存问题错误代码如下 npm ERR! code ERR_TLS_CERT_ALTNAME_INVALID npm ERR! errno ERR_TLS_CERT_ALTNAME_INVALID npm ERR! request to https://registry.npmjs.org/hexo-cli failed, reason: Hostname/IP does not match certificate&#39;s altnames: Host: registry.npmjs.org. is not in the cert&#39;s altnames: DNS:a.sni.fastly.net, DNS:a.sni.global-ssl.fastly.net 解决吗我也没实质性解决过吧，你们自己百度吧 网页进阶 这部分内容还是参照不同主题的不同文档 在他们github的页面上可以找到 参照下一篇 博客进阶","categories":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kaizynx.github.io/tags/Blog/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://kaizynx.github.io/categories/技术/"}]},{"title":"烹调方案","slug":"Luogu-P1417","date":"2018-08-31T13:33:36.000Z","updated":"2022-04-10T07:52:45.137Z","comments":true,"path":"2018/08/31/Luogu-P1417/","link":"","permalink":"http://kaizynx.github.io/2018/08/31/Luogu-P1417/","excerpt":"","text":"Luogu P1417 烹调方案摘自tinylic的题解: 现在考虑相邻的两个物品x,y。假设现在已经耗费p的时间，那么分别列出先做x,y的代价： ①a[x]-(p+c[x])b[x]+a[y]-(p+c[x]+c[y])by ②a[y]-(p+c[y])b[y]+a[x]-(p+c[y]+c[x])bx ==&gt; ①a[x]-(p+c[x])b[x]+a[y]-(p+c[x]+c[y])b[y] ②a[x]-(p+c[x]+c[y])b[x]+a[y]-(p+c[y])b[y] 消去相同的项后得 ①c[x]*b[y] ②c[y]*b[x] 所以 对这两个式子化简，得到①＞②的条件是c[x]b[y]&lt;c[y]b[x] 发现只要满足这个条件的物品对(x,y)，x在y前的代价永远更优 再然后很多人都错在了没开long long上 其实本来也没有这个坑,踩的人多了就成了坑 对于某个食物i,在时刻t完成的价值是ai-t*bi 显然,当t&gt;ai/bi时,价值&lt;0 而选择不做这个食物所获的价值为0 所以对每个食物进行背包的状态更新时,我们只需要枚举的下标范围缩小到[ ci, min(T, ⌊ai/bi⌋) ] (ai/bi向下取整) 转移方程dp[j] = max(dp[j], dp[j-ci]+ai-j*bi) 此时j*bi &lt;= (ai/bi)bi = ai &lt;= 100000 就不会爆了 (以上纯属搞笑) 再者还有一个爆int的地方是排序时ci*bi 本人亲身体验这里不会爆(逃) 下面就是理论上不完美但是能AC还附魔一点优化的代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int Maxn = 60; const int Maxt = 1e5+7; int T, n, res; int dp[Maxt]; struct Food { int a, b, c; bool operator &lt; (const Food &amp;nex) const { return b*nex.c &gt; c*nex.b; } } f[Maxn]; int main() { scanf(&quot;%d%d&quot;, &amp;T, &amp;n); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;f[i].a); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;f[i].b); for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;f[i].c); sort(f+1, f+n+1); for(int i = 1; i &lt;= n; ++i) for(int j = min(T, f[i].a/f[i].b); j &gt;= f[i].c; --j) dp[j] = max(dp[j], dp[j-f[i].c]+f[i].a-j*f[i].b); for(int i = 1; i &lt;= T; ++i) res = max(res, dp[i]); printf(&quot;%d\\n&quot;, res); return 0; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://kaizynx.github.io/tags/DP/"}],"keywords":[{"name":"Luogu","slug":"Luogu","permalink":"http://kaizynx.github.io/categories/Luogu/"}]}]}