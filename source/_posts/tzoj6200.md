---
title: TZOJ6200 图的生成树
author: Kaizyn
avatar: https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/custom/avatar.jpg
authorLink: https://kaizynx.github.io/
date: 2020-08-30 21:30:00
categories:
  - ACM
tags:
  - 最小生成树
  - 树上倍增
description: 树论题
photos: https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/posts/tzoj6200/cover.jpg
---
# 题面

[链接](http://www.tzcoder.cn/acmhome/problemdetail.do?method=showdetail&id=6200)

## 描述

桃子现在有一张无向无自环无重边的图，图上有N个点和M条边，现在他想知道，如果固定一条边，再来求一个图上的最小生成树，并且在使得在最小生成树根为1的情况下，新的生成树移动的点数最多。

生成树：任意两个点连通，并且任意两个点之间有且仅有一条路径。

生成树权值和：生成树每一条边的权值w总和。

最小生成树：满足生成树的前提下，权值和w最小。

自环：u和v相同。

重边：(1,2)和(1,2)。

## 输入

第一行两个正整数N，M（1<=N<=10^5，N-1<=M<=10^5），代表点数和边数。

接下来M条边，（u，v，w），(1<=u，v<=N，1<=w<=10^9)，代表u和v之间有一条w长度的边。

数据保证所有生成树存在，并且权值w各不相同。

## 输出

输出M行，每行输出两个数，第一个数代表固定一条边的生成树权值和，第二个数是最多有多少个点需要跟着移动，两个数之间用空格隔开。

## 样例输入

```
4 4
1 2 40
2 3 20
1 4 30
2 4 50
```

## 样例输出

```
90 0
90 0
90 0
100 2
```

## 提示

样例中最小生成树连的边为(1,2,40)和(2,3,20)和(1,4,30)。

固定(1,2,10)和(2,3,20)和(1,4,30)时新的生成树未发生变化。

固定(2,4,50)时新的最小生成树中最多变化的情况是2接到4下，此时变化了两个点，2和3。

# 思路

首先嘛这个题意就该死的买看懂,什么叫做新的生成树移动的点数嘛

不过当你会写了自然就懂了(阿哲

先搞出最小生成树嘛,如果选定最小生成树上的边自然没影响

如果选定的不是最小生成树上的边,我们不考虑重新建树,而是改造最小生成树

相当于加入了一条边 (u, v, w) ,那么树上就会形成一个环

因为最小生成树上的边已经是最优的(边权各不相同,不存在并列最优)

所以不可能改动其他边,最优的做法是删掉环上边权最大的边,使得剩余的还是树

那么这个环就是 u, v 以及他俩一直沿父亲向上到 最近公共祖先 的环

此时我们再看这波加边删边改变了什么,什么叫做新的生成树移动的点数

稍微作图即可发现移动的点就是删除的那条边下面的那个子树

(自己作图自己意会)

以上这些操作可以用树剖或者树上倍增实现(当然是选择倍增啦

复杂度 O((n+m)logn)

# 代码

{% spoiler "代码" %}
```cpp
#include <bits/stdc++.h>

// #define DEBUG

using namespace std;

const double eps = 1e-7;
const double PI = acos(-1);
typedef pair<int, int> pii;
const int MOD = 998244353;
const int INF = 0x3f3f3f3f;
const int N = 1e5+7;
const int NN = (int)log2(N)+3;

struct Edge {
  int u, v, w, id;
  friend bool operator <(const Edge &e1, const Edge &e2) {
    return e1.w < e2.w;
  }
  friend istream& operator >>(istream &is, Edge &e) {
    return is >> e.u >> e.v >> e.w;
  }
};

struct DSU {
  int fa[N];
  void init(int sz) { for (int i = 0; i <= sz; ++i) fa[i] = i; }
  int get(int s) { return s == fa[s] ? s : fa[s] = get(fa[s]); }
  int& operator [] (int i) { return fa[get(i)]; }
  bool merge(int x, int y) { // merge x to y
    int fx = get(x), fy = get(y);
    if (fx == fy) return false;
    fa[fx] = fy; return true;
  }
};

int n, m;
vector<pii> e[N];
DSU dsu;
Edge edge[N];
long long sum;
long long res1[N];
int res2[N], val[N], num[N];
int f[N][NN], d[N], lg2[N];
long long w[N][NN];

int update(const int &x, const int &y) {
  return val[x] < val[y] ? y : x;
}

void build(const int &u = 1, const int &fa = 0) {
  num[u] = 1;
  d[u] = d[fa]+1;
  f[u][0] = fa;
  for (int i = 1; (1<<i) <= d[u]; ++i) {
    f[u][i] = f[f[u][i-1]][i-1];
    w[u][i] = update(w[u][i-1], w[f[u][i-1]][i-1]);
  }
  for (auto &v : e[u]) if (v.first != fa) {
    w[v.first][0] = v.first;
    val[v.first] = v.second;
    build(v.first, u);
    num[u] += num[v.first];
  }
}

int fuck(int x, int y) {
  int res = 0;
  if (d[x] < d[y]) swap(x, y);
  while (d[x] > d[y]) {
    res = update(res, w[x][lg2[d[x]-d[y]]]);
    x = f[x][lg2[d[x]-d[y]]];
  }
  if (x == y) return res;
  for (int i = lg2[d[x]]; i >= 0; --i)
    if(f[x][i] != f[y][i]) {
      res = update(res, w[x][i]);
      res = update(res, w[y][i]);
      x = f[x][i], y = f[y][i];
    }
  return update(res, update(w[x][0], w[y][0]));
}

signed main() {
  ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
  for (int i = 2; i < N; ++i) lg2[i] = lg2[i>>1]+1;

  cin >> n >> m;
  for (int i = 1; i <= m; ++i) {
    cin >> edge[i];
    edge[i].id = i;
  }

  sort(edge+1, edge+m+1);
  dsu.init(n);
  memset(res2, -1, sizeof res2);
  for (int i = 1, u, v, w, id; i <= m; ++i) {
    u = edge[i].u;
    v = edge[i].v;
    w = edge[i].w;
    id = edge[i].id;
    if (dsu.merge(u, v)) {
      sum += w;
      res2[id] = 0;
      e[u].emplace_back(v, w);
      e[v].emplace_back(u, w);
    }
  }
  build();
  for (int i = 1, u, v, w, id; i <= m; ++i) {
    u = edge[i].u;
    v = edge[i].v;
    w = edge[i].w;
    id = edge[i].id;
    if (res2[id] != -1) {
      res1[id] = sum;
    } else {
      int p = fuck(u, v);
      res1[id] = sum+w-val[p];
      res2[id] = num[p];
    }
  }
  for (int i = 1; i <= m; ++i) {
    cout << res1[i] << " " << res2[i] << endl;
  }
  return 0;
}
```

{% endspoiler %}