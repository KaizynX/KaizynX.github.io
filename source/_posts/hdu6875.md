---
title: 杭电多校2020第9场1009 Yajilin
author: Kaizyn
avatar: https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/custom/avatar.jpg
authorLink: https://kaizynx.github.io/
date: 2020-08-19 21:15:00
mathjax: true
categories:
  - ACM
tags:
  - 插头DP
description: 插头DP
photos: https://cdn.jsdelivr.net/gh/KaizynX/cdn/img/posts/hdu6875/cover.jpg
---
# 题面

[hdu6875](http://acm.hdu.edu.cn/showproblem.php?pid=6875)

给 n*n 的平面, 每个点有权值

求把一些点涂黑,要求黑点不共边,且所有白点能形成**一条回路**

求黑点权值和最大是多少

# 题解

大家都能一眼看出来是典型的插头dp了

[Luogu P5056 【模板】插头dp](https://www.luogu.com.cn/problem/P5056)

没错,确实就是插头dp的入门题型,稍加变形,题解也就一句话

> 插头dp，在求哈密尔顿回路路的基础上对每个格⼦子加上⼀一个状态表示是否为⿊黑格即可。

## 前置

做这道题的前提是你把上述模板题搞懂

那么就在模板题的基础上讲,按照[此人题解](https://www.cnblogs.com/y2823774827y/p/10140757.html)讲

## 定义

- `state` 为当前轮廓线的二进制状态
- `b1`,`b2` 分别表示右插头和下插头
- 0表示无插头,1表示左端点,2表示右端点, **3表示涂黑**(增加的状态)

其他转移其实和模板题一样,不同的地方就是涂黑的情况和结束情况

## 涂黑情况

因为限制黑格不能上下左右相邻,所以当且仅当右插头和下插头都为0时才能涂黑

小技巧:特判涂黑之后,使3(涂黑)和0(无插头)等价,之后就真的一模一样不用改了

## 结束情况

由于黑格不能上下左右相邻,所以不可能扫描到一半终止(下面全黑)

只可能有两种情况

- 能在最后一格闭合回路(`b1==1 && b2 == 2`)
- 最后一格涂黑,在倒数第二格闭合回路

特判即可,注意最后一格涂黑的前提是倒数第二行最后一格不涂黑

## 还有一点

模板题求的是方案数,所以 `dp` 是各种情况相加

这题求的是最值,那么,那么就取最值呗

# 代码
{% spoiler "代码" %}
```cpp
#include <bits/stdc++.h>

// #define DEBUG

using namespace std;

typedef pair<int, int> pii;
typedef long long ll;
const int P = 1572869; // 3145739
const int INF = 0x3f3f3f3f;
const int N = 1e1+7;

int n;
int a[N][N];
int dp[2][P];
int head[2][P], nex[2][P], tot[2], ver[2][P];

inline void clear(const int &u) {
  for (int i = 0; i <= tot[u]; ++i) {
    dp[u][i] = 0;
    nex[u][i] = 0;
    head[u][ver[u][i]%P] = 0;
  }
  tot[u] = 0;
}

inline void insert(const int &u, const int &x, const int &v) {
  int p = x%P;
  for (int i = head[u][p]; i; i = nex[u][i]) {
    if (ver[u][i] == x) return dp[u][i] = max(dp[u][i], v), void();
  }
  ++tot[u];
  ver[u][tot[u]] = x;
  nex[u][tot[u]] = head[u][p];
  head[u][p] = tot[u];
  dp[u][tot[u]] += v;
}

inline int solve() {
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      cin >> a[i][j];
    }
  }
  int u = 0, res = 0, base = (1<<n*2+2)-1;
  clear(u);
  insert(u, 0, 0);
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= n; ++j) {
      clear(u ^= 1);
      for (int k = 1; k <= tot[u^1]; ++k) {
        int state = ver[u^1][k], val = dp[u^1][k];
        if (j == 1) state = (state<<2)&base;
        // b1 right b2 down
        // 0 no 1 left 2 right 3 black
        int b1 = (state>>j*2-2)%4, b2 = (state>>j*2)%4;
        // 处理能涂黑的情况
        if (!b1 && !b2) insert(u, state+(3<<j*2-2)+(3<<j*2), val+a[i][j]);
        if (b1 == 3) state -= 3<<j*2-2, b1 = 0;
        if (b2 == 3) state -= 3<<j*2, b2 = 0;
        // 一下操作和模板题完全一致
        if (!b1 && !b2) {
          if (i < n && j < n) insert(u, state+(1<<j*2-2)+(2<<j*2), val);
        } else if (!b1 && b2) {
          if (j < n) insert(u, state, val);
          if (i < n) insert(u, state+(b2<<j*2-2)-(b2<<j*2), val);
        } else if (b1 && !b2) {
          if (i < n) insert(u, state, val);
          if (j < n) insert(u, state-(b1<<j*2-2)+(b1<<j*2), val);
        } else if (b1 == 1 && b2 == 1) { // find 2 turn to 1
          for (int k = j+1, t = 1; k <= n; ++k) {
            if ((state>>k*2)%4 == 1) ++t;
            if ((state>>k*2)%4 == 2) --t;
            if (!t) { insert(u, state-(1<<j*2-2)-(1<<j*2)-(1<<k*2), val); break; }
          }
        } else if (b1 == 2 && b2 == 2) { // find 1 turn to 2
          for (int k = j-2, t = 1; k >= 0; --k) {
            if ((state>>k*2)%4 == 1) --t;
            if ((state>>k*2)%4 == 2) ++t;
            if (!t) { insert(u, state-(2<<j*2-2)-(2<<j*2)+(1<<k*2), val); break; }
          }
        } else if (b1 == 2 && b2 == 1) {
          insert(u, state-(2<<j*2-2)-(1<<j*2), val);
        } else if (b1 == 1 && b2 == 2) {
          // 结束条件的特判
          if (i < n) continue;
          if (j == n-1) {
            if ((state>>n*2)%4 != 3) res = max(res, val+a[n][n]);
          } else if (j == n) {
            res = max(res, val);
          }
        }
      }
    }
  }
  return res;
}

signed main() {
  ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
  int T = 1;
  cin >> T;
  for (int t = 1; t <= T; ++t) {
    cout << solve() << endl;
  }
  return 0;
}
```

{% endspoiler %}

# 总结

这题确实感觉就是很基础的插头dp题型,我是恰好暑假开始的时候才学了插头dp,有幸拿了一血

但赛场上这题惨不忍睹,最后只有三个队伍过了,还wa上加wa(我1a1b感到无比自豪)

可能插头dp确实不简单(实不相瞒我洛谷那道入门模板题肝了起码一天吧)

另一方面可能插头dp的题并不常见,甚至罕见,人生能有一次这样的高光时刻可遇而不可求,感谢出题人XP